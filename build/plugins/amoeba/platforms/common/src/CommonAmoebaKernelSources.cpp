/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CommonAmoebaKernelSources.h"

using namespace OpenMM;
using namespace std;

const string CommonAmoebaKernelSources::amoebaGk = "#define TILE_SIZE 32\n"
"\n"
"/**\n"
" * Reduce the Born sums to compute the Born radii.\n"
" */\n"
"KERNEL void reduceBornSum(GLOBAL const mm_long* RESTRICT bornSum, GLOBAL const float2* RESTRICT params, GLOBAL real* RESTRICT bornRadii) {\n"
"    for (unsigned int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        // Get summed Born data\n"
"\n"
"        real sum = RECIP((real) 0x100000000)*bornSum[index];\n"
"\n"
"        // Now calculate Born radius.\n"
"\n"
"        float radius = params[index].x;\n"
"        radius = RECIP(radius*radius*radius);\n"
"        sum = radius-sum;\n"
"        sum = (sum <= 0 ? (real) 1000 : POW(sum, -1/(real) 3));\n"
"        bornRadii[index] = sum;\n"
"    }\n"
"}\n"
"\n"
"#ifdef SURFACE_AREA_FACTOR\n"
"/**\n"
" * Apply the surface area term to the force and energy.\n"
" */\n"
"KERNEL void computeSurfaceAreaForce(GLOBAL mm_long* RESTRICT bornForce, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const float2* RESTRICT params, GLOBAL const real* RESTRICT bornRadii) {\n"
"    mixed energy = 0;\n"
"    for (unsigned int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        real bornRadius = bornRadii[index];\n"
"        float radius = params[index].x;\n"
"        real r = radius + DIELECTRIC_OFFSET + PROBE_RADIUS;\n"
"        real ratio6 = (radius+DIELECTRIC_OFFSET)/bornRadius;\n"
"        ratio6 = ratio6*ratio6*ratio6;\n"
"        ratio6 = ratio6*ratio6;\n"
"        real saTerm = SURFACE_AREA_FACTOR * r * r * ratio6;\n"
"        bornForce[index] += (mm_long) (saTerm*0x100000000/bornRadius);\n"
"        energy += saTerm;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] -= energy/6;\n"
"}\n"
"#endif\n"
"\n"
"/**\n"
" * Data structure used by computeBornSum().\n"
" */\n"
"typedef struct {\n"
"    real3 pos;\n"
"    real bornSum;\n"
"    float radius, scaledRadius, padding;\n"
"} AtomData1;\n"
"\n"
"DEVICE real computeBornSumOneInteraction(AtomData1 atom1, AtomData1 atom2) {\n"
"    if (atom1.radius <= 0)\n"
"        return 0; // Ignore this interaction\n"
"    real3 delta = atom2.pos - atom1.pos;\n"
"    real r2 = dot(delta, delta);\n"
"    real r = SQRT(r2);\n"
"    float sk = atom2.scaledRadius;\n"
"\n"
"    if (atom1.radius > r + sk)\n"
"        return 0; // No descreening due to atom1 engulfing atom2.\n"
"\n"
"    real sk2 = sk*sk;\n"
"    if (atom1.radius+r < sk) {\n"
"        real lik = atom1.radius;\n"
"        real uik = sk - r; \n"
"        atom1.bornSum -= RECIP(uik*uik*uik) - RECIP(lik*lik*lik);\n"
"    }\n"
"    real uik = r+sk;\n"
"    real lik;\n"
"    if (atom1.radius+r < sk)\n"
"        lik = sk-r;\n"
"    else if (r < atom1.radius+sk)\n"
"        lik = atom1.radius;\n"
"    else\n"
"        lik = r-sk;\n"
"    real l2 = lik*lik; \n"
"    real l4 = l2*l2;\n"
"    real lr = lik*r;\n"
"    real l4r = l4*r; \n"
"    real u2 = uik*uik;\n"
"    real u4 = u2*u2;\n"
"    real ur = uik*r; \n"
"    real u4r = u4*r;\n"
"    real term = (3*(r2-sk2)+6*u2-8*ur)/u4r - (3*(r2-sk2)+6*l2-8*lr)/l4r;\n"
"    return term/16;\n"
"}\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"KERNEL void computeBornSum(GLOBAL mm_ulong* RESTRICT bornSum, GLOBAL const real4* RESTRICT posq,\n"
"        GLOBAL const float2* RESTRICT params, unsigned int numTiles) {\n"
"    unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    unsigned int pos = (unsigned int) (warp*(mm_long)numTiles/totalWarps);\n"
"    unsigned int end = (unsigned int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    LOCAL AtomData1 localData[BORN_SUM_THREAD_BLOCK_SIZE];\n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"        const unsigned int tbx = LOCAL_ID - tgx;\n"
"        int x, y;\n"
"        AtomData1 data;\n"
"        data.bornSum = 0;\n"
"        if (pos < end) {\n"
"            y = (int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            data.pos = trimTo3(posq[atom1]);\n"
"            float2 params1 = params[atom1];\n"
"            data.radius = params1.x;\n"
"            data.scaledRadius = params1.y;\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                localData[LOCAL_ID].pos = data.pos;\n"
"                localData[LOCAL_ID].radius = params1.x;\n"
"                localData[LOCAL_ID].scaledRadius = params1.y;\n"
"                SYNC_WARPS;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+j;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                        real bornSum = computeBornSumOneInteraction(data, localData[tbx+j]);\n"
"                        data.bornSum += bornSum;\n"
"                    }\n"
"                }\n"
"                SYNC_WARPS;\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                if (lasty != y) {\n"
"                    unsigned int j = y*TILE_SIZE + tgx;\n"
"                    real4 tempPosq = posq[j];\n"
"                    localData[LOCAL_ID].pos = trimTo3(tempPosq);\n"
"                    float2 tempParams = params[j];\n"
"                    localData[LOCAL_ID].radius = tempParams.x;\n"
"                    localData[LOCAL_ID].scaledRadius = tempParams.y;\n"
"                }\n"
"                localData[LOCAL_ID].bornSum = 0;\n"
"                SYNC_WARPS;\n"
"                \n"
"                // Compute the full set of interactions in this tile.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+tj;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real bornSum = computeBornSumOneInteraction(data, localData[tbx+tj]);\n"
"                        data.bornSum += bornSum;\n"
"                        bornSum = computeBornSumOneInteraction(localData[tbx+tj], data);\n"
"                        localData[tbx+tj].bornSum += bornSum;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.\n"
"        \n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&bornSum[offset], (mm_ulong) ((mm_long) (data.bornSum*0x100000000)));\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&bornSum[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].bornSum*0x100000000)));\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    } while (pos < end);\n"
"}\n"
"\n"
"/**\n"
" * Data structure used by computeGKForces().\n"
" */\n"
"typedef struct {\n"
"    real3 pos, force, dipole, inducedDipole, inducedDipolePolar;\n"
"    real quadrupoleXX, quadrupoleXY, quadrupoleXZ;\n"
"    real quadrupoleYY, quadrupoleYZ, quadrupoleZZ;\n"
"    real q, bornRadius, bornForce;\n"
"} AtomData2;\n"
"\n"
"DEVICE void computeOneInteractionF1(AtomData2 atom1, volatile AtomData2 atom2, real* outputEnergy, real3* force);\n"
"DEVICE void computeOneInteractionF2(AtomData2 atom1, volatile AtomData2 atom2, real* outputEnergy, real3* force);\n"
"DEVICE void computeOneInteractionT1(AtomData2 atom1, volatile AtomData2 atom2, real3* torque);\n"
"DEVICE void computeOneInteractionT2(AtomData2 atom1, volatile AtomData2 atom2, real3* torque);\n"
"DEVICE void computeOneInteractionB1B2(AtomData2 atom1, volatile AtomData2 atom2, real* bornForce1, real* bornForce2);\n"
"\n"
"inline DEVICE AtomData2 loadAtomData2(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT labFrameDipole,\n"
"        GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const real* RESTRICT bornRadius) {\n"
"    AtomData2 data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = trimTo3(atomPosq);\n"
"    data.q = atomPosq.w;\n"
"    data.dipole.x = labFrameDipole[atom*3];\n"
"    data.dipole.y = labFrameDipole[atom*3+1];\n"
"    data.dipole.z = labFrameDipole[atom*3+2];\n"
"    data.quadrupoleXX = labFrameQuadrupole[atom*5];\n"
"    data.quadrupoleXY = labFrameQuadrupole[atom*5+1];\n"
"    data.quadrupoleXZ = labFrameQuadrupole[atom*5+2];\n"
"    data.quadrupoleYY = labFrameQuadrupole[atom*5+3];\n"
"    data.quadrupoleYZ = labFrameQuadrupole[atom*5+4];\n"
"    data.quadrupoleZZ = -(data.quadrupoleXX+data.quadrupoleYY);\n"
"    data.inducedDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"    data.inducedDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"    data.bornRadius = bornRadius[atom];\n"
"    return data;\n"
"}\n"
"\n"
"/**\n"
" * Compute electrostatic interactions.\n"
" */\n"
"KERNEL void computeGKForces(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, unsigned int startTileIndex, unsigned int numTileIndices, GLOBAL const real* RESTRICT labFrameDipole,\n"
"        GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"        GLOBAL const real* RESTRICT bornRadii, GLOBAL mm_ulong* RESTRICT bornForce) {\n"
"    unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    unsigned int pos = (unsigned int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    unsigned int end = (unsigned int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData2 localData[GK_FORCE_THREAD_BLOCK_SIZE];\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"        const unsigned int tbx = LOCAL_ID - tgx;\n"
"        int x, y;\n"
"        if (pos < end) {\n"
"            y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            AtomData2 data = loadAtomData2(atom1, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, bornRadii);\n"
"            data.force = make_real3(0);\n"
"            data.bornForce = 0;\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                localData[LOCAL_ID].pos = data.pos;\n"
"                localData[LOCAL_ID].q = data.q;\n"
"                localData[LOCAL_ID].dipole = data.dipole;\n"
"                localData[LOCAL_ID].quadrupoleXX = data.quadrupoleXX;\n"
"                localData[LOCAL_ID].quadrupoleXY = data.quadrupoleXY;\n"
"                localData[LOCAL_ID].quadrupoleXZ = data.quadrupoleXZ;\n"
"                localData[LOCAL_ID].quadrupoleYY = data.quadrupoleYY;\n"
"                localData[LOCAL_ID].quadrupoleYZ = data.quadrupoleYZ;\n"
"                localData[LOCAL_ID].quadrupoleZZ = data.quadrupoleZZ;\n"
"                localData[LOCAL_ID].inducedDipole = data.inducedDipole;\n"
"                localData[LOCAL_ID].inducedDipolePolar = data.inducedDipolePolar;\n"
"                localData[LOCAL_ID].bornRadius = data.bornRadius;\n"
"                SYNC_WARPS;\n"
"                \n"
"                // Compute forces.\n"
"                \n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+j;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempForce;\n"
"                        real tempEnergy;\n"
"                        computeOneInteractionF1(data, localData[tbx+j], &tempEnergy, &tempForce);\n"
"                        computeOneInteractionF2(data, localData[tbx+j], &tempEnergy, &tempForce);\n"
"                        data.force += tempForce;\n"
"                        energy += 0.5f*tempEnergy;\n"
"                    }\n"
"                }\n"
"                SYNC_WARPS;\n"
"                data.force *= 0.5f;\n"
"                ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"                \n"
"                // Compute torques.\n"
"                \n"
"                data.force = make_real3(0);\n"
"                data.bornForce = 0;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+j;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempTorque;\n"
"                        computeOneInteractionT1(data, localData[tbx+j], &tempTorque);\n"
"                        computeOneInteractionT2(data, localData[tbx+j], &tempTorque);\n"
"                        data.force += tempTorque;\n"
"                    }\n"
"                }\n"
"                SYNC_WARPS;\n"
"                ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"                \n"
"                // Compute chain rule terms.\n"
"                \n"
"                data.force = make_real3(0);\n"
"                data.bornForce = 0;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+j;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real bornForce1 = 0, bornForce2 = 0;\n"
"                        computeOneInteractionB1B2(data, localData[tbx+j], &bornForce1, &bornForce2);\n"
"                        data.bornForce += bornForce1;\n"
"                        localData[tbx+j].bornForce += bornForce2;\n"
"                        SYNC_WARPS;\n"
"                    }\n"
"                }\n"
"                ATOMIC_ADD(&bornForce[atom1], (mm_ulong) ((mm_long) (data.bornForce*0x100000000)));\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                localData[LOCAL_ID] = loadAtomData2(j, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, bornRadii);\n"
"                localData[LOCAL_ID].force = make_real3(0);\n"
"                localData[LOCAL_ID].bornForce = 0;\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+tj;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempForce;\n"
"                        real tempEnergy;\n"
"                        computeOneInteractionF1(data, localData[tbx+tj], &tempEnergy, &tempForce);\n"
"                        computeOneInteractionF2(data, localData[tbx+tj], &tempEnergy, &tempForce);\n"
"                        data.force += tempForce;\n"
"                        localData[tbx+tj].force -= tempForce;\n"
"                        energy += tempEnergy;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"                data.force *= 0.5f;\n"
"                localData[LOCAL_ID].force *= 0.5f;\n"
"                if (pos < end) {\n"
"                    unsigned int offset = x*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"                    offset = y*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"                }\n"
"\n"
"                // Compute torques.\n"
"\n"
"                data.force = make_real3(0);\n"
"                data.bornForce = 0;\n"
"                localData[LOCAL_ID].force = make_real3(0);\n"
"                localData[LOCAL_ID].bornForce = 0;\n"
"                SYNC_WARPS;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+tj;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempTorque;\n"
"                        computeOneInteractionT1(data, localData[tbx+tj], &tempTorque);\n"
"                        computeOneInteractionT2(data, localData[tbx+tj], &tempTorque);\n"
"                        data.force += tempTorque;\n"
"                        computeOneInteractionT1(localData[tbx+tj], data, &tempTorque);\n"
"                        computeOneInteractionT2(localData[tbx+tj], data, &tempTorque);\n"
"                        localData[tbx+tj].force += tempTorque;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"                if (pos < end) {\n"
"                    unsigned int offset = x*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"                    offset = y*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"                }\n"
"\n"
"                // Compute chain rule terms.\n"
"\n"
"                data.force = make_real3(0);\n"
"                data.bornForce = 0;\n"
"                localData[LOCAL_ID].force = make_real3(0);\n"
"                localData[LOCAL_ID].bornForce = 0;\n"
"                SYNC_WARPS;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+tj;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real bornForce1 = 0, bornForce2 = 0;\n"
"                        computeOneInteractionB1B2(data, localData[tbx+tj], &bornForce1, &bornForce2);\n"
"                        data.bornForce += bornForce1;\n"
"                        localData[tbx+tj].bornForce += bornForce2;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"                if (pos < end) {\n"
"                    unsigned int offset = x*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&bornForce[offset], (mm_ulong) ((mm_long) (data.bornForce*0x100000000)));\n"
"                    offset = y*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&bornForce[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].bornForce*0x100000000)));\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    } while (pos < end);\n"
"    energyBuffer[GLOBAL_ID] += energy*0.5f;\n"
"}\n"
"\n"
"\n"
"/**\n"
" * Data structure used by computeChainRuleForce().\n"
" */\n"
"typedef struct {\n"
"    real3 pos, force;\n"
"    real radius, scaledRadius, bornRadius, bornForce;\n"
"} AtomData3;\n"
"\n"
"inline DEVICE AtomData3 loadAtomData3(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const float2* RESTRICT params,\n"
"        GLOBAL const real* RESTRICT bornRadius, GLOBAL const mm_long* RESTRICT bornForce) {\n"
"    AtomData3 data;\n"
"    data.pos = trimTo3(posq[atom]);\n"
"    data.bornRadius = bornRadius[atom];\n"
"    float2 params1 = params[atom];\n"
"    data.radius = params1.x;\n"
"    data.scaledRadius = params1.y;\n"
"    data.bornForce = bornForce[atom]/(real) 0x100000000;\n"
"    return data;\n"
"}\n"
"\n"
"DEVICE void computeBornChainRuleInteraction(AtomData3 atom1, AtomData3 atom2, real3* force) {\n"
"    real third = 1/(real) 3;\n"
"    real pi43 = 4*third*M_PI;\n"
"    real factor = -POW(M_PI, third)*POW((real) 6, 2/(real) 3)/9;\n"
"    real term = pi43/(atom1.bornRadius*atom1.bornRadius*atom1.bornRadius);\n"
"    term = factor/POW(term, 4/(real) 3);\n"
"\n"
"    real3 delta = atom2.pos-atom1.pos;\n"
"\n"
"    float sk = atom2.scaledRadius;\n"
"    real sk2 = sk*sk;\n"
"    real r2 = dot(delta, delta);\n"
"    real r = SQRT(r2);\n"
"    real de = 0;\n"
"\n"
"    if (atom1.radius > r + sk)\n"
"        return; // No descreening due to atom1 engulfing atom2.\n"
"\n"
"    if (atom1.radius+r < sk) {\n"
"        real uik = sk-r;\n"
"        real uik4 = uik*uik;\n"
"        uik4 = uik4*uik4;\n"
"        de = -4*M_PI/uik4;\n"
"        real lik = sk - r;\n"
"        real lik4 = lik*lik;\n"
"        lik4 = lik4*lik4;\n"
"        de += 0.25f*M_PI*(sk2-4*sk*r+17*r2)/(r2*lik4);\n"
"    }\n"
"    else if (r < atom1.radius+sk) {\n"
"        real lik = atom1.radius;\n"
"        real lik4 = lik*lik;\n"
"        lik4 = lik4*lik4;\n"
"        de += 0.25f*M_PI*(2*atom1.radius*atom1.radius-sk2-r2)/(r2*lik4);\n"
"    }\n"
"    else {\n"
"        real lik = r-sk;\n"
"        real lik4 = lik*lik;\n"
"        lik4 = lik4*lik4;\n"
"        de += 0.25f*M_PI*(sk2-4*sk*r+r2)/(r2*lik4);\n"
"    }\n"
"    real uik = r+sk;\n"
"    real uik4 = uik*uik;\n"
"    uik4 = uik4*uik4;\n"
"    de -= 0.25f*M_PI*(sk2+4*sk*r+r2)/(r2*uik4);\n"
"    real dbr = term*de/r;\n"
"    de = dbr*atom1.bornForce;\n"
"    *force = delta*de;\n"
"}\n"
"\n"
"/**\n"
" * Compute chain rule terms.\n"
" */\n"
"KERNEL void computeChainRuleForce(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL const real4* RESTRICT posq, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"        GLOBAL const float2* RESTRICT params, GLOBAL const real* RESTRICT bornRadii, GLOBAL const mm_long* RESTRICT bornForce) {\n"
"    unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    unsigned int pos = startTileIndex+warp*numTiles/totalWarps;\n"
"    unsigned int end = startTileIndex+(warp+1)*numTiles/totalWarps;\n"
"    LOCAL AtomData3 localData[CHAIN_RULE_THREAD_BLOCK_SIZE];\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"        const unsigned int tbx = LOCAL_ID - tgx;\n"
"        int x, y;\n"
"        if (pos < end) {\n"
"            y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            AtomData3 data = loadAtomData3(atom1, posq, params, bornRadii, bornForce);\n"
"            data.force = make_real3(0);\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                localData[LOCAL_ID].pos = data.pos;\n"
"                localData[LOCAL_ID].radius = data.radius;\n"
"                localData[LOCAL_ID].scaledRadius = data.scaledRadius;\n"
"                localData[LOCAL_ID].bornRadius = data.bornRadius;\n"
"                localData[LOCAL_ID].bornForce = data.bornForce;\n"
"                localData[LOCAL_ID].force = make_real3(0);\n"
"                SYNC_WARPS;\n"
"                \n"
"                // Compute forces.\n"
"                \n"
"                for (unsigned int j = (tgx+1)&(TILE_SIZE-1); j != tgx; j = (j+1)&(TILE_SIZE-1)) {\n"
"                    int atom2 = y*TILE_SIZE+j;\n"
"                    if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempForce;\n"
"                        computeBornChainRuleInteraction(data, localData[tbx+j], &tempForce);\n"
"                        data.force -= tempForce;\n"
"                        localData[tbx+j].force += tempForce;\n"
"                    }\n"
"                    SYNC_WARPS;\n"
"                }\n"
"                ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) ((data.force.x+localData[LOCAL_ID].force.x)*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) ((data.force.y+localData[LOCAL_ID].force.y)*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) ((data.force.z+localData[LOCAL_ID].force.z)*0x100000000)));\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                localData[LOCAL_ID] = loadAtomData3(j, posq, params, bornRadii, bornForce);\n"
"                localData[LOCAL_ID].force = make_real3(0);\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = y*TILE_SIZE+tj;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 tempForce;\n"
"                        computeBornChainRuleInteraction(data, localData[tbx+tj], &tempForce);\n"
"                        data.force -= tempForce;\n"
"                        localData[tbx+tj].force += tempForce;\n"
"                        computeBornChainRuleInteraction(localData[tbx+tj], data, &tempForce);\n"
"                        data.force += tempForce;\n"
"                        localData[tbx+tj].force -= tempForce;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"                if (pos < end) {\n"
"                    unsigned int offset = x*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"                    offset = y*TILE_SIZE + tgx;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    } while (pos < end);\n"
"}\n"
"\n"
"typedef struct {\n"
"    real3 pos, force, dipole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS;\n"
"    real q, quadrupoleXX, quadrupoleXY, quadrupoleXZ;\n"
"    real quadrupoleYY, quadrupoleYZ, quadrupoleZZ;\n"
"    float thole, damp;\n"
"} AtomData4;\n"
"\n"
"DEVICE void computeOneEDiffInteractionF1(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real* outputEnergy, real3* outputForce);\n"
"DEVICE void computeOneEDiffInteractionT1(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real3* outputForce);\n"
"DEVICE void computeOneEDiffInteractionT3(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real3* outputForce);\n"
"\n"
"inline DEVICE AtomData4 loadAtomData4(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT labFrameDipole,\n"
"        GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"        GLOBAL const real* RESTRICT inducedDipoleS, GLOBAL const real* RESTRICT inducedDipolePolarS, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    AtomData4 data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    data.q = atomPosq.w;\n"
"    data.dipole.x = labFrameDipole[atom*3];\n"
"    data.dipole.y = labFrameDipole[atom*3+1];\n"
"    data.dipole.z = labFrameDipole[atom*3+2];\n"
"    data.quadrupoleXX = labFrameQuadrupole[atom*5];\n"
"    data.quadrupoleXY = labFrameQuadrupole[atom*5+1];\n"
"    data.quadrupoleXZ = labFrameQuadrupole[atom*5+2];\n"
"    data.quadrupoleYY = labFrameQuadrupole[atom*5+3];\n"
"    data.quadrupoleYZ = labFrameQuadrupole[atom*5+4];\n"
"    data.quadrupoleZZ = -(data.quadrupoleXX+data.quadrupoleYY);\n"
"    data.inducedDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"    data.inducedDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"    data.inducedDipoleS = make_real3(inducedDipoleS[3*atom], inducedDipoleS[3*atom+1], inducedDipoleS[3*atom+2]);\n"
"    data.inducedDipolePolarS = make_real3(inducedDipolePolarS[3*atom], inducedDipolePolarS[3*atom+1], inducedDipolePolarS[3*atom+2]);\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"    return data;\n"
"}\n"
"\n"
"DEVICE real computeDScaleFactor(unsigned int polarizationGroup, int index) {\n"
"    return (polarizationGroup & 1<<index ? 0 : 1);\n"
"}\n"
"\n"
"DEVICE float computePScaleFactor(uint2 covalent, unsigned int polarizationGroup, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    bool p = (polarizationGroup & mask);\n"
"    return (x && y ? 0.0f : (x && p ? 0.5f : 1.0f));\n"
"}\n"
"\n"
"/**\n"
" * Compute electrostatic interactions.\n"
" */\n"
"KERNEL void computeEDiffForce(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const uint2* RESTRICT covalentFlags, GLOBAL const unsigned int* RESTRICT polarizationGroupFlags,\n"
"        GLOBAL const int2* RESTRICT exclusionTiles, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"        GLOBAL const real* RESTRICT labFrameDipole, GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const real* RESTRICT inducedDipoleS, GLOBAL const real* RESTRICT inducedDipolePolarS,\n"
"        GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData4 localData[EDIFF_THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        AtomData4 data = loadAtomData4(atom1, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS, dampingAndThole);\n"
"        data.force = make_real3(0);\n"
"        uint2 covalent = covalentFlags[pos*TILE_SIZE+tgx];\n"
"        unsigned int polarizationGroup = polarizationGroupFlags[pos*TILE_SIZE+tgx];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].pos = data.pos;\n"
"            localData[LOCAL_ID].q = data.q;\n"
"            localData[LOCAL_ID].dipole = data.dipole;\n"
"            localData[LOCAL_ID].quadrupoleXX = data.quadrupoleXX;\n"
"            localData[LOCAL_ID].quadrupoleXY = data.quadrupoleXY;\n"
"            localData[LOCAL_ID].quadrupoleXZ = data.quadrupoleXZ;\n"
"            localData[LOCAL_ID].quadrupoleYY = data.quadrupoleYY;\n"
"            localData[LOCAL_ID].quadrupoleYZ = data.quadrupoleYZ;\n"
"            localData[LOCAL_ID].quadrupoleZZ = data.quadrupoleZZ;\n"
"            localData[LOCAL_ID].inducedDipole = data.inducedDipole;\n"
"            localData[LOCAL_ID].inducedDipolePolar = data.inducedDipolePolar;\n"
"            localData[LOCAL_ID].inducedDipoleS = data.inducedDipoleS;\n"
"            localData[LOCAL_ID].inducedDipolePolarS = data.inducedDipolePolarS;\n"
"            localData[LOCAL_ID].thole = data.thole;\n"
"            localData[LOCAL_ID].damp = data.damp;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempForce;\n"
"                    real tempEnergy;\n"
"                    float d = computeDScaleFactor(polarizationGroup, j);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, j);\n"
"                    computeOneEDiffInteractionF1(&data, &localData[tbx+j], d, p, &tempEnergy, &tempForce);\n"
"                    energy += 0.25f*tempEnergy;\n"
"                    data.force += tempForce;\n"
"                }\n"
"            }\n"
"            SYNC_WARPS;\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"\n"
"            // Compute torques.\n"
"\n"
"            data.force = make_real3(0);\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempTorque;\n"
"                    float d = computeDScaleFactor(polarizationGroup, j);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, j);\n"
"                    computeOneEDiffInteractionT1(&data, &localData[tbx+j], d, p, &tempTorque);\n"
"                    data.force += tempTorque;\n"
"                }\n"
"            }\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            localData[LOCAL_ID] = loadAtomData4(j, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            SYNC_WARPS;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempForce;\n"
"                    real tempEnergy;\n"
"                    float d = computeDScaleFactor(polarizationGroup, tj);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, tj);\n"
"                    computeOneEDiffInteractionF1(&data, &localData[tbx+tj], d, p, &tempEnergy, &tempForce);\n"
"                    energy += 0.5f*tempEnergy;\n"
"                    data.force += tempForce;\n"
"                    localData[tbx+tj].force -= tempForce;\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= ENERGY_SCALE_FACTOR;\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"\n"
"            // Compute torques.\n"
"\n"
"            data.force = make_real3(0);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            SYNC_WARPS;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempTorque;\n"
"                    float d = computeDScaleFactor(polarizationGroup, tj);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, tj);\n"
"                    computeOneEDiffInteractionT1(&data, &localData[tbx+tj], d, p, &tempTorque);\n"
"                    data.force += tempTorque;\n"
"                    computeOneEDiffInteractionT3(&data, &localData[tbx+tj], d, p, &tempTorque);\n"
"                    localData[tbx+tj].force += tempTorque;\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= ENERGY_SCALE_FACTOR;\n"
"            offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions (by enumerating all of them, since there's no cutoff).\n"
"\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = startTileIndex+warp*numTiles/totalWarps;\n"
"    int end = startTileIndex+(warp+1)*numTiles/totalWarps;\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL volatile int skipTiles[EDIFF_THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile.\n"
"\n"
"        int x, y;\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        bool includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            AtomData4 data = loadAtomData4(atom1, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS, dampingAndThole);\n"
"            data.force = make_real3(0);\n"
"            localData[LOCAL_ID] = loadAtomData4(atom1, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS, dampingAndThole);\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            localData[LOCAL_ID] = loadAtomData4(j, posq, labFrameDipole, labFrameQuadrupole, inducedDipole, inducedDipolePolar, inducedDipoleS, inducedDipolePolarS, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempForce;\n"
"                    real tempEnergy;\n"
"                    computeOneEDiffInteractionF1(&data, &localData[tbx+tj], 1, 1, &tempEnergy, &tempForce);\n"
"                    energy += 0.5f*tempEnergy;\n"
"                    data.force += tempForce;\n"
"                    localData[tbx+tj].force -= tempForce;\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= ENERGY_SCALE_FACTOR;\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"\n"
"            // Compute torques.\n"
"\n"
"            data.force = make_real3(0);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempTorque;\n"
"                    computeOneEDiffInteractionT1(&data, &localData[tbx+tj], 1, 1, &tempTorque);\n"
"                    data.force += tempTorque;\n"
"                    computeOneEDiffInteractionT3(&data, &localData[tbx+tj], 1, 1, &tempTorque);\n"
"                    localData[tbx+tj].force += tempTorque;\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            data.force *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= ENERGY_SCALE_FACTOR;\n"
"            offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy*ENERGY_SCALE_FACTOR;\n"
"}\n"
"";
const string CommonAmoebaKernelSources::amoebaTorsionTorsionForce = "int2 torsionParams = TORSION_PARAMS[index];\n"
"\n"
"real3 ba = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"real3 cb = make_real3(pos3.x-pos2.x, pos3.y-pos2.y, pos3.z-pos2.z);\n"
"real3 dc = make_real3(pos4.x-pos3.x, pos4.y-pos3.y, pos4.z-pos3.z);\n"
"real3 ed = make_real3(pos5.x-pos4.x, pos5.y-pos4.y, pos5.z-pos4.z);\n"
"\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(ba)\n"
"APPLY_PERIODIC_TO_DELTA(cb)\n"
"APPLY_PERIODIC_TO_DELTA(dc)\n"
"APPLY_PERIODIC_TO_DELTA(ed)\n"
"#endif\n"
"\n"
"real xt = ba.y*cb.z - cb.y*ba.z;\n"
"real yt = ba.z*cb.x - cb.z*ba.x;\n"
"real zt = ba.x*cb.y - cb.x*ba.y;\n"
"\n"
"real xu = cb.y*dc.z - dc.y*cb.z;\n"
"real yu = cb.z*dc.x - dc.z*cb.x;\n"
"real zu = cb.x*dc.y - dc.x*cb.y;\n"
"\n"
"real rt2 = xt*xt + yt*yt + zt*zt;\n"
"real ru2 = xu*xu + yu*yu + zu*zu;\n"
"\n"
"real rtru = SQRT(rt2 * ru2);\n"
"\n"
"real xv = dc.y*ed.z - ed.y*dc.z;\n"
"real yv = dc.z*ed.x - ed.z*dc.x;\n"
"real zv = dc.x*ed.y - ed.x*dc.y;\n"
"\n"
"real rv2 = xv*xv + yv*yv + zv*zv;\n"
"real rurv = SQRT(ru2 * rv2);\n"
"\n"
"real rcb = SQRT(cb.x*cb.x + cb.y*cb.y + cb.z*cb.z);\n"
"real cosine1 = (rtru != 0 ? (xt*xu+yt*yu+zt*zu)/rtru : (real) 0);\n"
"cosine1 = (cosine1 > 1 ? (real) 1 : cosine1);\n"
"cosine1 = (cosine1 < -1 ? (real) -1 : cosine1);\n"
"real angle1;\n"
"if (cosine1 > 0.99f || cosine1 < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real3 cross_prod = cross(make_real3(xt, yt, zt), make_real3(xu, yu, zu));\n"
"    angle1 = RAD_TO_DEG*ASIN(SQRT(dot(cross_prod, cross_prod)/(rt2*ru2)));\n"
"    if (cosine1 < 0.0f)\n"
"        angle1 = 180-angle1;\n"
"}\n"
"else\n"
"   angle1 = RAD_TO_DEG*ACOS(cosine1);\n"
"real sign = ba.x*xu + ba.y*yu + ba.z*zu;\n"
"angle1 = (sign < 0 ? -angle1 : angle1);\n"
"real value1 = angle1;\n"
"\n"
"real rdc = SQRT(dc.x*dc.x + dc.y*dc.y + dc.z*dc.z);\n"
"real cosine2 = (xu*xv + yu*yv + zu*zv) / rurv;\n"
"cosine2 = (cosine2 > 1 ? (real) 1 : cosine2);\n"
"cosine2 = (cosine2 < -1 ? (real) -1 : cosine2);\n"
"real angle2;\n"
"if (cosine2 > 0.99f || cosine2 < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real3 cross_prod = cross(make_real3(xu, yu, zu), make_real3(xv, yv, zv));\n"
"    angle2 = RAD_TO_DEG*ASIN(SQRT(dot(cross_prod, cross_prod)/(ru2*rv2)));\n"
"    if (cosine2 < 0.0f)\n"
"        angle2 = 180-angle2;\n"
"}\n"
"else\n"
"   angle2 = RAD_TO_DEG*ACOS(cosine2);\n"
"sign = cb.x*xv + cb.y*yv + cb.z*zv;\n"
"angle2 = (sign < 0 ? -angle2 : angle2);\n"
"real value2 = angle2;\n"
"\n"
"// check for inverted chirality at the central atom\n"
"\n"
"// if atom2.y < 0, then no chiral check required\n"
"// sign is set to 1.0 in this case\n"
"// use atom5 for the atom index to avoid warp divergence\n"
"\n"
"int chiralAtomIndex = (torsionParams.x > -1 ? torsionParams.x : atom5);\n"
"real4 pos6 = posq[chiralAtomIndex];\n"
"\n"
"real3 ac = make_real3(pos6.x-pos3.x, pos6.y-pos3.y, pos6.z-pos3.z);\n"
"real3 bc = make_real3(pos2.x-pos3.x, pos2.y-pos3.y, pos2.z-pos3.z);\n"
"real3 dc1 = make_real3(pos4.x-pos3.x, pos4.y-pos3.y, pos4.z-pos3.z);\n"
"\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(ac)\n"
"APPLY_PERIODIC_TO_DELTA(bc)\n"
"APPLY_PERIODIC_TO_DELTA(dc1)\n"
"#endif\n"
"\n"
"real c1 = bc.y*dc1.z - bc.z*dc1.y;\n"
"real c2 = dc1.y*ac.z - dc1.z*ac.y;\n"
"real c3 = ac.y*bc.z - ac.z*bc.y;\n"
"real vol = ac.x*c1 + bc.x*c2 + dc1.x*c3;\n"
"sign = (vol > 0 ? (real) 1 : (real) -1);\n"
"sign = (torsionParams.x < 0 ? (real) 1 : sign);\n"
"value1 *= sign;\n"
"value2 *= sign;\n"
"\n"
"// use bicubic interpolation to compute spline values\n"
"// compute indices into grid based on angles\n"
"\n"
"float4 gridParams = GRID_PARAMS[torsionParams.y];\n"
"int index1 = (int) ((value1 - gridParams.y)/gridParams.z + 1.0e-05f);\n"
"real fIndex = (real) index1;\n"
"real x1l = gridParams.z*fIndex + gridParams.y;\n"
"real x1u = x1l + gridParams.z;\n"
"\n"
"int index2 = (int) ((value2 - gridParams.y)/gridParams.z + 1.0e-05f);\n"
"fIndex = (real) index2;\n"
"real x2l = gridParams.z*fIndex + gridParams.y;\n"
"real x2u = x2l + gridParams.z;\n"
"\n"
"int posIndex1 = index2 + index1*(int) gridParams.w;\n"
"posIndex1 += (int) gridParams.x;\n"
"\n"
"int posIndex2 = index2 + (index1+1)*(int) gridParams.w;\n"
"posIndex2 += (int) gridParams.x;\n"
"\n"
"// load grid points surrounding angle\n"
"\n"
"real4 y;\n"
"real4 y1;\n"
"real4 y2;\n"
"real4 y12;\n"
"\n"
"int localIndex = posIndex1;\n"
"y.x = GRID_VALUES[localIndex].x;\n"
"y1.x = GRID_VALUES[localIndex].y;\n"
"y2.x = GRID_VALUES[localIndex].z;\n"
"y12.x = GRID_VALUES[localIndex].w;\n"
"\n"
"localIndex = posIndex2;\n"
"y.y = GRID_VALUES[localIndex].x;\n"
"y1.y = GRID_VALUES[localIndex].y;\n"
"y2.y = GRID_VALUES[localIndex].z;\n"
"y12.y = GRID_VALUES[localIndex].w;\n"
"\n"
"localIndex = posIndex2 + 1;\n"
"y.z = GRID_VALUES[localIndex].x;\n"
"y1.z = GRID_VALUES[localIndex].y;\n"
"y2.z = GRID_VALUES[localIndex].z;\n"
"y12.z = GRID_VALUES[localIndex].w;\n"
"\n"
"localIndex = posIndex1 + 1;\n"
"y.w = GRID_VALUES[localIndex].x;\n"
"y1.w = GRID_VALUES[localIndex].y;\n"
"y2.w = GRID_VALUES[localIndex].z;\n"
"y12.w = GRID_VALUES[localIndex].w;\n"
"\n"
"// perform interpolation\n"
"\n"
"real e;\n"
"real dedang1;\n"
"real dedang2;\n"
"\n"
"bicubic(y, y1, y2, y12, value1, x1l, x1u, value2, x2l, x2u, &e, &dedang1, &dedang2);\n"
"energy += e;\n"
"dedang1 *= sign * RAD_TO_DEG;\n"
"dedang2 *= sign * RAD_TO_DEG;\n"
"\n"
"// chain rule terms for first angle derivative components\n"
"\n"
"real3 ca = make_real3(pos3.x-pos1.x, pos3.y-pos1.y, pos3.z-pos1.z);\n"
"real3 db = make_real3(pos4.x-pos2.x, pos4.y-pos2.y, pos4.z-pos2.z);\n"
"\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(ca)\n"
"APPLY_PERIODIC_TO_DELTA(db)\n"
"#endif\n"
"\n"
"real dedxt = dedang1 * (yt*cb.z - cb.y*zt) / (rt2*rcb);\n"
"real dedyt = dedang1 * (zt*cb.x - cb.z*xt) / (rt2*rcb);\n"
"real dedzt = dedang1 * (xt*cb.y - cb.x*yt) / (rt2*rcb);\n"
"real dedxu = -dedang1 * (yu*cb.z - cb.y*zu) / (ru2*rcb);\n"
"real dedyu = -dedang1 * (zu*cb.x - cb.z*xu) / (ru2*rcb);\n"
"real dedzu = -dedang1 * (xu*cb.y - cb.x*yu) / (ru2*rcb);\n"
"\n"
"// compute first derivative components for first angle\n"
"\n"
"real dedxia = cb.z*dedyt - cb.y*dedzt;\n"
"real dedyia = cb.x*dedzt - cb.z*dedxt;\n"
"real dedzia = cb.y*dedxt - cb.x*dedyt;\n"
"\n"
"real dedxib = ca.y*dedzt - ca.z*dedyt + dc.z*dedyu - dc.y*dedzu;\n"
"real dedyib = ca.z*dedxt - ca.x*dedzt + dc.x*dedzu - dc.z*dedxu;\n"
"real dedzib = ca.x*dedyt - ca.y*dedxt + dc.y*dedxu - dc.x*dedyu;\n"
"\n"
"real dedxic = ba.z*dedyt - ba.y*dedzt + db.y*dedzu - db.z*dedyu;\n"
"real dedyic = ba.x*dedzt - ba.z*dedxt + db.z*dedxu - db.x*dedzu;\n"
"real dedzic = ba.y*dedxt - ba.x*dedyt + db.x*dedyu - db.y*dedxu;\n"
"\n"
"real dedxid = cb.z*dedyu - cb.y*dedzu;\n"
"real dedyid = cb.x*dedzu - cb.z*dedxu;\n"
"real dedzid = cb.y*dedxu - cb.x*dedyu;\n"
"\n"
"// chain rule terms for second angle derivative components\n"
"\n"
"real3 ec = make_real3(pos5.x-pos3.x, pos5.y-pos3.y, pos5.z-pos3.z);\n"
"\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(ec)\n"
"#endif\n"
"\n"
"real dedxu2 = dedang2 * (yu*dc.z - dc.y*zu) / (ru2*rdc);\n"
"real dedyu2 = dedang2 * (zu*dc.x - dc.z*xu) / (ru2*rdc);\n"
"real dedzu2 = dedang2 * (xu*dc.y - dc.x*yu) / (ru2*rdc);\n"
"real dedxv2 = -dedang2 * (yv*dc.z - dc.y*zv) / (rv2*rdc);\n"
"real dedyv2 = -dedang2 * (zv*dc.x - dc.z*xv) / (rv2*rdc);\n"
"real dedzv2 = -dedang2 * (xv*dc.y - dc.x*yv) / (rv2*rdc);\n"
"\n"
"// compute first derivative components for second angle\n"
"\n"
"real dedxib2 = dc.z*dedyu2 - dc.y*dedzu2;\n"
"real dedyib2 = dc.x*dedzu2 - dc.z*dedxu2;\n"
"real dedzib2 = dc.y*dedxu2 - dc.x*dedyu2;\n"
"real dedxic2 = db.y*dedzu2 - db.z*dedyu2 + ed.z*dedyv2 - ed.y*dedzv2;\n"
"real dedyic2 = db.z*dedxu2 - db.x*dedzu2 + ed.x*dedzv2 - ed.z*dedxv2;\n"
"real dedzic2 = db.x*dedyu2 - db.y*dedxu2 + ed.y*dedxv2 - ed.x*dedyv2;\n"
"real dedxid2 = cb.z*dedyu2 - cb.y*dedzu2 + ec.y*dedzv2 - ec.z*dedyv2;\n"
"real dedyid2 = cb.x*dedzu2 - cb.z*dedxu2 + ec.z*dedxv2 - ec.x*dedzv2;\n"
"real dedzid2 = cb.y*dedxu2 - cb.x*dedyu2 + ec.x*dedyv2 - ec.y*dedxv2;\n"
"real dedxie2 = dc.z*dedyv2 - dc.y*dedzv2;\n"
"real dedyie2 = dc.x*dedzv2 - dc.z*dedxv2;\n"
"real dedzie2 = dc.y*dedxv2 - dc.x*dedyv2;\n"
"\n"
"real3 force1 = make_real3(-dedxia, -dedyia, -dedzia);\n"
"real3 force2 = make_real3(-dedxib-dedxib2, -dedyib-dedyib2, -dedzib-dedzib2);\n"
"real3 force3 = make_real3(-dedxic-dedxic2, -dedyic-dedyic2, -dedzic-dedzic2);\n"
"real3 force4 = make_real3(-dedxid-dedxid2, -dedyid-dedyid2, -dedzid-dedzid2);\n"
"real3 force5 = make_real3(-dedxie2, -dedyie2, -dedzie2);";
const string CommonAmoebaKernelSources::amoebaVdwForce1 = "/**\n"
" * Clear the forces, and compute the position to use for each atom based on the bond reduction factors.\n"
" */\n"
"KERNEL void prepareToComputeForce(GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL real4* RESTRICT posq, GLOBAL const real4* RESTRICT tempPosq,\n"
"        GLOBAL const int* RESTRICT bondReductionAtoms, GLOBAL const float* RESTRICT bondReductionFactors) {\n"
"    for (unsigned int atom = GLOBAL_ID; atom < PADDED_NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        forceBuffers[atom] = 0;\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] = 0;\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS*2] = 0;\n"
"        real4 pos1 = tempPosq[atom];\n"
"        real4 pos2 = tempPosq[bondReductionAtoms[atom]];\n"
"        real factor = (real) bondReductionFactors[atom];\n"
"        posq[atom] = make_real4(factor*pos1.x + (1-factor)*pos2.x,\n"
"                                    factor*pos1.y + (1-factor)*pos2.y,\n"
"                                    factor*pos1.z + (1-factor)*pos2.z, pos1.w);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Spread the forces between atoms based on the bond reduction factors.\n"
" */\n"
"KERNEL void spreadForces(GLOBAL const mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT tempForceBuffers,\n"
"        GLOBAL const int* RESTRICT bondReductionAtoms, GLOBAL const float* RESTRICT bondReductionFactors) {\n"
"    for (unsigned int atom1 = GLOBAL_ID; atom1 < PADDED_NUM_ATOMS; atom1 += GLOBAL_SIZE) {\n"
"        int atom2 = bondReductionAtoms[atom1];\n"
"        mm_long fx1 = forceBuffers[atom1];\n"
"        mm_long fy1 = forceBuffers[atom1+PADDED_NUM_ATOMS];\n"
"        mm_long fz1 = forceBuffers[atom1+PADDED_NUM_ATOMS*2];\n"
"        if (atom1 != atom2) {\n"
"            double factor = (double) bondReductionFactors[atom1];\n"
"            mm_long fx2 = (mm_long) ((1-factor)*fx1);\n"
"            mm_long fy2 = (mm_long) ((1-factor)*fy1);\n"
"            mm_long fz2 = (mm_long) ((1-factor)*fz1);\n"
"            ATOMIC_ADD(&tempForceBuffers[atom2], (mm_ulong) fx2);\n"
"            ATOMIC_ADD(&tempForceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) fy2);\n"
"            ATOMIC_ADD(&tempForceBuffers[atom2+PADDED_NUM_ATOMS*2], (mm_ulong) fz2);\n"
"            fx1 = (mm_long) (factor*fx1);\n"
"            fy1 = (mm_long) (factor*fy1);\n"
"            fz1 = (mm_long) (factor*fz1);\n"
"        }\n"
"        ATOMIC_ADD(&tempForceBuffers[atom1], (mm_ulong) fx1);\n"
"        ATOMIC_ADD(&tempForceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) fy1);\n"
"        ATOMIC_ADD(&tempForceBuffers[atom1+PADDED_NUM_ATOMS*2], (mm_ulong) fz1);\n"
"    }\n"
"}\n"
"";
const string CommonAmoebaKernelSources::amoebaVdwForce2 = "{\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    unsigned int includeInteraction = (!isExcluded);\n"
"#endif\n"
"    real tempForce = 0.0f;\n"
"    float2 pairSigmaEpsilon = sigmaEpsilon[atomType1+atomType2*NUM_TYPES];\n"
"    real sigma = pairSigmaEpsilon.x;\n"
"    real epsilon = pairSigmaEpsilon.y;\n"
"    real softcore = 0.0f;\n"
"#if VDW_ALCHEMICAL_METHOD == 1\n"
"    if (isAlchemical1 != isAlchemical2) { \n"
"#elif VDW_ALCHEMICAL_METHOD == 2 \n"
"    if (isAlchemical1 || isAlchemical2) {\n"
"#endif\n"
"#if VDW_ALCHEMICAL_METHOD != 0\n"
"       real lambda = vdwLambda[0];\n"
"       epsilon = epsilon * POW(lambda, VDW_SOFTCORE_POWER);\n"
"       softcore = VDW_SOFTCORE_ALPHA * (1.0f - lambda) * (1.0f - lambda);\n"
"    }\n"
"#endif\n"
"#if POTENTIAL_FUNCTION == 1\n"
"    real pp1 = sigma / r;\n"
"    real pp2 = pp1 * pp1;\n"
"    real pp3 = pp2 * pp1;\n"
"    real pp6 = pp3 * pp3;\n"
"    real pp12 = pp6 * pp6;\n"
"    real termEnergy = 4 * epsilon * (pp12 - pp6);\n"
"    real deltaE = -24 * epsilon * (2*pp12 - pp6) / r;\n"
"#else\n"
"    real dhal = 0.07f;\n"
"    real ghal = 0.12f;\n"
"    real dhal1 = 1.07f;\n"
"    real ghal1 = 1.12f;\n"
"    real rho = r / sigma;\n"
"    real rho2 = rho * rho;\n"
"    real rho6 = rho2 * rho2 * rho2;\n"
"    real rhoplus = rho + dhal;\n"
"    real rhodec2 = rhoplus * rhoplus;\n"
"    real rhodec = rhodec2 * rhodec2 * rhodec2;\n"
"    real s1 = 1.0f / (softcore + rhodec * rhoplus);\n"
"    real s2 = 1.0f / (softcore + rho6 * rho + ghal);\n"
"    real point72 = dhal1 * dhal1;\n"
"    real t1 = dhal1 * point72 * point72 * point72 * s1;\n"
"    real t2 = ghal1 * s2;\n"
"    real t2min = t2 - 2.0f;\n"
"    real dt1 = -7.0f * rhodec * t1 * s1;\n"
"    real dt2 = -7.0f * rho6 * t2 * s2;\n"
"    real termEnergy = epsilon * t1 * t2min;\n"
"    real deltaE = epsilon * (dt1 * t2min + t1 * dt2) / sigma;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    if (r > TAPER_CUTOFF) {\n"
"        real x = r-TAPER_CUTOFF;\n"
"        real taper = 1+x*x*x*(TAPER_C3+x*(TAPER_C4+x*TAPER_C5));\n"
"        real dtaper = x*x*(3*TAPER_C3+x*(4*TAPER_C4+x*5*TAPER_C5));\n"
"        deltaE = termEnergy*dtaper + deltaE*taper;\n"
"        termEnergy *= taper;\n"
"    }\n"
"#endif\n"
"    tempEnergy += (includeInteraction ? termEnergy : 0);\n"
"    dEdR -= (includeInteraction ? deltaE*invR : 0);\n"
"}\n"
"";
const string CommonAmoebaKernelSources::amoebaWcaForce = "#define TILE_SIZE 32\n"
"#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real3 pos, force;\n"
"    float radius, epsilon, padding;\n"
"} AtomData;\n"
"\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const float2* RESTRICT radiusEpsilon) {\n"
"    AtomData data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    float2 temp = radiusEpsilon[atom];\n"
"    data.radius = temp.x;\n"
"    data.epsilon = temp.y;\n"
"    return data;\n"
"}\n"
"\n"
"DEVICE void initParticleParameters(float radius, float epsilon, real* rmixo, real* rmixh, real* emixo, real* emixh) {\n"
"    real sqrtEps = SQRT(epsilon);\n"
"    real denominator = SQRT(EPSO) + sqrtEps;\n"
"    *emixo = 4*EPSO*epsilon / (denominator*denominator);\n"
"    denominator = SQRT(EPSH) + sqrtEps;\n"
"    *emixh = 4*EPSH*epsilon / (denominator*denominator);\n"
"    real radius2 = radius*radius;\n"
"    real rmino2 = RMINO*RMINO; \n"
"    *rmixo = 2*(rmino2*RMINO + radius2*radius) / (rmino2 + radius2);\n"
"    real rminh2 = RMINH*RMINH;\n"
"    *rmixh = 2*(rminh2*RMINH + radius2*radius) / (rminh2+radius2);\n"
"}\n"
"\n"
"DEVICE void computeOneInteraction(AtomData atom1, AtomData atom2, real rmixo, real rmixh, real emixo, real emixh, real3* force, real* energy) {\n"
"    // get deltaR and r between 2 atoms\n"
"    \n"
"    *force = atom2.pos - atom1.pos;\n"
"    real r2 = dot(*force, *force);\n"
"    if (r2 <= 0) {\n"
"        *force = make_real3(0);\n"
"        *energy = 0;\n"
"        return;\n"
"    }\n"
"    real rI = RSQRT(r2);\n"
"    real r = RECIP(rI);\n"
"\n"
"    real sk = atom2.radius*SHCTD;\n"
"    real sk2 = sk*sk;\n"
"    if (atom1.radius >= (r+sk)) {\n"
"        *force = make_real3(0);\n"
"        *energy = 0;\n"
"        return;\n"
"    }\n"
"\n"
"    real rmax = atom1.radius > (r - sk) ? atom1.radius : (r - sk);\n"
"    real lik = rmax;\n"
"    real lik2 = lik*lik;\n"
"    real lik3 = lik2*lik;\n"
"    real lik4 = lik2*lik2;\n"
" \n"
"    real uik = (r+sk) < rmixo ? (r+sk) : rmixo;\n"
"    real uik2 = uik*uik;\n"
"    real uik3 = uik2*uik;\n"
"    real uik4 = uik2*uik2;\n"
"\n"
"    real term = 4*M_PI/(48*r)*(3*(lik4-uik4) - 8*r*(lik3-uik3) + 6*(r2-sk2)*(lik2-uik2));\n"
"\n"
"    real r3 = r2*r;\n"
"    real dl1 = lik2*(-lik2 + 2*(r2 + sk2));\n"
"    real dl2 = lik*(-lik3 + 4*lik2*r - 6*lik*r2 + 2*lik*sk2 + 4*r3 - 4*r*sk2);\n"
"    real dl = atom1.radius > (r-sk)? dl1 : dl2;\n"
"\n"
"    real du1 = uik2*(-uik2 + 2*(r2 + sk2));\n"
"    real du2 = uik*(-uik3 + 4*uik2*r - 2*uik*(3*r2 - sk2) + 4*r*(r2 - sk2));\n"
"    real du = (r+sk) > rmixo ? -du1 : -du2;\n"
"\n"
"    real mask2 = lik < rmixo ? 1 : 0;\n"
"    real sum = -mask2*(emixo*term);\n"
"    real de = -mask2*emixo*M_PI*(dl+du)/(4*r2);\n"
"\n"
"    uik = (r+sk) < rmixh ? (r+sk) : rmixh;\n"
"    uik2 = uik*uik;\n"
"    uik3 = uik2*uik;\n"
"    uik4 = uik2*uik2;\n"
"\n"
"    term = (M_PI)/ (12*r) * (3*(lik4-uik4) - 8*r*(lik3-uik3) + 6*(r2-sk2)*(lik2-uik2));\n"
"\n"
"    dl1 = lik2*(-lik2 + 2*r2 + 2*sk2);\n"
"    dl2 = lik*(-lik3 + 4*lik2*r - 6*lik*r2 + 2*lik*sk2 + 4*r3 - 4*r*sk2);\n"
"    dl = atom1.radius > (r-sk) ? dl1 : dl2;\n"
"\n"
"    du1 = -uik2*(-uik2 + 2*r2 + 2*sk2);\n"
"    du2 = -uik*(-uik3 + 4*uik2*r - 6*uik*r2 + 2*uik*sk2 + 4*r3 - 4*r*sk2);\n"
"    du = (r+sk) > rmixh ? du1 : du2;\n"
"\n"
"    mask2 = lik < rmixh ? 1 : 0;\n"
"    sum -= mask2*(2*emixh*term);\n"
"    de -= mask2*(2*emixh*M_PI*(dl+du)/(4*r2));\n"
"\n"
"    uik = r + sk;\n"
"    uik2 = uik*uik;\n"
"    uik3 = uik2*uik;\n"
"    uik4 = uik2*uik2;\n"
"    real uik5 = uik4*uik;\n"
"    real uik6 = uik3*uik3;\n"
"    real uik10 = uik5*uik5;\n"
"    real uik11 = uik10*uik;\n"
"    real uik12 = uik6*uik6;\n"
"    real uik13 = uik12*uik;\n"
"\n"
"    lik = rmax > rmixo ? rmax : rmixo;\n"
"    lik2 = lik*lik;\n"
"    lik3 = lik2*lik;\n"
"    lik4 = lik2*lik2;\n"
"    real lik5 = lik4*lik;\n"
"    real lik6 = lik3*lik3;\n"
"    real lik10 = lik5*lik5;\n"
"    real lik11 = lik10*lik;\n"
"    real lik12 = lik6*lik6;\n"
"    real lik13 = lik12*lik;\n"
"\n"
"    term = 4*M_PI/(120*r*lik5*uik5)*(15*uik*lik*r*(uik4-lik4) - 10*uik2*lik2*(uik3-lik3) + 6*(sk2-r2)*(uik5-lik5));\n"
"    dl1 = (-5*lik2 + 3*r2 + 3*sk2)/lik5;\n"
"    dl2 = (5*lik3 - 33*lik*r2 - 3*lik*sk2 + 15*(lik2*r+r3-r*sk2))/lik6;\n"
"    dl = (atom1.radius > (r-sk)) || (rmax < rmixo) ? -dl1 : dl2;\n"
"\n"
"    du = (-5*uik3 + 33*uik*r2 + 3*uik*sk2 - 15*(uik2*r+r3-r*sk2))/uik6;\n"
"\n"
"    real rmixo7 = rmixo*rmixo*rmixo;\n"
"    rmixo7 = rmixo7*rmixo7*rmixo;\n"
"    real ao = emixo*rmixo7;\n"
"\n"
"    real idisp = -2*ao*term;\n"
"    mask2 = uik > rmixo ? 1 : 0;\n"
"\n"
"    de -= mask2*(2*ao*M_PI*(dl + du)/(15*r2));\n"
"\n"
"    term = 4*M_PI/(2640*r*lik12*uik12) * (120*uik*lik*r*(uik11-lik11) - 66*uik2*lik2*(uik10-lik10) + 55*(sk2-r2)*(uik12-lik12));\n"
"\n"
"    dl1 = (6*lik2 - 5*r2 - 5*sk2)/lik12;\n"
"    dl2 = (6*lik3 - 125*lik*r2 - 5*lik*sk2 + 60*(lik2*r+r3-r*sk2))/lik13;\n"
"    dl = (atom1.radius > (r-sk)) || (rmax < rmixo) ? dl1 : dl2;\n"
"\n"
"    du = (-6*uik3 + 125*uik*r2 + 5*uik*sk2 - 60*(uik2*r+r3-r*sk2))/uik13;\n"
"\n"
"    de += mask2*(ao*rmixo7*M_PI*(dl + du)/(60*r2));\n"
"    real irep = ao*rmixo7*term;\n"
"    sum += mask2*(irep + idisp);\n"
"\n"
"    lik = rmax > rmixh ? rmax : rmixh;\n"
"    lik2 = lik*lik;\n"
"    lik3 = lik2*lik;\n"
"    lik4 = lik2*lik2;\n"
"    lik5 = lik4*lik;\n"
"    lik6 = lik3*lik3;\n"
"    lik10 = lik5*lik5;\n"
"    lik11 = lik10*lik;\n"
"    lik12 = lik6*lik6;\n"
"    lik13 = lik12*lik;\n"
"\n"
"    term = 4*M_PI / (120*r*lik5*uik5) * (15*uik*lik*r*(uik4-lik4) - 10*uik2*lik2*(uik3-lik3) + 6*(sk2-r2)*(uik5-lik5));\n"
"\n"
"    dl1 = (-5*lik2 + 3*r2 + 3*sk2)/lik5;\n"
"    dl2 = (5*lik3 - 33*lik*r2 - 3*lik*sk2+ 15*(lik2*r+r3-r*sk2))/lik6;\n"
"    dl = (atom1.radius > (r-sk)) || (rmax < rmixh) ? -dl1 : dl2;\n"
"\n"
"    du = -(5*uik3 - 33*uik*r2 - 3*uik*sk2 + 15*(uik2*r+r3-r*sk2))/uik6;\n"
"\n"
"    real rmixh7 = rmixh*rmixh*rmixh;\n"
"    rmixh7 = rmixh7*rmixh7*rmixh;\n"
"    real ah = emixh*rmixh7;\n"
"\n"
"    idisp = -4*ah*term;\n"
"\n"
"    mask2 = uik > rmixh ? 1 : 0;\n"
"    de -= mask2*(4*ah*M_PI*(dl + du)/(15*r2));\n"
"\n"
"    term = 4*M_PI / (2640*r*lik12*uik12) * (120*uik*lik*r*(uik11-lik11) - 66*uik2*lik2*(uik10-lik10) + 55*(sk2-r2)*(uik12-lik12));\n"
"\n"
"    dl1 = -(-6*lik2 + 5*r2 + 5*sk2)/lik12;\n"
"    dl2 = (6*lik3 - 125*lik*r2 - 5*lik*sk2 + 60*(lik2*r+r3-r*sk2))/lik13;\n"
"    dl = ((atom1.radius > (r-sk)) || (rmax < rmixh)) ? dl1 : dl2;\n"
"\n"
"    du = -(6*uik3 - 125*uik*r2 -5*uik*sk2 + 60*(uik2*r+r3-r*sk2))/uik13;\n"
"    irep = 2*ah*rmixh7*term;\n"
"\n"
"    de += mask2*(ah*rmixh7*M_PI*(dl+du)/(30*r2));\n"
"    sum += mask2*(irep+idisp);\n"
"\n"
"    *energy = sum;\n"
"    de *= -AWATER*rI;\n"
"    *force *= de;\n"
"}\n"
"\n"
"/**\n"
" * Compute WCA interaction.\n"
" */\n"
"KERNEL void computeWCAForce(GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, unsigned int startTileIndex, unsigned int numTileIndices, GLOBAL const float2* RESTRICT radiusEpsilon) {\n"
"    unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    unsigned int pos = (unsigned int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    unsigned int end = (unsigned int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        \n"
"        const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"        const unsigned int tbx = LOCAL_ID - tgx;\n"
"        const unsigned int localGroupIndex = LOCAL_ID/TILE_SIZE;\n"
"        int x, y;\n"
"        AtomData data;\n"
"        if (pos < end) {\n"
"            y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            data = loadAtomData(atom1, posq, radiusEpsilon);\n"
"            localData[LOCAL_ID] = loadAtomData(y*TILE_SIZE+tgx, posq, radiusEpsilon);\n"
"            real emixo, emixh, rmixo, rmixh;\n"
"            initParticleParameters(data.radius, data.epsilon, &rmixo, &rmixh, &emixo, &emixh);\n"
"            data.force = make_real3(0);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 tempForce;\n"
"                    real tempEnergy;\n"
"                    computeOneInteraction(data, localData[tbx+tj], rmixo, rmixh, emixo, emixh, &tempForce, &tempEnergy);\n"
"                    data.force += tempForce;\n"
"                    localData[tbx+tj].force -= tempForce;\n"
"                    energy += (x == y ? 0.5f*tempEnergy : tempEnergy);\n"
"                    real emjxo, emjxh, rmjxo, rmjxh;\n"
"                    initParticleParameters(localData[tbx+tj].radius, localData[tbx+tj].epsilon, &rmjxo, &rmjxh, &emjxo, &emjxh);\n"
"                    computeOneInteraction(localData[tbx+tj], data, rmjxo, rmjxh, emjxo, emjxh, &tempForce, &tempEnergy);\n"
"                    data.force -= tempForce;\n"
"                    localData[tbx+tj].force += tempForce;\n"
"                    energy += (x == y ? 0.5f*tempEnergy : tempEnergy);\n"
"                }\n"
"                tj = (tj+1) & (TILE_SIZE-1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            if (x != y) {\n"
"                offset = y*TILE_SIZE + tgx;\n"
"                ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    } while (pos < end);\n"
"    energyBuffer[GLOBAL_ID] -= AWATER*energy;\n"
"}";
const string CommonAmoebaKernelSources::bicubic = "DEVICE void bicubic(real4 y, real4 y1i, real4 y2i, real4 y12i, real x1, real x1l, real x1u,\n"
"                        real x2, real x2l, real x2u, real* energyOut, real* dang1Out, real* dang2Out) {\n"
"    real c[4][4];\n"
"    real d1 = x1u - x1l;\n"
"    real d2 = x2u - x2l;\n"
"    real d12 = d1*d2;\n"
"    real4 y1 = d1*y1i;\n"
"    real4 y2 = d2*y2i;\n"
"    real4 y12 = d12*y12i;\n"
"\n"
"    c[0][0] = y.x;\n"
"    c[0][1] = y2.x;\n"
"    c[0][2] = 3.0f*(y.w - y.x) - (2.0f*y2.x + y2.w);\n"
"    c[0][3] = 2.0f*(y.x - y.w) + y2.x + y2.w;\n"
"    c[1][0] = y1.x;\n"
"    c[1][1] = y12.x;\n"
"    c[1][2] = 3.0f*(y1.w - y1.x) - (2.0f*y12.x + y12.w);\n"
"    c[1][3] = 2.0f*(y1.x - y1.w) + y12.x + y12.w;\n"
"    c[2][0] = 3.0f*(y.y - y.x) - (2.0f*y1.x + y1.y);\n"
"    c[2][1] = 3.0f*(y2.y - y2.x) - (2.0f*y12.x + y12.y);\n"
"    c[2][2] = 9.0f*(y.x - y.y + y.z - y.w) + 6.0f* y1.x  +  3.0f* y1.y  -  3.0f* y1.z  -  6.0f* y1.w +\n"
"                                             6.0f* y2.x  -  6.0f* y2.y  -  3.0f* y2.z  +  3.0f* y2.w +\n"
"                                             4.0f*y12.x  +  2.0f*y12.y  +       y12.z  +  2.0f*y12.w;\n"
"    c[2][3] = 6.0f*(y.y - y.x + y.w - y.z) + -4.0f* y1.x  -  2.0f* y1.y  +  2.0f* y1.z  +  4.0f* y1.w +\n"
"                                             -3.0f* y2.x  +  3.0f* y2.y  +  3.0f* y2.z  -  3.0f* y2.w\n"
"                                             -2.0f*y12.x  -       y12.y  -       y12.z  -  2.0f*y12.w;\n"
"    c[3][0] = 2.0f*(y.x - y.y) + y1.x + y1.y;\n"
"    c[3][1] = 2.0f*(y2.x - y2.y) + y12.x + y12.y;\n"
"    c[3][2] = 6.0f*(y.y -  y.x +  y.w -  y.z) +\n"
"              3.0f*(y1.z + y1.w - y1.x - y1.y) +\n"
"              2.0f*(2.0f*(y2.y - y2.x) + y2.z - y2.w) +\n"
"             -2.0f*(y12.x + y12.y) - y12.z - y12.w;\n"
"    c[3][3] = 4.0f*( y.x -    y.y  +   y.z -  y.w)  +\n"
"              2.0f*(y1.x +   y1.y  -  y1.z -  y1.w) +\n"
"              2.0f*(y2.x -   y2.y  -  y2.z +  y2.w) +\n"
"                    y12.x +  y12.y  + y12.z + y12.w;\n"
"\n"
"    real t = (x1-x1l) / (x1u-x1l);\n"
"    real u = (x2-x2l) / (x2u-x2l);\n"
"\n"
"    real energy =       ((c[3][3]*u + c[3][2])*u + c[3][1])*u + c[3][0];\n"
"    energy = t*energy + ((c[2][3]*u + c[2][2])*u + c[2][1])*u + c[2][0];\n"
"    energy = t*energy + ((c[1][3]*u + c[1][2])*u + c[1][1])*u + c[1][0];\n"
"    energy = t*energy + ((c[0][3]*u + c[0][2])*u + c[0][1])*u + c[0][0];\n"
"\n"
"    real dang1 =           (3.0f*c[3][3]*t + 2.0f*c[2][3])*t + c[1][3];\n"
"         dang1 = u*dang1 + (3.0f*c[3][2]*t + 2.0f*c[2][2])*t + c[1][2];\n"
"         dang1 = u*dang1 + (3.0f*c[3][1]*t + 2.0f*c[2][1])*t + c[1][1];\n"
"         dang1 = u*dang1 + (3.0f*c[3][0]*t + 2.0f*c[2][0])*t + c[1][0];\n"
"\n"
"    real dang2 =           (3.0f*c[3][3]*u + 2.0f*c[3][2])*u + c[3][1];\n"
"         dang2 = t*dang2 + (3.0f*c[2][3]*u + 2.0f*c[2][2])*u + c[2][1];\n"
"         dang2 = t*dang2 + (3.0f*c[1][3]*u + 2.0f*c[1][2])*u + c[1][1];\n"
"         dang2 = t*dang2 + (3.0f*c[0][3]*u + 2.0f*c[0][2])*u + c[0][1];\n"
"\n"
"    dang1 = dang1 / (x1u-x1l);\n"
"    dang2 = dang2 / (x2u-x2l);\n"
"\n"
"    *energyOut = energy;\n"
"    *dang1Out = dang1;\n"
"    *dang2Out = dang2;\n"
"}";
const string CommonAmoebaKernelSources::gkEDiffPairForce = "#if defined F1\n"
"DEVICE void computeOneEDiffInteractionF1(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real* outputEnergy, real3* outputForce) {\n"
"#elif defined T1\n"
"DEVICE void computeOneEDiffInteractionT1(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real3* outputForce) {\n"
"#elif defined T3\n"
"DEVICE void computeOneEDiffInteractionT3(AtomData4* atom1, LOCAL_ARG volatile AtomData4* atom2, float dScale, float pScale, real3* outputForce) {\n"
"#endif\n"
"    const float uscale = 1;\n"
"\n"
"    // deltaR\n"
"\n"
"    real xr = atom2->pos.x - atom1->pos.x;\n"
"    real yr = atom2->pos.y - atom1->pos.y;\n"
"    real zr = atom2->pos.z - atom1->pos.z;\n"
"\n"
"    real r22 = xr*xr + yr*yr + zr*zr;\n"
"\n"
"    real r = SQRT(r22);\n"
"    real rr1 = RECIP(r);\n"
"    real rr2 = rr1*rr1;\n"
"    real rr3 = rr1*rr2;\n"
"\n"
"    real scale3 = 1;\n"
"    real scale5 = 1;\n"
"    real scale7 = 1;\n"
"\n"
"#ifdef F1\n"
"    real ddsc3_1 = 0;\n"
"    real ddsc3_2 = 0;\n"
"    real ddsc3_3 = 0;\n"
"\n"
"    real ddsc5_1 = 0;\n"
"    real ddsc5_2 = 0;\n"
"    real ddsc5_3 = 0;\n"
"\n"
"    real ddsc7_1 = 0;\n"
"    real ddsc7_2 = 0;\n"
"    real ddsc7_3 = 0;\n"
"\n"
"    real ftm2i1 = 0;\n"
"    real ftm2i2 = 0;\n"
"    real ftm2i3 = 0;\n"
"#endif\n"
"\n"
"    // apply Thole polarization damping to scale factors\n"
" \n"
"    real damp = atom1->damp*atom2->damp;\n"
"    if (damp != 0) {\n"
"        real pgamma = atom2->thole > atom1->thole ? atom1->thole : atom2->thole;\n"
"        real ratio = (r/damp);\n"
"        damp = -pgamma*ratio*ratio*ratio;\n"
"        if (damp > -50) {\n"
"            real dampE = EXP(damp);\n"
"            real damp2 = damp*damp;\n"
"            scale3 = 1 - dampE;\n"
"            scale5 = 1 - (1 - damp)*dampE;\n"
"            scale7 = 1 - (1 - damp + 0.6f*damp2)*dampE;\n"
"\n"
"#ifdef F1\n"
"            ddsc3_1 = -3*damp*EXP(damp)*xr*rr2*rr3;\n"
"            ddsc3_2 = -3*damp*EXP(damp)*yr*rr2*rr3;\n"
"            ddsc3_3 = -3*damp*EXP(damp)*zr*rr2*rr3;\n"
"\n"
"            ddsc5_1 = -3*damp*ddsc3_1*rr2;\n"
"            ddsc5_2 = -3*damp*ddsc3_2*rr2;\n"
"            ddsc5_3 = -3*damp*ddsc3_3*rr2;\n"
"\n"
"            ddsc7_1 = -5*(0.2f+0.6f*damp)*ddsc5_1*rr2;\n"
"            ddsc7_2 = -5*(0.2f+0.6f*damp)*ddsc5_2*rr2;\n"
"            ddsc7_3 = -5*(0.2f+0.6f*damp)*ddsc5_3*rr2;\n"
"#endif\n"
"        }\n"
"    }\n"
"\n"
"    real scale3i = 3*scale3*uscale*rr3*rr2;\n"
"    real scale5i = 3*scale5*uscale*rr3*rr2;\n"
"\n"
"    real dsc3 = scale3*dScale*rr3;\n"
"    real dsc5 = 3*scale5*dScale*rr3*rr2;\n"
"    real dsc7 = 15*scale7*dScale*rr3*rr3*rr1;\n"
"\n"
"    real psc3 = scale3*pScale*rr3;\n"
"    real psc5 = 3*scale5*pScale*rr3*rr2;\n"
"    real psc7 = 15*scale7*pScale*rr3*rr3*rr1;\n"
" \n"
"#ifdef T1\n"
"    real dixr1 = atom1->dipole.y*zr - atom1->dipole.z*yr;\n"
"    real dixr2 = atom1->dipole.z*xr - atom1->dipole.x*zr;\n"
"    real dixr3 = atom1->dipole.x*yr - atom1->dipole.y*xr;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    real dkxr1 = atom2->dipole.y*zr - atom2->dipole.z*yr;\n"
"    real dkxr2 = atom2->dipole.z*xr - atom2->dipole.x*zr;\n"
"    real dkxr3 = atom2->dipole.x*yr - atom2->dipole.y*xr;\n"
"#endif\n"
"\n"
"    real qir1 = atom1->quadrupoleXX*xr + atom1->quadrupoleXY*yr + atom1->quadrupoleXZ*zr;\n"
"    real qir2 = atom1->quadrupoleXY*xr + atom1->quadrupoleYY*yr + atom1->quadrupoleYZ*zr;\n"
"    real qir3 = atom1->quadrupoleXZ*xr + atom1->quadrupoleYZ*yr + atom1->quadrupoleZZ*zr;\n"
"\n"
"    real qkr1 = atom2->quadrupoleXX*xr + atom2->quadrupoleXY*yr + atom2->quadrupoleXZ*zr;\n"
"    real qkr2 = atom2->quadrupoleXY*xr + atom2->quadrupoleYY*yr + atom2->quadrupoleYZ*zr;\n"
"    real qkr3 = atom2->quadrupoleXZ*xr + atom2->quadrupoleYZ*yr + atom2->quadrupoleZZ*zr;\n"
"\n"
"#ifdef T1\n"
"    real rxqir1 = yr*qir3 - zr*qir2;\n"
"    real rxqir2 = zr*qir1 - xr*qir3;\n"
"    real rxqir3 = xr*qir2 - yr*qir1;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    real rxqkr1 = yr*qkr3 - zr*qkr2;\n"
"    real rxqkr2 = zr*qkr1 - xr*qkr3;\n"
"    real rxqkr3 = xr*qkr2 - yr*qkr1;\n"
"#endif\n"
"\n"
"    // get intermediate variables for permanent energy terms\n"
" \n"
"    real sc3 = atom1->dipole.x*xr + atom1->dipole.y*yr + atom1->dipole.z*zr;\n"
"    real sc4 = atom2->dipole.x*xr + atom2->dipole.y*yr + atom2->dipole.z*zr;\n"
"    real sc5 = qir1*xr + qir2*yr + qir3*zr;\n"
"    real sc6 = qkr1*xr + qkr2*yr + qkr3*zr;\n"
" \n"
"#ifdef T1\n"
"    real dixuk1 = atom1->dipole.y*atom2->inducedDipoleS.z - atom1->dipole.z*atom2->inducedDipoleS.y;\n"
"    real dixuk2 = atom1->dipole.z*atom2->inducedDipoleS.x - atom1->dipole.x*atom2->inducedDipoleS.z;\n"
"    real dixuk3 = atom1->dipole.x*atom2->inducedDipoleS.y - atom1->dipole.y*atom2->inducedDipoleS.x;\n"
"\n"
"    real dixukp1 = atom1->dipole.y*atom2->inducedDipolePolarS.z - atom1->dipole.z*atom2->inducedDipolePolarS.y;\n"
"    real dixukp2 = atom1->dipole.z*atom2->inducedDipolePolarS.x - atom1->dipole.x*atom2->inducedDipolePolarS.z;\n"
"    real dixukp3 = atom1->dipole.x*atom2->inducedDipolePolarS.y - atom1->dipole.y*atom2->inducedDipolePolarS.x;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    real dkxui1 = atom2->dipole.y*atom1->inducedDipoleS.z - atom2->dipole.z*atom1->inducedDipoleS.y;\n"
"    real dkxui2 = atom2->dipole.z*atom1->inducedDipoleS.x - atom2->dipole.x*atom1->inducedDipoleS.z;\n"
"    real dkxui3 = atom2->dipole.x*atom1->inducedDipoleS.y - atom2->dipole.y*atom1->inducedDipoleS.x;\n"
"\n"
"    real dkxuip1 = atom2->dipole.y*atom1->inducedDipolePolarS.z - atom2->dipole.z*atom1->inducedDipolePolarS.y;\n"
"    real dkxuip2 = atom2->dipole.z*atom1->inducedDipolePolarS.x - atom2->dipole.x*atom1->inducedDipolePolarS.z;\n"
"    real dkxuip3 = atom2->dipole.x*atom1->inducedDipolePolarS.y - atom2->dipole.y*atom1->inducedDipolePolarS.x;\n"
"#endif\n"
"\n"
"#if defined F1 || defined T1\n"
"    real qiuk1 = atom1->quadrupoleXX*atom2->inducedDipoleS.x + atom1->quadrupoleXY*atom2->inducedDipoleS.y + atom1->quadrupoleXZ*atom2->inducedDipoleS.z;\n"
"    real qiuk2 = atom1->quadrupoleXY*atom2->inducedDipoleS.x + atom1->quadrupoleYY*atom2->inducedDipoleS.y + atom1->quadrupoleYZ*atom2->inducedDipoleS.z;\n"
"    real qiuk3 = atom1->quadrupoleXZ*atom2->inducedDipoleS.x + atom1->quadrupoleYZ*atom2->inducedDipoleS.y + atom1->quadrupoleZZ*atom2->inducedDipoleS.z;\n"
"\n"
"    real qiukp1 = atom1->quadrupoleXX*atom2->inducedDipolePolarS.x + atom1->quadrupoleXY*atom2->inducedDipolePolarS.y + atom1->quadrupoleXZ*atom2->inducedDipolePolarS.z;\n"
"    real qiukp2 = atom1->quadrupoleXY*atom2->inducedDipolePolarS.x + atom1->quadrupoleYY*atom2->inducedDipolePolarS.y + atom1->quadrupoleYZ*atom2->inducedDipolePolarS.z;\n"
"    real qiukp3 = atom1->quadrupoleXZ*atom2->inducedDipolePolarS.x + atom1->quadrupoleYZ*atom2->inducedDipolePolarS.y + atom1->quadrupoleZZ*atom2->inducedDipolePolarS.z;\n"
"#if defined F1\n"
"    qiuk1 -= atom1->quadrupoleXX*atom2->inducedDipole.x + atom1->quadrupoleXY*atom2->inducedDipole.y + atom1->quadrupoleXZ*atom2->inducedDipole.z;\n"
"    qiuk2 -= atom1->quadrupoleXY*atom2->inducedDipole.x + atom1->quadrupoleYY*atom2->inducedDipole.y + atom1->quadrupoleYZ*atom2->inducedDipole.z;\n"
"    qiuk3 -= atom1->quadrupoleXZ*atom2->inducedDipole.x + atom1->quadrupoleYZ*atom2->inducedDipole.y + atom1->quadrupoleZZ*atom2->inducedDipole.z;\n"
"\n"
"    qiukp1 -= atom1->quadrupoleXX*atom2->inducedDipolePolar.x + atom1->quadrupoleXY*atom2->inducedDipolePolar.y + atom1->quadrupoleXZ*atom2->inducedDipolePolar.z;\n"
"    qiukp2 -= atom1->quadrupoleXY*atom2->inducedDipolePolar.x + atom1->quadrupoleYY*atom2->inducedDipolePolar.y + atom1->quadrupoleYZ*atom2->inducedDipolePolar.z;\n"
"    qiukp3 -= atom1->quadrupoleXZ*atom2->inducedDipolePolar.x + atom1->quadrupoleYZ*atom2->inducedDipolePolar.y + atom1->quadrupoleZZ*atom2->inducedDipolePolar.z;\n"
"\n"
"    ftm2i1 -= psc5*qiuk1 + dsc5*qiukp1;\n"
"    ftm2i2 -= psc5*qiuk2 + dsc5*qiukp2;\n"
"    ftm2i3 -= psc5*qiuk3 + dsc5*qiukp3;\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined F1 || defined T3\n"
"    real qkui1 = atom2->quadrupoleXX*atom1->inducedDipoleS.x + atom2->quadrupoleXY*atom1->inducedDipoleS.y + atom2->quadrupoleXZ*atom1->inducedDipoleS.z;\n"
"    real qkui2 = atom2->quadrupoleXY*atom1->inducedDipoleS.x + atom2->quadrupoleYY*atom1->inducedDipoleS.y + atom2->quadrupoleYZ*atom1->inducedDipoleS.z;\n"
"    real qkui3 = atom2->quadrupoleXZ*atom1->inducedDipoleS.x + atom2->quadrupoleYZ*atom1->inducedDipoleS.y + atom2->quadrupoleZZ*atom1->inducedDipoleS.z;\n"
"\n"
"    real qkuip1 = atom2->quadrupoleXX*atom1->inducedDipolePolarS.x + atom2->quadrupoleXY*atom1->inducedDipolePolarS.y + atom2->quadrupoleXZ*atom1->inducedDipolePolarS.z;\n"
"    real qkuip2 = atom2->quadrupoleXY*atom1->inducedDipolePolarS.x + atom2->quadrupoleYY*atom1->inducedDipolePolarS.y + atom2->quadrupoleYZ*atom1->inducedDipolePolarS.z;\n"
"    real qkuip3 = atom2->quadrupoleXZ*atom1->inducedDipolePolarS.x + atom2->quadrupoleYZ*atom1->inducedDipolePolarS.y + atom2->quadrupoleZZ*atom1->inducedDipolePolarS.z;\n"
"\n"
"#if defined F1\n"
"    qkui1 -= atom2->quadrupoleXX*atom1->inducedDipole.x + atom2->quadrupoleXY*atom1->inducedDipole.y + atom2->quadrupoleXZ*atom1->inducedDipole.z;\n"
"    qkui2 -= atom2->quadrupoleXY*atom1->inducedDipole.x + atom2->quadrupoleYY*atom1->inducedDipole.y + atom2->quadrupoleYZ*atom1->inducedDipole.z;\n"
"    qkui3 -= atom2->quadrupoleXZ*atom1->inducedDipole.x + atom2->quadrupoleYZ*atom1->inducedDipole.y + atom2->quadrupoleZZ*atom1->inducedDipole.z;\n"
"\n"
"    qkuip1 -= atom2->quadrupoleXX*atom1->inducedDipolePolar.x + atom2->quadrupoleXY*atom1->inducedDipolePolar.y + atom2->quadrupoleXZ*atom1->inducedDipolePolar.z;\n"
"    qkuip2 -= atom2->quadrupoleXY*atom1->inducedDipolePolar.x + atom2->quadrupoleYY*atom1->inducedDipolePolar.y + atom2->quadrupoleYZ*atom1->inducedDipolePolar.z;\n"
"    qkuip3 -= atom2->quadrupoleXZ*atom1->inducedDipolePolar.x + atom2->quadrupoleYZ*atom1->inducedDipolePolar.y + atom2->quadrupoleZZ*atom1->inducedDipolePolar.z;\n"
"\n"
"    ftm2i1 += psc5*qkui1 + dsc5*qkuip1;\n"
"    ftm2i2 += psc5*qkui2 + dsc5*qkuip2;\n"
"    ftm2i3 += psc5*qkui3 + dsc5*qkuip3;\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    real uixqkr1 = atom1->inducedDipoleS.y*qkr3 - atom1->inducedDipoleS.z*qkr2;\n"
"    real uixqkr2 = atom1->inducedDipoleS.z*qkr1 - atom1->inducedDipoleS.x*qkr3;\n"
"    real uixqkr3 = atom1->inducedDipoleS.x*qkr2 - atom1->inducedDipoleS.y*qkr1;\n"
"\n"
"    real uixqkrp1 = atom1->inducedDipolePolarS.y*qkr3 - atom1->inducedDipolePolarS.z*qkr2;\n"
"    real uixqkrp2 = atom1->inducedDipolePolarS.z*qkr1 - atom1->inducedDipolePolarS.x*qkr3;\n"
"    real uixqkrp3 = atom1->inducedDipolePolarS.x*qkr2 - atom1->inducedDipolePolarS.y*qkr1;\n"
"\n"
"    real rxqkuip1 = yr*qkuip3 - zr*qkuip2;\n"
"    real rxqkuip2 = zr*qkuip1 - xr*qkuip3;\n"
"    real rxqkuip3 = xr*qkuip2 - yr*qkuip1;\n"
"\n"
"    real rxqkui1 = yr*qkui3 - zr*qkui2;\n"
"    real rxqkui2 = zr*qkui1 - xr*qkui3;\n"
"    real rxqkui3 = xr*qkui2 - yr*qkui1;\n"
"#endif\n"
"\n"
"#ifdef T1\n"
"    real ukxqir1 = atom2->inducedDipoleS.y*qir3 - atom2->inducedDipoleS.z*qir2;\n"
"    real ukxqir2 = atom2->inducedDipoleS.z*qir1 - atom2->inducedDipoleS.x*qir3;\n"
"    real ukxqir3 = atom2->inducedDipoleS.x*qir2 - atom2->inducedDipoleS.y*qir1;\n"
"\n"
"    real ukxqirp1 = atom2->inducedDipolePolarS.y*qir3 - atom2->inducedDipolePolarS.z*qir2;\n"
"    real ukxqirp2 = atom2->inducedDipolePolarS.z*qir1 - atom2->inducedDipolePolarS.x*qir3;\n"
"    real ukxqirp3 = atom2->inducedDipolePolarS.x*qir2 - atom2->inducedDipolePolarS.y*qir1;\n"
"\n"
"    real rxqiuk1 = yr*qiuk3 - zr*qiuk2;\n"
"    real rxqiuk2 = zr*qiuk1 - xr*qiuk3;\n"
"    real rxqiuk3 = xr*qiuk2 - yr*qiuk1;\n"
"\n"
"    real rxqiukp1 = yr*qiukp3 - zr*qiukp2;\n"
"    real rxqiukp2 = zr*qiukp1 - xr*qiukp3;\n"
"    real rxqiukp3 = xr*qiukp2 - yr*qiukp1;\n"
"#endif\n"
"\n"
"    // get intermediate variables for induction energy terms\n"
"\n"
"    real sci3 = atom1->inducedDipoleS.x*xr + atom1->inducedDipoleS.y*yr + atom1->inducedDipoleS.z*zr;\n"
"    real sci4 = atom2->inducedDipoleS.x*xr + atom2->inducedDipoleS.y*yr + atom2->inducedDipoleS.z*zr;\n"
"#ifdef F1\n"
"    ftm2i1 += 0.5f*scale5i*(sci4*atom1->inducedDipolePolarS.x + sci3*atom2->inducedDipolePolarS.x);\n"
"    ftm2i2 += 0.5f*scale5i*(sci4*atom1->inducedDipolePolarS.y + sci3*atom2->inducedDipolePolarS.y);\n"
"    ftm2i3 += 0.5f*scale5i*(sci4*atom1->inducedDipolePolarS.z + sci3*atom2->inducedDipolePolarS.z);\n"
"#endif\n"
"    real sci3Y = atom1->inducedDipole.x*xr + atom1->inducedDipole.y*yr + atom1->inducedDipole.z*zr;\n"
"    real sci4Y = atom2->inducedDipole.x*xr + atom2->inducedDipole.y*yr + atom2->inducedDipole.z*zr;\n"
"#ifdef F1\n"
"    ftm2i1 -= 0.5f*scale5i*(sci3Y*atom2->inducedDipolePolar.x + sci4Y*atom1->inducedDipolePolar.x);\n"
"    ftm2i2 -= 0.5f*scale5i*(sci3Y*atom2->inducedDipolePolar.y + sci4Y*atom1->inducedDipolePolar.y);\n"
"    ftm2i3 -= 0.5f*scale5i*(sci3Y*atom2->inducedDipolePolar.z + sci4Y*atom1->inducedDipolePolar.z);\n"
"#endif\n"
"\n"
"    real sci7 = qir1*atom2->inducedDipoleS.x + qir2*atom2->inducedDipoleS.y + qir3*atom2->inducedDipoleS.z;\n"
"    real sci8 = qkr1*atom1->inducedDipoleS.x + qkr2*atom1->inducedDipoleS.y + qkr3*atom1->inducedDipoleS.z;\n"
"    real scip1 = atom1->inducedDipolePolarS.x*atom2->dipole.x + atom1->inducedDipolePolarS.y*atom2->dipole.y + atom1->inducedDipolePolarS.z*atom2->dipole.z +\n"
"                              atom1->dipole.x*atom2->inducedDipolePolarS.x + atom1->dipole.y*atom2->inducedDipolePolarS.y + atom1->dipole.z*atom2->inducedDipolePolarS.z;\n"
"\n"
"    real scip2 = atom1->inducedDipoleS.x*atom2->inducedDipolePolarS.x + atom1->inducedDipoleS.y*atom2->inducedDipolePolarS.y + atom1->inducedDipoleS.z*atom2->inducedDipolePolarS.z +\n"
"                              atom1->inducedDipolePolarS.x*atom2->inducedDipoleS.x + atom1->inducedDipolePolarS.y*atom2->inducedDipoleS.y + atom1->inducedDipolePolarS.z*atom2->inducedDipoleS.z;\n"
"\n"
"    sci7 -= qir1*atom2->inducedDipole.x + qir2*atom2->inducedDipole.y + qir3*atom2->inducedDipole.z;\n"
"    sci8 -= qkr1*atom1->inducedDipole.x + qkr2*atom1->inducedDipole.y + qkr3*atom1->inducedDipole.z;\n"
"\n"
"    scip1 -= atom1->inducedDipolePolar.x*atom2->dipole.x + atom1->inducedDipolePolar.y*atom2->dipole.y + atom1->inducedDipolePolar.z*atom2->dipole.z +\n"
"                              atom1->dipole.x*atom2->inducedDipolePolar.x + atom1->dipole.y*atom2->inducedDipolePolar.y + atom1->dipole.z*atom2->inducedDipolePolar.z;\n"
"\n"
"\n"
"    scip2 -= atom1->inducedDipole.x*atom2->inducedDipolePolar.x + atom1->inducedDipole.y*atom2->inducedDipolePolar.y + atom1->inducedDipole.z*atom2->inducedDipolePolar.z   +\n"
"                              atom1->inducedDipolePolar.x*atom2->inducedDipole.x + atom1->inducedDipolePolar.y*atom2->inducedDipole.y + atom1->inducedDipolePolar.z*atom2->inducedDipole.z;\n"
"\n"
"\n"
"    real scip3 = atom1->inducedDipolePolarS.x*xr + atom1->inducedDipolePolarS.y*yr + atom1->inducedDipolePolarS.z*zr;\n"
"    real scip4 = atom2->inducedDipolePolarS.x*xr + atom2->inducedDipolePolarS.y*yr + atom2->inducedDipolePolarS.z*zr;\n"
"    real gfi1 = -2.5f*(sci3*scip4+scip3*sci4)*scale5i;\n"
"\n"
"#ifdef F1\n"
"    ftm2i1 += 0.5f*scale5i*(scip4*atom1->inducedDipoleS.x + scip3*atom2->inducedDipoleS.x);\n"
"    ftm2i2 += 0.5f*scale5i*(scip4*atom1->inducedDipoleS.y + scip3*atom2->inducedDipoleS.y);\n"
"    ftm2i3 += 0.5f*scale5i*(scip4*atom1->inducedDipoleS.z + scip3*atom2->inducedDipoleS.z);\n"
"#endif\n"
"\n"
"    real scip3Y = atom1->inducedDipolePolar.x*xr + atom1->inducedDipolePolar.y*yr + atom1->inducedDipolePolar.z*zr;\n"
"    real scip4Y = atom2->inducedDipolePolar.x*xr + atom2->inducedDipolePolar.y*yr + atom2->inducedDipolePolar.z*zr;\n"
"    gfi1 += 2.5f*(sci3Y*scip4Y + scip3Y*sci4Y)*scale5i;\n"
"#ifdef F1\n"
"    ftm2i1 -= 0.5f*scale5i*(scip3Y*atom2->inducedDipole.x + scip4Y*atom1->inducedDipole.x);\n"
"    ftm2i2 -= 0.5f*scale5i*(scip3Y*atom2->inducedDipole.y + scip4Y*atom1->inducedDipole.y);\n"
"    ftm2i3 -= 0.5f*scale5i*(scip3Y*atom2->inducedDipole.z + scip4Y*atom1->inducedDipole.z);\n"
"#endif\n"
"    sci3Y = sci3 - sci3Y;\n"
"    sci4Y = sci4 - sci4Y;\n"
"    scip3Y = scip3 - scip3Y;\n"
"    scip4Y = scip4 - scip4Y;\n"
"\n"
"    real scip7 = qir1*atom2->inducedDipolePolarS.x + qir2*atom2->inducedDipolePolarS.y + qir3*atom2->inducedDipolePolarS.z;\n"
"    scip7 -= qir1*atom2->inducedDipolePolar.x + qir2*atom2->inducedDipolePolar.y + qir3*atom2->inducedDipolePolar.z;\n"
"\n"
"    real scip8 = qkr1*atom1->inducedDipolePolarS.x + qkr2*atom1->inducedDipolePolarS.y + qkr3*atom1->inducedDipolePolarS.z;\n"
"    scip8 -= qkr1*atom1->inducedDipolePolar.x + qkr2*atom1->inducedDipolePolar.y + qkr3*atom1->inducedDipolePolar.z;\n"
"\n"
"    real sci1 = atom1->inducedDipoleS.x*atom2->dipole.x + atom1->inducedDipoleS.y*atom2->dipole.y +\n"
"                              atom1->inducedDipoleS.z*atom2->dipole.z + atom1->dipole.x*atom2->inducedDipoleS.x +\n"
"                              atom1->dipole.y*atom2->inducedDipoleS.y + atom1->dipole.z*atom2->inducedDipoleS.z;\n"
"    sci1 -= atom1->inducedDipole.x*atom2->dipole.x + atom1->inducedDipole.y*atom2->dipole.y +\n"
"                              atom1->inducedDipole.z*atom2->dipole.z + atom1->dipole.x*atom2->inducedDipole.x +\n"
"                              atom1->dipole.y*atom2->inducedDipole.y + atom1->dipole.z*atom2->inducedDipole.z;\n"
"\n"
"    real gli1 = atom2->q*sci3Y - atom1->q*sci4Y + sci1;\n"
"    real gli2 = -sc3*sci4Y - sci3Y*sc4 + 2*(sci7-sci8);\n"
"    real gli3 = sci3Y*sc6 - sci4Y*sc5;\n"
"    real glip1 = atom2->q*scip3Y - atom1->q*scip4Y + scip1;\n"
"    real glip2 = -sc3*scip4Y - scip3Y*sc4 + 2*(scip7-scip8);\n"
"    real glip3 = scip3Y*sc6 - scip4Y*sc5;\n"
"\n"
"#ifdef F1\n"
"    ftm2i1 -= 0.5f*((gli1*pScale + glip1*dScale)*ddsc3_1 + (gli2*pScale + glip2*dScale)*ddsc5_1 + (gli3*pScale+glip3*dScale)*ddsc7_1);\n"
"    ftm2i2 -= 0.5f*((gli1*pScale + glip1*dScale)*ddsc3_2 + (gli2*pScale + glip2*dScale)*ddsc5_2 + (gli3*pScale+glip3*dScale)*ddsc7_2);\n"
"    ftm2i3 -= 0.5f*((gli1*pScale + glip1*dScale)*ddsc3_3 + (gli2*pScale + glip2*dScale)*ddsc5_3 + (gli3*pScale+glip3*dScale)*ddsc7_3);\n"
"    *outputEnergy = gli1*psc3 + gli2*psc5 + gli3*psc7;\n"
"#endif\n"
"\n"
"    gfi1 += 1.5f*(gli1*psc3 + glip1*dsc3);\n"
"    gfi1 += 2.5f*(gli2*psc5 + glip2*dsc5);\n"
"    gfi1 += 3.5f*(gli3*psc7 + glip3*dsc7);\n"
"    gfi1 *= rr2;\n"
"    gfi1 += 0.5f*scip2*scale3i;\n"
"\n"
"#if defined F1 || defined T1\n"
"    real gfi5 =  (sci4Y*psc7+scip4Y*dsc7);\n"
"#endif\n"
"\n"
"#if defined F1 || defined T3\n"
"    real gfi6 = -(sci3Y*psc7+scip3Y*dsc7);\n"
"#endif\n"
"\n"
"#ifdef F1\n"
"    ftm2i1 += gfi1*xr;\n"
"\n"
"    real diff0 = atom1->inducedDipoleS.x - atom1->inducedDipole.x;               \n"
"    real diff1 = atom1->inducedDipolePolarS.x - atom1->inducedDipolePolar.x;               \n"
"    ftm2i1 += 0.5f*(-atom2->q*(diff0*psc3 + diff1*dsc3) + sc4*(diff0*psc5 + diff1*dsc5) - sc6*(diff0*psc7 + diff1*dsc7));\n"
"    \n"
"    diff0 = atom2->inducedDipoleS.x - atom2->inducedDipole.x;               \n"
"    diff1 = atom2->inducedDipolePolarS.x - atom2->inducedDipolePolar.x;               \n"
"    ftm2i1 += 0.5f*(atom1->q*(diff0*psc3 + diff1*dsc3) + sc3*(diff0*psc5 + diff1*dsc5) + sc5*(diff0*psc7 + diff1*dsc7));\n"
"    ftm2i1 += 0.5f*(sci4Y*psc5+scip4Y*dsc5)*atom1->dipole.x + 0.5f*(sci3Y*psc5+scip3Y*dsc5)*atom2->dipole.x + gfi5*qir1 + gfi6*qkr1;\n"
"\n"
"    ftm2i2 += gfi1*yr;\n"
"\n"
"    diff0 = atom1->inducedDipoleS.y - atom1->inducedDipole.y;               \n"
"    diff1 = atom1->inducedDipolePolarS.y - atom1->inducedDipolePolar.y;               \n"
"    ftm2i2 += 0.5f*(-atom2->q*(diff0*psc3 + diff1*dsc3) + sc4*(diff0*psc5 + diff1*dsc5) - sc6*(diff0*psc7 + diff1*dsc7));\n"
"\n"
"    diff0 = atom2->inducedDipoleS.y - atom2->inducedDipole.y;               \n"
"    diff1 = atom2->inducedDipolePolarS.y - atom2->inducedDipolePolar.y;               \n"
"\n"
"    ftm2i2 += 0.5f*(atom1->q*(diff0*psc3 + diff1*dsc3) + sc3*(diff0*psc5 + diff1*dsc5) + sc5*(diff0*psc7 + diff1*dsc7));\n"
"    ftm2i2 += 0.5f*(sci4Y*psc5+scip4Y*dsc5)*atom1->dipole.y + 0.5f*(sci3Y*psc5+scip3Y*dsc5)*atom2->dipole.y + gfi5*qir2 + gfi6*qkr2;\n"
"\n"
"    ftm2i3 += gfi1*zr;\n"
"\n"
"    diff0 = atom1->inducedDipoleS.z - atom1->inducedDipole.z;               \n"
"    diff1 = atom1->inducedDipolePolarS.z - atom1->inducedDipolePolar.z;               \n"
"    ftm2i3 += 0.5f*(-atom2->q*(diff0*psc3 + diff1*dsc3) + sc4*(diff0*psc5 + diff1*dsc5) - sc6*(diff0*psc7 + diff1*dsc7));\n"
"    diff0 = atom2->inducedDipoleS.z - atom2->inducedDipole.z;               \n"
"    diff1 = atom2->inducedDipolePolarS.z - atom2->inducedDipolePolar.z;               \n"
"\n"
"    ftm2i3 += 0.5f*(atom1->q*(diff0*psc3 + diff1*dsc3) + sc3*(diff0*psc5 + diff1*dsc5) + sc5*(diff0*psc7 + diff1*dsc7));\n"
"    ftm2i3 += 0.5f*(sci4Y*psc5+scip4Y*dsc5)*atom1->dipole.z + 0.5f*(sci3Y*psc5+scip3Y*dsc5)*atom2->dipole.z + gfi5*qir3 + gfi6*qkr3;\n"
" \n"
"    // intermediate values needed for partially excluded interactions\n"
"\n"
"    // correction to convert mutual to direct polarization force\n"
"\n"
"#ifdef MUTUAL_POLARIZATION\n"
"    real findmp1 = uscale*(scip2*ddsc3_1 - ddsc5_1*(sci3*scip4+scip3*sci4));\n"
"    real findmp2 = uscale*(scip2*ddsc3_2 - ddsc5_2*(sci3*scip4+scip3*sci4));\n"
"    real findmp3 = uscale*(scip2*ddsc3_3 - ddsc5_3*(sci3*scip4+scip3*sci4));\n"
"    ftm2i1 -= 0.5f*findmp1;\n"
"    ftm2i2 -= 0.5f*findmp2;\n"
"    ftm2i3 -= 0.5f*findmp3;\n"
"\n"
"    real sci3X = sci3 - sci3Y;\n"
"    real sci4X = sci4 - sci4Y;\n"
"    real scip3X = scip3 - scip3Y;\n"
"    real scip4X = scip4 - scip4Y;\n"
"    ftm2i1 += 0.5f*uscale*(-ddsc5_1*(sci3X*scip4X+scip3X*sci4X));\n"
"    ftm2i2 += 0.5f*uscale*(-ddsc5_2*(sci3X*scip4X+scip3X*sci4X));\n"
"    ftm2i3 += 0.5f*uscale*(-ddsc5_3*(sci3X*scip4X+scip3X*sci4X)); \n"
"#else\n"
"    real gfd = (scip2*scale3i - 5*rr2*(scip3*sci4+sci3*scip4)*scale5i);\n"
"    real fdir1 = gfd*xr + scale5i* (sci4*atom1->inducedDipolePolarS.x+scip4*atom1->inducedDipoleS.x + sci3*atom2->inducedDipolePolarS.x+scip3*atom2->inducedDipoleS.x);\n"
"    real fdir2 = gfd*yr + scale5i* (sci4*atom1->inducedDipolePolarS.y+scip4*atom1->inducedDipoleS.y + sci3*atom2->inducedDipolePolarS.y+scip3*atom2->inducedDipoleS.y);\n"
"    real fdir3 = gfd*zr + scale5i* (sci4*atom1->inducedDipolePolarS.z+scip4*atom1->inducedDipoleS.z + sci3*atom2->inducedDipolePolarS.z+scip3*atom2->inducedDipoleS.z);\n"
"    ftm2i1 -= 0.5f*fdir1;\n"
"    ftm2i2 -= 0.5f*fdir2;\n"
"    ftm2i3 -= 0.5f*fdir3;\n"
"\n"
"    real sci3X = sci3 - sci3Y;\n"
"    real sci4X = sci4 - sci4Y;\n"
"    real scip3X = scip3 - scip3Y;\n"
"    real scip4X = scip4 - scip4Y;\n"
"    gfd = -5*rr2*(scip3X*sci4X+sci3X*scip4X)*scale5i;\n"
"    fdir1 = gfd*xr + scale5i*(sci4X*atom1->inducedDipolePolar.x + scip4X*atom1->inducedDipole.x + sci3X*atom2->inducedDipolePolar.x + scip3X*atom2->inducedDipole.x);\n"
"    fdir2 = gfd*yr + scale5i*(sci4X*atom1->inducedDipolePolar.y + scip4X*atom1->inducedDipole.y + sci3X*atom2->inducedDipolePolar.y + scip3X*atom2->inducedDipole.y);\n"
"    fdir3 = gfd*zr + scale5i*(sci4X*atom1->inducedDipolePolar.z + scip4X*atom1->inducedDipole.z + sci3X*atom2->inducedDipolePolar.z + scip3X*atom2->inducedDipole.z);\n"
"    ftm2i1 += 0.5f*fdir1;\n"
"    ftm2i2 += 0.5f*fdir2;\n"
"    ftm2i3 += 0.5f*fdir3;\n"
"#endif\n"
"#endif\n"
"\n"
"#ifdef T1\n"
"    real gti2 = 0.5f*(sci4Y*psc5 + scip4Y*dsc5);\n"
"    real ttm2i1 = -(dixuk1*psc3+dixukp1*dsc3)*0.5f + gti2*dixr1 + ((ukxqir1+rxqiuk1)*psc5 +(ukxqirp1+rxqiukp1)*dsc5) - gfi5*rxqir1;\n"
"    real ttm2i2 = -(dixuk2*psc3+dixukp2*dsc3)*0.5f + gti2*dixr2 + ((ukxqir2+rxqiuk2)*psc5 +(ukxqirp2+rxqiukp2)*dsc5) - gfi5*rxqir2;\n"
"    real ttm2i3 = -(dixuk3*psc3+dixukp3*dsc3)*0.5f + gti2*dixr3 + ((ukxqir3+rxqiuk3)*psc5 +(ukxqirp3+rxqiukp3)*dsc5) - gfi5*rxqir3;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    real gti3 = 0.5f*(sci3Y*psc5 + scip3Y*dsc5);\n"
"    real ttm3i1 = -(dkxui1*psc3+dkxuip1*dsc3)*0.5f + gti3*dkxr1 - ((uixqkr1+rxqkui1)*psc5 +(uixqkrp1+rxqkuip1)*dsc5) - gfi6*rxqkr1;\n"
"    real ttm3i2 = -(dkxui2*psc3+dkxuip2*dsc3)*0.5f + gti3*dkxr2 - ((uixqkr2+rxqkui2)*psc5 +(uixqkrp2+rxqkuip2)*dsc5) - gfi6*rxqkr2;\n"
"    real ttm3i3 = -(dkxui3*psc3+dkxuip3*dsc3)*0.5f + gti3*dkxr3 - ((uixqkr3+rxqkui3)*psc5 +(uixqkrp3+rxqkuip3)*dsc5) - gfi6*rxqkr3;\n"
"#endif\n"
" \n"
"    // update force and torque on site k\n"
"    \n"
"#ifdef F1\n"
"    outputForce->x = -ftm2i1;\n"
"    outputForce->y = -ftm2i2;\n"
"    outputForce->z = -ftm2i3;\n"
"#endif\n"
"\n"
"#ifdef T1\n"
"    outputForce->x = ttm2i1;\n"
"    outputForce->y = ttm2i2;\n"
"    outputForce->z = ttm2i3;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    outputForce->x = ttm3i1;\n"
"    outputForce->y = ttm3i2;\n"
"    outputForce->z = ttm3i3;\n"
"#endif\n"
"\n"
"    // construct auxiliary vectors for induced terms\n"
"\n"
"#ifdef T1\n"
"    dixuk1 = atom1->dipole.y*atom2->inducedDipole.z - atom1->dipole.z*atom2->inducedDipole.y;\n"
"    dixuk2 = atom1->dipole.z*atom2->inducedDipole.x - atom1->dipole.x*atom2->inducedDipole.z;\n"
"    dixuk3 = atom1->dipole.x*atom2->inducedDipole.y - atom1->dipole.y*atom2->inducedDipole.x;\n"
"\n"
"    dixukp1 = atom1->dipole.y*atom2->inducedDipolePolar.z - atom1->dipole.z*atom2->inducedDipolePolar.y;\n"
"    dixukp2 = atom1->dipole.z*atom2->inducedDipolePolar.x - atom1->dipole.x*atom2->inducedDipolePolar.z;\n"
"    dixukp3 = atom1->dipole.x*atom2->inducedDipolePolar.y - atom1->dipole.y*atom2->inducedDipolePolar.x;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    dkxui1 = atom2->dipole.y*atom1->inducedDipole.z - atom2->dipole.z*atom1->inducedDipole.y;\n"
"    dkxui2 = atom2->dipole.z*atom1->inducedDipole.x - atom2->dipole.x*atom1->inducedDipole.z;\n"
"    dkxui3 = atom2->dipole.x*atom1->inducedDipole.y - atom2->dipole.y*atom1->inducedDipole.x;\n"
"\n"
"    dkxuip1 = atom2->dipole.y*atom1->inducedDipolePolar.z - atom2->dipole.z*atom1->inducedDipolePolar.y;\n"
"    dkxuip2 = atom2->dipole.z*atom1->inducedDipolePolar.x - atom2->dipole.x*atom1->inducedDipolePolar.z;\n"
"    dkxuip3 = atom2->dipole.x*atom1->inducedDipolePolar.y - atom2->dipole.y*atom1->inducedDipolePolar.x;\n"
"#endif\n"
"\n"
"#if defined T1\n"
"    qiuk1 = atom1->quadrupoleXX*atom2->inducedDipole.x + atom1->quadrupoleXY*atom2->inducedDipole.y + atom1->quadrupoleXZ*atom2->inducedDipole.z;\n"
"    qiuk2 = atom1->quadrupoleXY*atom2->inducedDipole.x + atom1->quadrupoleYY*atom2->inducedDipole.y + atom1->quadrupoleYZ*atom2->inducedDipole.z;\n"
"    qiuk3 = atom1->quadrupoleXZ*atom2->inducedDipole.x + atom1->quadrupoleYZ*atom2->inducedDipole.y + atom1->quadrupoleZZ*atom2->inducedDipole.z;\n"
"\n"
"    qiukp1 = atom1->quadrupoleXX*atom2->inducedDipolePolar.x + atom1->quadrupoleXY*atom2->inducedDipolePolar.y + atom1->quadrupoleXZ*atom2->inducedDipolePolar.z;\n"
"    qiukp2 = atom1->quadrupoleXY*atom2->inducedDipolePolar.x + atom1->quadrupoleYY*atom2->inducedDipolePolar.y + atom1->quadrupoleYZ*atom2->inducedDipolePolar.z;\n"
"    qiukp3 = atom1->quadrupoleXZ*atom2->inducedDipolePolar.x + atom1->quadrupoleYZ*atom2->inducedDipolePolar.y + atom1->quadrupoleZZ*atom2->inducedDipolePolar.z;\n"
"#endif\n"
"\n"
"#if defined T3\n"
"    qkui1 = atom2->quadrupoleXX*atom1->inducedDipole.x + atom2->quadrupoleXY*atom1->inducedDipole.y + atom2->quadrupoleXZ*atom1->inducedDipole.z;\n"
"    qkui2 = atom2->quadrupoleXY*atom1->inducedDipole.x + atom2->quadrupoleYY*atom1->inducedDipole.y + atom2->quadrupoleYZ*atom1->inducedDipole.z;\n"
"    qkui3 = atom2->quadrupoleXZ*atom1->inducedDipole.x + atom2->quadrupoleYZ*atom1->inducedDipole.y + atom2->quadrupoleZZ*atom1->inducedDipole.z;\n"
"\n"
"    qkuip1 = atom2->quadrupoleXX*atom1->inducedDipolePolar.x + atom2->quadrupoleXY*atom1->inducedDipolePolar.y + atom2->quadrupoleXZ*atom1->inducedDipolePolar.z;\n"
"    qkuip2 = atom2->quadrupoleXY*atom1->inducedDipolePolar.x + atom2->quadrupoleYY*atom1->inducedDipolePolar.y + atom2->quadrupoleYZ*atom1->inducedDipolePolar.z;\n"
"    qkuip3 = atom2->quadrupoleXZ*atom1->inducedDipolePolar.x + atom2->quadrupoleYZ*atom1->inducedDipolePolar.y + atom2->quadrupoleZZ*atom1->inducedDipolePolar.z;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    uixqkr1 = atom1->inducedDipole.y*qkr3 - atom1->inducedDipole.z*qkr2;\n"
"    uixqkr2 = atom1->inducedDipole.z*qkr1 - atom1->inducedDipole.x*qkr3;\n"
"    uixqkr3 = atom1->inducedDipole.x*qkr2 - atom1->inducedDipole.y*qkr1;\n"
"\n"
"    uixqkrp1 = atom1->inducedDipolePolar.y*qkr3 - atom1->inducedDipolePolar.z*qkr2;\n"
"    uixqkrp2 = atom1->inducedDipolePolar.z*qkr1 - atom1->inducedDipolePolar.x*qkr3;\n"
"    uixqkrp3 = atom1->inducedDipolePolar.x*qkr2 - atom1->inducedDipolePolar.y*qkr1;\n"
"#endif\n"
"\n"
"#ifdef T1\n"
"    ukxqir1 = atom2->inducedDipole.y*qir3 - atom2->inducedDipole.z*qir2;\n"
"    ukxqir2 = atom2->inducedDipole.z*qir1 - atom2->inducedDipole.x*qir3;\n"
"    ukxqir3 = atom2->inducedDipole.x*qir2 - atom2->inducedDipole.y*qir1;\n"
"\n"
"    ukxqirp1 = atom2->inducedDipolePolar.y*qir3 - atom2->inducedDipolePolar.z*qir2;\n"
"    ukxqirp2 = atom2->inducedDipolePolar.z*qir1 - atom2->inducedDipolePolar.x*qir3;\n"
"    ukxqirp3 = atom2->inducedDipolePolar.x*qir2 - atom2->inducedDipolePolar.y*qir1;\n"
"\n"
"    rxqiuk1 = yr*qiuk3 - zr*qiuk2;\n"
"    rxqiuk2 = zr*qiuk1 - xr*qiuk3;\n"
"    rxqiuk3 = xr*qiuk2 - yr*qiuk1;\n"
"\n"
"    rxqiukp1 = yr*qiukp3 - zr*qiukp2;\n"
"    rxqiukp2 = zr*qiukp1 - xr*qiukp3;\n"
"    rxqiukp3 = xr*qiukp2 - yr*qiukp1;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    rxqkui1 = yr*qkui3 - zr*qkui2;\n"
"    rxqkui2 = zr*qkui1 - xr*qkui3;\n"
"    rxqkui3 = xr*qkui2 - yr*qkui1;\n"
"\n"
"    rxqkuip1 = yr*qkuip3 - zr*qkuip2;\n"
"    rxqkuip2 = zr*qkuip1 - xr*qkuip3;\n"
"    rxqkuip3 = xr*qkuip2 - yr*qkuip1;\n"
"#endif\n"
"\n"
"#ifdef T1\n"
"     ttm2i1 = -(dixuk1*psc3+dixukp1*dsc3)*0.5f + ((ukxqir1+rxqiuk1)*psc5 +(ukxqirp1+rxqiukp1)*dsc5);\n"
"     ttm2i2 = -(dixuk2*psc3+dixukp2*dsc3)*0.5f + ((ukxqir2+rxqiuk2)*psc5 +(ukxqirp2+rxqiukp2)*dsc5);\n"
"     ttm2i3 = -(dixuk3*psc3+dixukp3*dsc3)*0.5f + ((ukxqir3+rxqiuk3)*psc5 +(ukxqirp3+rxqiukp3)*dsc5);\n"
"#endif\n"
" \n"
"#ifdef T3\n"
"     ttm3i1 = -(dkxui1*psc3+dkxuip1*dsc3)*0.5f - ((uixqkr1+rxqkui1)*psc5 +(uixqkrp1+rxqkuip1)*dsc5);\n"
"     ttm3i2 = -(dkxui2*psc3+dkxuip2*dsc3)*0.5f - ((uixqkr2+rxqkui2)*psc5 +(uixqkrp2+rxqkuip2)*dsc5);\n"
"     ttm3i3 = -(dkxui3*psc3+dkxuip3*dsc3)*0.5f - ((uixqkr3+rxqkui3)*psc5 +(uixqkrp3+rxqkuip3)*dsc5);\n"
"#endif\n"
"\n"
"    // update force and torque on site k;\n"
"\n"
"#ifdef T1\n"
"    outputForce->x -= ttm2i1;\n"
"    outputForce->y -= ttm2i2;\n"
"    outputForce->z -= ttm2i3;\n"
"#endif\n"
"\n"
"#ifdef T3\n"
"    outputForce->x -= ttm3i1;\n"
"    outputForce->y -= ttm3i2;\n"
"    outputForce->z -= ttm3i3;\n"
"#endif\n"
"}\n"
"";
const string CommonAmoebaKernelSources::gkPairForce1 = "/**\n"
" * This defines three different closely related functions, depending on which constant (F1, T1, or T3) is defined.\n"
" * To work around limitations in Visual Studio, this kernel is split into two files.\n"
" */\n"
"\n"
"#if defined F1\n"
"DEVICE void computeOneInteractionF1(AtomData2 atom1, volatile AtomData2 atom2, real* outputEnergy, real3* force) {\n"
"#elif defined F2\n"
"DEVICE void computeOneInteractionF2(AtomData2 atom1, volatile AtomData2 atom2, real* outputEnergy, real3* force) {\n"
"#elif defined T1\n"
"DEVICE void computeOneInteractionT1(AtomData2 atom1, volatile AtomData2 atom2, real3* torque) {\n"
"#elif defined T2\n"
"DEVICE void computeOneInteractionT2(AtomData2 atom1, volatile AtomData2 atom2, real3* torque) {\n"
"#elif defined B1 && defined B2\n"
"DEVICE void computeOneInteractionB1B2(AtomData2 atom1, volatile AtomData2 atom2, real* bornForce1, real* bornForce2) {\n"
"#endif\n"
"\n"
"    const real fc = EPSILON_FACTOR*GK_FC;\n"
"    const real fd = EPSILON_FACTOR*GK_FD;\n"
"    const real fq = EPSILON_FACTOR*GK_FQ;\n"
"\n"
"#if defined F2 || defined B2\n"
"    real sxi = atom1.inducedDipole.x + atom1.inducedDipolePolar.x;\n"
"    real syi = atom1.inducedDipole.y + atom1.inducedDipolePolar.y;\n"
"    real szi = atom1.inducedDipole.z + atom1.inducedDipolePolar.z;\n"
"#endif\n"
"\n"
"#if defined F2 || defined T2 || defined B2\n"
"    real sxk = atom2.inducedDipole.x + atom2.inducedDipolePolar.x;\n"
"    real syk = atom2.inducedDipole.y + atom2.inducedDipolePolar.y;\n"
"    real szk = atom2.inducedDipole.z + atom2.inducedDipolePolar.z;\n"
"#endif\n"
"\n"
"    // decide whether to compute the current interaction;\n"
"\n"
"    real xr = atom2.pos.x - atom1.pos.x;\n"
"    real yr = atom2.pos.y - atom1.pos.y;\n"
"    real zr = atom2.pos.z - atom1.pos.z;\n"
"\n"
"    real xr2 = xr*xr;\n"
"    real yr2 = yr*yr;\n"
"    real zr2 = zr*zr;\n"
"    real r2 = xr2 + yr2 + zr2;\n"
"\n"
"    real rb2 = atom1.bornRadius*atom2.bornRadius;\n"
"\n"
"    real expterm = EXP(-r2/(GK_C*rb2));\n"
"    real expc = expterm/GK_C;\n"
"    real expcr = r2*expterm/(GK_C*GK_C*rb2*rb2);\n"
"    real dexpc = -2 / (GK_C*rb2);\n"
"    real dexpcr = 2 / (GK_C*rb2*rb2);\n"
"    real dgfdr = 0.5f*expterm*(1 + r2/(rb2*GK_C));\n"
"    real gf2 = 1 / (r2 + rb2*expterm);\n"
"\n"
"    real gf = SQRT(gf2);\n"
"    real gf3 = gf2*gf;\n"
"    real gf5 = gf3*gf2;\n"
"    real gf7 = gf5*gf2;\n"
"    real gf9 = gf7*gf2;\n"
"    real gf11 = gf9*gf2;\n"
"\n"
"    // reaction potential auxiliary terms;\n"
"\n"
"    real a00 = gf;\n"
"    real a10 = -gf3;\n"
"    real a20 = 3*gf5;\n"
"    real a30 = -15*gf7;\n"
"    real a40 = 105*gf9;\n"
"    real a50 = -945*gf11;\n"
"\n"
"    // Born radii derivatives of reaction potential auxiliary terms;\n"
"\n"
"    real b00 = dgfdr*a10;\n"
"    real b10 = dgfdr*a20;\n"
"    real b20 = dgfdr*a30;\n"
"    real b30 = dgfdr*a40;\n"
"    real b40 = dgfdr*a50;\n"
"\n"
"    // reaction potential gradient auxiliary terms;\n"
"\n"
"    real expc1 = 1 - expc;\n"
"    real a01 = expc1*a10;\n"
"    real a11 = expc1*a20;\n"
"    real a21 = expc1*a30;\n"
"    real a31 = expc1*a40;\n"
"    real a41 = expc1*a50;\n"
"\n"
"    // Born radii derivs of reaction potential gradient auxiliary terms;\n"
"\n"
"    real b01 = b10 - expcr*a10 - expc*b10;\n"
"    real b11 = b20 - expcr*a20 - expc*b20;\n"
"    real b21 = b30 - expcr*a30 - expc*b30;\n"
"    real b31 = b40 - expcr*a40 - expc*b40;\n"
"\n"
"    // 2nd reaction potential gradient auxiliary terms;\n"
"\n"
"    real expcdexpc = -expc*dexpc;\n"
"    real a02 = expc1*a11 + expcdexpc*a10;\n"
"    real a12 = expc1*a21 + expcdexpc*a20;\n"
"    real a22 = expc1*a31 + expcdexpc*a30;\n"
"    real a32 = expc1*a41 + expcdexpc*a40;\n"
"\n"
"    // Born radii derivatives of the 2nd reaction potential\n"
"    // gradient auxiliary terms\n"
"\n"
"     real b02 = b11 - (expcr*(a11 + dexpc*a10) + expc*(b11 + dexpcr*a10 + dexpc*b10));\n"
"     real b12 = b21 - (expcr*(a21 + dexpc*a20) + expc*(b21 + dexpcr*a20 + dexpc*b20));\n"
"     real b22 = b31 - (expcr*(a31 + dexpc*a30) + expc*(b31 + dexpcr*a30 + dexpc*b30));\n"
"\n"
"    // 3rd reaction potential gradient auxiliary terms\n"
"\n"
"    expcdexpc = 2*expcdexpc;\n"
"    real a03 = expc1*a12 + expcdexpc*a11;\n"
"    real a13 = expc1*a22 + expcdexpc*a21;\n"
"    real a23 = expc1*a32 + expcdexpc*a31;\n"
"\n"
"    expcdexpc = -expc*dexpc*dexpc;\n"
"    a03 = a03 + expcdexpc*a10;\n"
"    a13 = a13 + expcdexpc*a20;\n"
"    a23 = a23 + expcdexpc*a30;\n"
"\n"
"    // multiply the auxillary terms by their dieletric functions;\n"
"\n"
"    a00 *= fc;\n"
"    a01 *= fc;\n"
"    a02 *= fc;\n"
"    a03 *= fc;\n"
"\n"
"    b00 *= fc;\n"
"    b01 *= fc;\n"
"    b02 *= fc;\n"
"\n"
"    a10 *= fd;\n"
"    a11 *= fd;\n"
"    a12 *= fd;\n"
"    a13 *= fd;\n"
"\n"
"    b10 *= fd;\n"
"    b11 *= fd;\n"
"    b12 *= fd;\n"
"\n"
"    a20 *= fq;\n"
"    a21 *= fq;\n"
"    a22 *= fq;\n"
"    a23 *= fq;\n"
"\n"
"    b20 *= fq;\n"
"    b21 *= fq;\n"
"    b22 *= fq;\n"
"\n"
"    // unweighted reaction potential tensor\n"
"\n"
"#if defined F2\n"
"    real energy = -a10*atom2.q*(atom1.inducedDipole.x*xr + atom1.inducedDipole.y*yr + atom1.inducedDipole.z*zr);\n"
"    energy += a10*atom1.q*(atom2.inducedDipole.x*xr + atom2.inducedDipole.y*yr + atom2.inducedDipole.z*zr);\n"
"#endif\n"
"\n"
"#if defined F1\n"
"    real energy = 2*atom1.q*atom2.q*a00;\n"
"    energy += -a10*atom2.q*(atom1.dipole.x*xr + atom1.dipole.y*yr + atom1.dipole.z*zr);\n"
"    energy += a10*atom1.q*(atom2.dipole.x*xr + atom2.dipole.y*yr + atom2.dipole.z*zr);\n"
"    energy += a20*atom2.q*(atom1.quadrupoleXX*xr2 + atom1.quadrupoleYY*yr2 + atom1.quadrupoleZZ*zr2 + 2*(atom1.quadrupoleXY*xr*yr + atom1.quadrupoleXZ*xr*zr + atom1.quadrupoleYZ*yr*zr));\n"
"    energy += a20*atom1.q*(atom2.quadrupoleXX*xr2 + atom2.quadrupoleYY*yr2 + atom2.quadrupoleZZ*zr2 + 2*(atom2.quadrupoleXY*xr*yr + atom2.quadrupoleXZ*xr*zr + atom2.quadrupoleYZ*yr*zr));\n"
"#endif\n"
"\n"
"    // Born radii derivs of unweighted reaction potential tensor\n"
"\n"
"#if defined B1\n"
"    real dsumdrB1 = 2*(atom1.q*atom2.q*b00);\n"
"    dsumdrB1 -= b10*atom2.q*(atom1.dipole.x*xr + atom1.dipole.y*yr + atom1.dipole.z*zr);\n"
"    dsumdrB1 += b10*atom1.q*(atom2.dipole.x*xr + atom2.dipole.y*yr + atom2.dipole.z*zr);\n"
"#endif\n"
"#if defined B2\n"
"    real dsumdrB2 = -b10*atom2.q*(sxi*xr + syi*yr + szi*zr);\n"
"    dsumdrB2 += b10*atom1.q*(sxk*xr + syk*yr + szk*zr);\n"
"#endif\n"
"\n"
"#if defined B1\n"
"    real gqxx21 = xr*xr;\n"
"    real gqyy21 = yr*yr;\n"
"    real gqzz21 = zr*zr;\n"
"\n"
"    real gqxy21 = xr*yr;\n"
"    real gqxz21 = xr*zr;\n"
"    real gqyz21 = yr*zr;\n"
"    dsumdrB1 += b20*atom2.q*(atom1.quadrupoleXX*gqxx21 + atom1.quadrupoleYY*gqyy21 + atom1.quadrupoleZZ*gqzz21 + 2*(atom1.quadrupoleXY*gqxy21 + atom1.quadrupoleXZ*gqxz21 + atom1.quadrupoleYZ*gqyz21));\n"
"    dsumdrB1 += b20*atom1.q*(atom2.quadrupoleXX*gqxx21 + atom2.quadrupoleYY*gqyy21 + atom2.quadrupoleZZ*gqzz21 + 2*(atom2.quadrupoleXY*gqxy21 + atom2.quadrupoleXZ*gqxz21 + atom2.quadrupoleYZ*gqyz21));\n"
"#endif\n"
"\n"
"#if defined F1\n"
"    energy += a01*atom1.q*(atom2.dipole.x*xr + atom2.dipole.y*yr + atom2.dipole.z*zr);\n"
"    energy -= a01*atom2.q*(atom1.dipole.x*xr + atom1.dipole.y*yr + atom1.dipole.z*zr);\n"
"    real factor = a01*2*atom1.q*atom2.q;\n"
"    real dedx = factor*xr;\n"
"    real dedy = factor*yr;\n"
"    real dedz = factor*zr;\n"
"#endif\n"
"#if defined F2 \n"
"    energy += a01*atom1.q*(atom2.inducedDipole.x*xr + atom2.inducedDipole.y*yr + atom2.inducedDipole.z*zr);\n"
"    energy -= a01*atom2.q*(atom1.inducedDipole.x*xr + atom1.inducedDipole.y*yr + atom1.inducedDipole.z*zr);\n"
"#endif\n"
"\n"
"#if defined F1 || defined F2 || defined T1 || defined T2\n"
"    real gux2 = a10 + xr*xr*a11;\n"
"    real gux3 = xr*yr*a11;\n"
"    real gux4 = xr*zr*a11;\n"
"\n"
"    real guy3 = a10 + yr*yr*a11;\n"
"    real guy4 = yr*zr*a11;\n"
"    real guz4 = a10 + zr*zr*a11;\n"
"#if defined T1\n"
"    real guy2 = gux3;\n"
"    real guz2 = gux4;\n"
"    real guz3 = guy4;\n"
"#endif\n"
"#if defined T2\n"
"    real fid1 = sxk*gux2 + syk*gux3 + szk*gux4;\n"
"    real fid2 = sxk*gux3 + syk*guy3 + szk*guy4;\n"
"    real fid3 = sxk*gux4 + syk*guy4 + szk*guz4;\n"
"\n"
"    real trqi1 = atom1.dipole.y*fid3 - atom1.dipole.z*fid2;\n"
"    real trqi2 = atom1.dipole.z*fid1 - atom1.dipole.x*fid3;\n"
"    real trqi3 = atom1.dipole.x*fid2 - atom1.dipole.y*fid1;\n"
"#endif\n"
"\n"
"#if defined F1\n"
"    energy -= 2*(atom1.dipole.x*(atom2.dipole.x*gux2 + atom2.dipole.y*gux3 + atom2.dipole.z*gux4) +\n"
"                             atom1.dipole.y*(atom2.dipole.x*gux3 + atom2.dipole.y*guy3 + atom2.dipole.z*guy4) +\n"
"                             atom1.dipole.z*(atom2.dipole.x*gux4 + atom2.dipole.y*guy4 + atom2.dipole.z*guz4));\n"
"\n"
"    dedx -= atom2.q*(atom1.dipole.x*gux2 + atom1.dipole.y*gux3 + atom1.dipole.z*gux4);\n"
"    dedx += atom1.q*(atom2.dipole.x*gux2 + atom2.dipole.y*gux3 + atom2.dipole.z*gux4);\n"
"\n"
"    dedy -= atom2.q*(atom1.dipole.x*gux3 + atom1.dipole.y*guy3 + atom1.dipole.z*guy4);\n"
"    dedy += atom1.q*(atom2.dipole.x*gux3 + atom2.dipole.y*guy3 + atom2.dipole.z*guy4);\n"
"\n"
"    dedz -= atom2.q*(atom1.dipole.x*gux4 + atom1.dipole.y*guy4 + atom1.dipole.z*guz4);\n"
"    dedz += atom1.q*(atom2.dipole.x*gux4 + atom2.dipole.y*guy4 + atom2.dipole.z*guz4);\n"
"#endif\n"
"#if defined F2\n"
"    energy -= 2*(\n"
"                       atom1.dipole.x*(atom2.inducedDipole.x*gux2 + atom2.inducedDipole.y*gux3 + atom2.inducedDipole.z*gux4) + \n"
"                       atom1.dipole.y*(atom2.inducedDipole.x*gux3 + atom2.inducedDipole.y*guy3 + atom2.inducedDipole.z*guy4) + \n"
"                       atom1.dipole.z*(atom2.inducedDipole.x*gux4 + atom2.inducedDipole.y*guy4 + atom2.inducedDipole.z*guz4) + \n"
"                       atom2.dipole.x*(atom1.inducedDipole.x*gux2 + atom1.inducedDipole.y*gux3 + atom1.inducedDipole.z*gux4) + \n"
"                       atom2.dipole.y*(atom1.inducedDipole.x*gux3 + atom1.inducedDipole.y*guy3 + atom1.inducedDipole.z*guy4) + \n"
"                       atom2.dipole.z*(atom1.inducedDipole.x*gux4 + atom1.inducedDipole.y*guy4 + atom1.inducedDipole.z*guz4));\n"
"\n"
"    real dpdx = atom1.q*(sxk*gux2 + syk*gux3 + szk*gux4);\n"
"    dpdx -= atom2.q*(sxi*gux2 + syi*gux3 + szi*gux4);\n"
"\n"
"    real dpdy = atom1.q*(sxk*gux3 + syk*guy3 + szk*guy4);\n"
"    dpdy -= atom2.q*(sxi*gux3 + syi*guy3 + szi*guy4);\n"
"\n"
"    real dpdz = atom1.q*(sxk*gux4 + syk*guy4 + szk*guz4);\n"
"    dpdz -= atom2.q*(sxi*gux4 + syi*guy4 + szi*guz4);\n"
"\n"
"#endif\n"
"    real gqxx2 = xr*(2*a20 + xr*xr*a21);\n"
"    real gqxx3 = yr*xr*xr*a21;\n"
"    real gqxx4 = zr*xr*xr*a21;\n"
"    real gqyy2 = xr*yr*yr*a21;\n"
"    real gqyy3 = yr*(2*a20 + yr*yr*a21);\n"
"    real gqyy4 = zr*yr*yr*a21;\n"
"    real gqzz2 = xr*zr*zr*a21;\n"
"    real gqzz3 = yr*zr*zr*a21;\n"
"    real gqzz4 = zr*(2*a20 + zr*zr*a21);\n"
"    real gqxy2 = yr*(a20 + xr*xr*a21);\n"
"    real gqxy3 = xr*(a20 + yr*yr*a21);\n"
"    real gqxy4 = zr*xr*yr*a21;\n"
"    real gqxz2 = zr*(a20 + xr*xr*a21);\n"
"    real gqxz4 = xr*(a20 + zr*zr*a21);\n"
"    real gqyz3 = zr*(a20 + yr*yr*a21);\n"
"    real gqyz4 = yr*(a20 + zr*zr*a21);\n"
"#if defined T1 || defined T2\n"
"    real gqxz3 = gqxy4;\n"
"    real gqyz2 = gqxy4;\n"
"#endif\n"
"\n"
"#if defined F1\n"
"    energy += atom2.dipole.x*(atom1.quadrupoleXX*gqxx2 + atom1.quadrupoleYY*gqyy2 + atom1.quadrupoleZZ*gqzz2 + 2*(atom1.quadrupoleXY*gqxy2 + atom1.quadrupoleXZ*gqxz2 + atom1.quadrupoleYZ*gqxy4)) +\n"
"                       atom2.dipole.y*(atom1.quadrupoleXX*gqxx3 + atom1.quadrupoleYY*gqyy3 + atom1.quadrupoleZZ*gqzz3 + 2*(atom1.quadrupoleXY*gqxy3 + atom1.quadrupoleXZ*gqxy4 + atom1.quadrupoleYZ*gqyz3)) +\n"
"                       atom2.dipole.z*(atom1.quadrupoleXX*gqxx4 + atom1.quadrupoleYY*gqyy4 + atom1.quadrupoleZZ*gqzz4 + 2*(atom1.quadrupoleXY*gqxy4 + atom1.quadrupoleXZ*gqxz4 + atom1.quadrupoleYZ*gqyz4));\n"
"    energy -= atom1.dipole.x*(atom2.quadrupoleXX*gqxx2 + atom2.quadrupoleYY*gqyy2 + atom2.quadrupoleZZ*gqzz2 + 2*(atom2.quadrupoleXY*gqxy2 + atom2.quadrupoleXZ*gqxz2 + atom2.quadrupoleYZ*gqxy4)) +\n"
"                       atom1.dipole.y*(atom2.quadrupoleXX*gqxx3 + atom2.quadrupoleYY*gqyy3 + atom2.quadrupoleZZ*gqzz3 + 2*(atom2.quadrupoleXY*gqxy3 + atom2.quadrupoleXZ*gqxy4 + atom2.quadrupoleYZ*gqyz3)) +\n"
"                       atom1.dipole.z*(atom2.quadrupoleXX*gqxx4 + atom2.quadrupoleYY*gqyy4 + atom2.quadrupoleZZ*gqzz4 + 2*(atom2.quadrupoleXY*gqxy4 + atom2.quadrupoleXZ*gqxz4 + atom2.quadrupoleYZ*gqyz4));\n"
"\n"
"    dedx += atom2.q*(atom1.quadrupoleXX*gqxx2 + atom1.quadrupoleYY*gqyy2 + atom1.quadrupoleZZ*gqzz2 + 2*(atom1.quadrupoleXY*gqxy2 + atom1.quadrupoleXZ*gqxz2 + atom1.quadrupoleYZ*gqxy4));\n"
"    dedx += atom1.q*(atom2.quadrupoleXX*gqxx2 + atom2.quadrupoleYY*gqyy2 + atom2.quadrupoleZZ*gqzz2 + 2*(atom2.quadrupoleXY*gqxy2 + atom2.quadrupoleXZ*gqxz2 + atom2.quadrupoleYZ*gqxy4));\n"
"\n"
"    dedy += atom2.q*(atom1.quadrupoleXX*gqxx3 + atom1.quadrupoleYY*gqyy3 + atom1.quadrupoleZZ*gqzz3 + 2*(atom1.quadrupoleXY*gqxy3 + atom1.quadrupoleXZ*gqxy4 + atom1.quadrupoleYZ*gqyz3));\n"
"    dedy += atom1.q*(atom2.quadrupoleXX*gqxx3 + atom2.quadrupoleYY*gqyy3 + atom2.quadrupoleZZ*gqzz3 + 2*(atom2.quadrupoleXY*gqxy3 + atom2.quadrupoleXZ*gqxy4 + atom2.quadrupoleYZ*gqyz3));\n"
"\n"
"    dedz += atom2.q*(atom1.quadrupoleXX*gqxx4 + atom1.quadrupoleYY*gqyy4 + atom1.quadrupoleZZ*gqzz4 + 2*(atom1.quadrupoleXY*gqxy4 + atom1.quadrupoleXZ*gqxz4 + atom1.quadrupoleYZ*gqyz4));\n"
"    dedz += atom1.q*(atom2.quadrupoleXX*gqxx4 + atom2.quadrupoleYY*gqyy4 + atom2.quadrupoleZZ*gqzz4 + 2*(atom2.quadrupoleXY*gqxy4 + atom2.quadrupoleXZ*gqxz4 + atom2.quadrupoleYZ*gqyz4));\n"
"#endif\n"
"\n"
"#if defined F2\n"
"    energy += atom2.inducedDipole.x*(atom1.quadrupoleXX*gqxx2 + atom1.quadrupoleYY*gqyy2 + atom1.quadrupoleZZ*gqzz2 + 2*(atom1.quadrupoleXY*gqxy2 + atom1.quadrupoleXZ*gqxz2 + atom1.quadrupoleYZ*gqxy4)) +\n"
"              atom2.inducedDipole.y*(atom1.quadrupoleXX*gqxx3 + atom1.quadrupoleYY*gqyy3 + atom1.quadrupoleZZ*gqzz3 + 2*(atom1.quadrupoleXY*gqxy3 + atom1.quadrupoleXZ*gqxy4 + atom1.quadrupoleYZ*gqyz3)) +\n"
"              atom2.inducedDipole.z*(atom1.quadrupoleXX*gqxx4 + atom1.quadrupoleYY*gqyy4 + atom1.quadrupoleZZ*gqzz4 + 2*(atom1.quadrupoleXY*gqxy4 + atom1.quadrupoleXZ*gqxz4 + atom1.quadrupoleYZ*gqyz4));\n"
"\n"
"    energy -= atom1.inducedDipole.x*(atom2.quadrupoleXX*gqxx2 + atom2.quadrupoleYY*gqyy2 + atom2.quadrupoleZZ*gqzz2 + 2*(atom2.quadrupoleXY*gqxy2 + atom2.quadrupoleXZ*gqxz2 + atom2.quadrupoleYZ*gqxy4)) +\n"
"              atom1.inducedDipole.y*(atom2.quadrupoleXX*gqxx3 + atom2.quadrupoleYY*gqyy3 + atom2.quadrupoleZZ*gqzz3 + 2*(atom2.quadrupoleXY*gqxy3 + atom2.quadrupoleXZ*gqxy4 + atom2.quadrupoleYZ*gqyz3)) +\n"
"              atom1.inducedDipole.z*(atom2.quadrupoleXX*gqxx4 + atom2.quadrupoleYY*gqyy4 + atom2.quadrupoleZZ*gqzz4 + 2*(atom2.quadrupoleXY*gqxy4 + atom2.quadrupoleXZ*gqxz4 + atom2.quadrupoleYZ*gqyz4));\n"
"\n"
"#endif\n"
"#endif\n"
"\n"
"    // Born derivs of the unweighted reaction potential gradient tensor\n"
"\n"
"#if defined B1\n"
"    dsumdrB1 += b01*atom1.q*(atom2.dipole.x*xr + atom2.dipole.y*yr + atom2.dipole.z*zr);\n"
"    dsumdrB1 -= b01*atom2.q*(atom1.dipole.x*xr + atom1.dipole.y*yr + atom1.dipole.z*zr);\n"
"#endif\n"
"#if defined B2\n"
"    dsumdrB2 += b01*atom1.q*(sxk*xr+ syk*yr + szk*zr);\n"
"    dsumdrB2 -= b01*atom2.q*(sxi*xr+ syi*yr + szi*zr);\n"
"#endif\n"
"\n"
"#if defined B1 || defined B2\n"
"    real gux22 = b10 + xr2*b11;\n"
"    real gux23 = xr*yr*b11;\n"
"    real gux24 = xr*zr*b11;\n"
"    real guy22 = gux23;\n"
"    real guy23 = b10 + yr2*b11;\n"
"    real guy24 = yr*zr*b11;\n"
"    real guz22 = gux24;\n"
"    real guz23 = guy24;\n"
"    real guz24 = b10 + zr2*b11;\n"
"#if defined B1\n"
"    dsumdrB1 -= 2*(atom1.dipole.x*(atom2.dipole.x*gux22 + atom2.dipole.y*guy22 + atom2.dipole.z*guz22) +\n"
"                              atom1.dipole.y*(atom2.dipole.x*gux23 + atom2.dipole.y*guy23 + atom2.dipole.z*guz23) +\n"
"                              atom1.dipole.z*(atom2.dipole.x*gux24 + atom2.dipole.y*guy24 + atom2.dipole.z*guz24));\n"
"#endif\n"
"#if defined B2\n"
"    dsumdrB2 -= 2*(atom1.dipole.x*(sxk*gux22 + syk*guy22 + szk*guz22) +\n"
"                            atom1.dipole.y*(sxk*gux23 + syk*guy23 + szk*guz23) +\n"
"                            atom1.dipole.z*(sxk*gux24 + syk*guy24 + szk*guz24) +\n"
"                            atom2.dipole.x*(sxi*gux22 + syi*guy22 + szi*guz22) +\n"
"                            atom2.dipole.y*(sxi*gux23 + syi*guy23 + szi*guz23) +\n"
"                            atom2.dipole.z*(sxi*gux24 + syi*guy24 + szi*guz24));\n"
"\n"
"#ifndef DIRECT_POLARIZATION\n"
"    dsumdrB2 -= 2*(atom1.inducedDipole.x*(atom2.inducedDipolePolar.x*gux22 + atom2.inducedDipolePolar.y*gux23 + atom2.inducedDipolePolar.z*gux24)\n"
"                            + atom1.inducedDipole.y*(atom2.inducedDipolePolar.x*guy22 + atom2.inducedDipolePolar.y*guy23 + atom2.inducedDipolePolar.z*guy24)\n"
"                            + atom1.inducedDipole.z*(atom2.inducedDipolePolar.x*guz22 + atom2.inducedDipolePolar.y*guz23 + atom2.inducedDipolePolar.z*guz24)\n"
"                            + atom2.inducedDipole.x*(atom1.inducedDipolePolar.x*gux22 + atom1.inducedDipolePolar.y*gux23 + atom1.inducedDipolePolar.z*gux24)\n"
"                            + atom2.inducedDipole.y*(atom1.inducedDipolePolar.x*guy22 + atom1.inducedDipolePolar.y*guy23 + atom1.inducedDipolePolar.z*guy24)\n"
"                            + atom2.inducedDipole.z*(atom1.inducedDipolePolar.x*guz22 + atom1.inducedDipolePolar.y*guz23 + atom1.inducedDipolePolar.z*guz24));\n"
"#endif\n"
"#endif\n"
"    real gqxx22 = xr*(2*b20 + xr2*b21);\n"
"    real gqxx23 = yr*xr2*b21;\n"
"    real gqxx24 = zr*xr2*b21;\n"
"    real gqyy22 = xr*yr2*b21;\n"
"    real gqyy23 = yr*(2*b20 + yr2*b21);\n"
"    real gqyy24 = zr*yr2*b21;\n"
"    real gqzz22 = xr*zr2*b21;\n"
"    real gqzz23 = yr*zr2*b21;\n"
"    real gqzz24 = zr*(2*b20 + zr2*b21);\n"
"    real gqxy22 = yr*(b20 + xr2*b21);\n"
"    real gqxy23 = xr*(b20 + yr2*b21);\n"
"    real gqxy24 = zr*xr*yr*b21;\n"
"    real gqxz22 = zr*(b20 + xr2*b21);\n"
"    real gqxz23 = gqxy24;\n"
"    real gqxz24 = xr*(b20 + zr2*b21);\n"
"    real gqyz22 = gqxy24;\n"
"    real gqyz23 = zr*(b20 + yr2*b21);\n"
"    real gqyz24 = yr*(b20 + zr2*b21);\n"
"#if defined B1\n"
"    dsumdrB1 += atom2.dipole.x*(atom1.quadrupoleXX*gqxx22 + atom1.quadrupoleYY*gqyy22 + atom1.quadrupoleZZ*gqzz22 + 2*(atom1.quadrupoleXY*gqxy22 + atom1.quadrupoleXZ*gqxz22 + atom1.quadrupoleYZ*gqyz22)) +\n"
"                atom2.dipole.y*(atom1.quadrupoleXX*gqxx23 + atom1.quadrupoleYY*gqyy23 + atom1.quadrupoleZZ*gqzz23 + 2*(atom1.quadrupoleXY*gqxy23 + atom1.quadrupoleXZ*gqxz23 + atom1.quadrupoleYZ*gqyz23)) +\n"
"                atom2.dipole.z*(atom1.quadrupoleXX*gqxx24 + atom1.quadrupoleYY*gqyy24 + atom1.quadrupoleZZ*gqzz24 + 2*(atom1.quadrupoleXY*gqxy24 + atom1.quadrupoleXZ*gqxz24 + atom1.quadrupoleYZ*gqyz24));\n"
"    dsumdrB1 -= atom1.dipole.x*(atom2.quadrupoleXX*gqxx22 + atom2.quadrupoleYY*gqyy22 + atom2.quadrupoleZZ*gqzz22 + 2*(atom2.quadrupoleXY*gqxy22 + atom2.quadrupoleXZ*gqxz22 + atom2.quadrupoleYZ*gqyz22)) +\n"
"                atom1.dipole.y*(atom2.quadrupoleXX*gqxx23 + atom2.quadrupoleYY*gqyy23 + atom2.quadrupoleZZ*gqzz23 + 2*(atom2.quadrupoleXY*gqxy23 + atom2.quadrupoleXZ*gqxz23 + atom2.quadrupoleYZ*gqyz23)) +\n"
"                atom1.dipole.z*(atom2.quadrupoleXX*gqxx24 + atom2.quadrupoleYY*gqyy24 + atom2.quadrupoleZZ*gqzz24 + 2*(atom2.quadrupoleXY*gqxy24 + atom2.quadrupoleXZ*gqxz24 + atom2.quadrupoleYZ*gqyz24));\n"
"#endif\n"
"#if defined B2\n"
"\n"
"    dsumdrB2 += sxk*(atom1.quadrupoleXX*gqxx22 + atom1.quadrupoleYY*gqyy22 + atom1.quadrupoleZZ*gqzz22 + 2*(atom1.quadrupoleXY*gqxy22 + atom1.quadrupoleXZ*gqxz22 + atom1.quadrupoleYZ*gqyz22)) +\n"
"                syk*(atom1.quadrupoleXX*gqxx23 + atom1.quadrupoleYY*gqyy23 + atom1.quadrupoleZZ*gqzz23 + 2*(atom1.quadrupoleXY*gqxy23 + atom1.quadrupoleXZ*gqxz23 + atom1.quadrupoleYZ*gqyz23)) +\n"
"                szk*(atom1.quadrupoleXX*gqxx24 + atom1.quadrupoleYY*gqyy24 + atom1.quadrupoleZZ*gqzz24 + 2*(atom1.quadrupoleXY*gqxy24 + atom1.quadrupoleXZ*gqxz24 + atom1.quadrupoleYZ*gqyz24));\n"
"    dsumdrB2 -= sxi*(atom2.quadrupoleXX*gqxx22 + atom2.quadrupoleYY*gqyy22 + atom2.quadrupoleZZ*gqzz22 + 2*(atom2.quadrupoleXY*gqxy22 + atom2.quadrupoleXZ*gqxz22 + atom2.quadrupoleYZ*gqyz22)) +\n"
"                syi*(atom2.quadrupoleXX*gqxx23 + atom2.quadrupoleYY*gqyy23 + atom2.quadrupoleZZ*gqzz23 + 2*(atom2.quadrupoleXY*gqxy23 + atom2.quadrupoleXZ*gqxz23 + atom2.quadrupoleYZ*gqyz23)) +\n"
"                szi*(atom2.quadrupoleXX*gqxx24 + atom2.quadrupoleYY*gqyy24 + atom2.quadrupoleZZ*gqzz24 + 2*(atom2.quadrupoleXY*gqxy24 + atom2.quadrupoleXZ*gqxz24 + atom2.quadrupoleYZ*gqyz24));\n"
"\n"
"#endif\n"
"#endif\n"
"\n"
"    // unweighted 2nd reaction potential gradient tensor;\n"
"\n"
"#if defined F1 || defined F2 || defined T1\n"
"    real gc5 = a01 + xr2*a02;\n"
"    real gc6 = xr*yr*a02;\n"
"    real gc7 = xr*zr*a02;\n"
"    real gc8 = a01 + yr2*a02;\n"
"    real gc9 = yr*zr*a02;\n"
"    real gc10 = a01 + zr2*a02;\n"
"#if defined F1\n"
"    energy += atom1.q*(atom2.quadrupoleXX*gc5 + atom2.quadrupoleYY*gc8 + atom2.quadrupoleZZ*gc10 + 2*(atom2.quadrupoleXY*gc6 + atom2.quadrupoleXZ*gc7 + atom2.quadrupoleYZ*gc9));\n"
"    energy += atom2.q*(atom1.quadrupoleXX*gc5 + atom1.quadrupoleYY*gc8 + atom1.quadrupoleZZ*gc10 + 2*(atom1.quadrupoleXY*gc6 + atom1.quadrupoleXZ*gc7 + atom1.quadrupoleYZ*gc9));\n"
"\n"
"    dedx += atom1.q*(atom2.dipole.x*gc5 + atom2.dipole.y*gc6 + atom2.dipole.z*gc7);\n"
"    dedx -= atom2.q*(atom1.dipole.x*gc5 + atom1.dipole.y*gc6 + atom1.dipole.z*gc7);\n"
"\n"
"    dedy += atom1.q*(atom2.dipole.x*gc6 + atom2.dipole.y*gc8 + atom2.dipole.z*gc9);\n"
"    dedy -= atom2.q*(atom1.dipole.x*gc6 + atom1.dipole.y*gc8 + atom1.dipole.z*gc9);\n"
"\n"
"    dedz += atom1.q*(atom2.dipole.x*gc7 + atom2.dipole.y*gc9 + atom2.dipole.z*gc10);\n"
"    dedz -= atom2.q*(atom1.dipole.x*gc7 + atom1.dipole.y*gc9 + atom1.dipole.z*gc10);\n"
"#endif\n"
"\n"
"#if defined F2\n"
"    dpdx += atom1.q*(sxk*gc5 + syk*gc6 + szk*gc7);\n"
"    dpdx -= atom2.q*(sxi*gc5 + syi*gc6 + szi*gc7);\n"
"    dpdy += atom1.q*(sxk*gc6 + syk*gc8 + szk*gc9);\n"
"    dpdy -= atom2.q*(sxi*gc6 + syi*gc8 + szi*gc9);\n"
"    dpdz += atom1.q*(sxk*gc7 + syk*gc9 + szk*gc10);\n"
"    dpdz -= atom2.q*(sxi*gc7 + syi*gc9 + szi*gc10);\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#if defined F1 || defined F2 || defined T1 || defined T2\n"
"    real gux5 = xr*(3*a11 + xr2*a12);\n"
"    real gux6 = yr*(a11 + xr2*a12);\n"
"    real gux7 = zr*(a11 + xr2*a12);\n"
"    real gux8 = xr*(a11 + yr2*a12);\n"
"    real gux9 = zr*xr*yr*a12;\n"
"    real gux10 = xr*(a11 + zr2*a12);\n"
"    real guy5 = yr*(a11 + xr2*a12);\n"
"    real guy6 = xr*(a11 + yr2*a12);\n"
"    real guy7 = gux9;\n"
"    real guy8 = yr*(3*a11 + yr2*a12);\n"
"    real guy9 = zr*(a11 + yr2*a12);\n"
"    real guy10 = yr*(a11 + zr2*a12);\n"
"    real guz5 = zr*(a11 + xr2*a12);\n"
"    real guz6 = gux9;\n"
"    real guz7 = xr*(a11 + zr2*a12);\n"
"    real guz8 = zr*(a11 + yr2*a12);\n"
"    real guz9 = yr*(a11 + zr2*a12);\n"
"    real guz10 = zr*(3*a11 + zr2*a12);\n"
"#if defined F1\n"
"    energy -= atom1.dipole.x*(atom2.quadrupoleXX*gux5 + atom2.quadrupoleYY*gux8 + atom2.quadrupoleZZ*gux10 + 2*(atom2.quadrupoleXY*gux6 + atom2.quadrupoleXZ*gux7 + atom2.quadrupoleYZ*gux9)) +\n"
"                       atom1.dipole.y*(atom2.quadrupoleXX*guy5 + atom2.quadrupoleYY*guy8 + atom2.quadrupoleZZ*guy10 + 2*(atom2.quadrupoleXY*guy6 + atom2.quadrupoleXZ*guy7 + atom2.quadrupoleYZ*guy9)) +\n"
"                       atom1.dipole.z*(atom2.quadrupoleXX*guz5 + atom2.quadrupoleYY*guz8 + atom2.quadrupoleZZ*guz10 + 2*(atom2.quadrupoleXY*guz6 + atom2.quadrupoleXZ*guz7 + atom2.quadrupoleYZ*guz9));\n"
"\n"
"    energy += atom2.dipole.x*(atom1.quadrupoleXX*gux5 + atom1.quadrupoleYY*gux8 + atom1.quadrupoleZZ*gux10 + 2*(atom1.quadrupoleXY*gux6 + atom1.quadrupoleXZ*gux7 + atom1.quadrupoleYZ*gux9)) +\n"
"                       atom2.dipole.y*(atom1.quadrupoleXX*guy5 + atom1.quadrupoleYY*guy8 + atom1.quadrupoleZZ*guy10 + 2*(atom1.quadrupoleXY*guy6 + atom1.quadrupoleXZ*guy7 + atom1.quadrupoleYZ*guy9)) +\n"
"                       atom2.dipole.z*(atom1.quadrupoleXX*guz5 + atom1.quadrupoleYY*guz8 + atom1.quadrupoleZZ*guz10 + 2*(atom1.quadrupoleXY*guz6 + atom1.quadrupoleXZ*guz7 + atom1.quadrupoleYZ*guz9));\n"
"\n"
"    dedx -= 2*(atom1.dipole.x*(atom2.dipole.x*gux5 + atom2.dipole.y*guy5 + atom2.dipole.z*guz5) +\n"
"                              atom1.dipole.y*(atom2.dipole.x*gux6 + atom2.dipole.y*guy6 + atom2.dipole.z*guz6) +\n"
"                              atom1.dipole.z*(atom2.dipole.x*gux7 + atom2.dipole.y*guy7 + atom2.dipole.z*guz7));\n"
"\n"
"    dedy -= 2*(atom1.dipole.x*(atom2.dipole.x*gux6 + atom2.dipole.y*guy6 + atom2.dipole.z*guz6) +\n"
"                              atom1.dipole.y*(atom2.dipole.x*gux8 + atom2.dipole.y*guy8 + atom2.dipole.z*guz8) +\n"
"                              atom1.dipole.z*(atom2.dipole.x*gux9 + atom2.dipole.y*guy9 + atom2.dipole.z*guz9));\n"
"\n"
"    dedz -= 2*(atom1.dipole.x*(atom2.dipole.x*gux7 + atom2.dipole.y*guy7 + atom2.dipole.z*guz7) +\n"
"                              atom1.dipole.y*(atom2.dipole.x*gux9 + atom2.dipole.y*guy9 + atom2.dipole.z*guz9) +\n"
"                              atom1.dipole.z*(atom2.dipole.x*gux10 + atom2.dipole.y*guy10 + atom2.dipole.z*guz10));\n"
"\n"
"#endif\n"
"\n"
"#if defined F2\n"
"    energy -= atom1.inducedDipole.x*(atom2.quadrupoleXX*gux5 + atom2.quadrupoleYY*gux8 + atom2.quadrupoleZZ*gux10 + 2*(atom2.quadrupoleXY*gux6 + atom2.quadrupoleXZ*gux7 + atom2.quadrupoleYZ*gux9)) +\n"
"              atom1.inducedDipole.y*(atom2.quadrupoleXX*guy5 + atom2.quadrupoleYY*guy8 + atom2.quadrupoleZZ*guy10 + 2*(atom2.quadrupoleXY*guy6 + atom2.quadrupoleXZ*guy7 + atom2.quadrupoleYZ*guy9)) +\n"
"              atom1.inducedDipole.z*(atom2.quadrupoleXX*guz5 + atom2.quadrupoleYY*guz8 + atom2.quadrupoleZZ*guz10 + 2*(atom2.quadrupoleXY*guz6 + atom2.quadrupoleXZ*guz7 + atom2.quadrupoleYZ*guz9));\n"
"\n"
"    energy += atom2.inducedDipole.x*(atom1.quadrupoleXX*gux5 + atom1.quadrupoleYY*gux8 + atom1.quadrupoleZZ*gux10 + 2*(atom1.quadrupoleXY*gux6 + atom1.quadrupoleXZ*gux7 + atom1.quadrupoleYZ*gux9)) +\n"
"              atom2.inducedDipole.y*(atom1.quadrupoleXX*guy5 + atom1.quadrupoleYY*guy8 + atom1.quadrupoleZZ*guy10 + 2*(atom1.quadrupoleXY*guy6 + atom1.quadrupoleXZ*guy7 + atom1.quadrupoleYZ*guy9)) +\n"
"              atom2.inducedDipole.z*(atom1.quadrupoleXX*guz5 + atom1.quadrupoleYY*guz8 + atom1.quadrupoleZZ*guz10 + 2*(atom1.quadrupoleXY*guz6 + atom1.quadrupoleXZ*guz7 + atom1.quadrupoleYZ*guz9));\n"
"\n"
"    dpdx -= 2*(atom1.dipole.x*(sxk*gux5 + syk*guy5 + szk*guz5) + atom1.dipole.y*(sxk*gux6 + syk*guy6 + szk*guz6) + atom1.dipole.z*(sxk*gux7 + syk*guy7 + szk*guz7) +\n"
"                    atom2.dipole.x*(sxi*gux5 + syi*guy5 + szi*guz5) + atom2.dipole.y*(sxi*gux6 + syi*guy6 + szi*guz6) + atom2.dipole.z*(sxi*gux7 + syi*guy7 + szi*guz7));\n"
"\n"
"    dpdy -= 2*(atom1.dipole.x*(sxk*gux6 + syk*guy6 + szk*guz6) + atom1.dipole.y*(sxk*gux8 + syk*guy8 + szk*guz8) + atom1.dipole.z*(sxk*gux9 + syk*guy9 + szk*guz9) +\n"
"                    atom2.dipole.x*(sxi*gux6 + syi*guy6 + szi*guz6) + atom2.dipole.y*(sxi*gux8 + syi*guy8 + szi*guz8) + atom2.dipole.z*(sxi*gux9 + syi*guy9 + szi*guz9));\n"
"\n"
"    dpdz -= 2*(atom1.dipole.x*(sxk*gux7 + syk*guy7 + szk*guz7) + atom1.dipole.y*(sxk*gux9 + syk*guy9 + szk*guz9) + atom1.dipole.z*(sxk*gux10 + syk*guy10 + szk*guz10) +\n"
"                    atom2.dipole.x*(sxi*gux7 + syi*guy7 + szi*guz7) + atom2.dipole.y*(sxi*gux9 + syi*guy9 + szi*guz9) + atom2.dipole.z*(sxi*gux10 + syi*guy10 + szi*guz10));\n"
"\n"
"#ifndef DIRECT_POLARIZATION\n"
"        dpdx -= 2*(atom1.inducedDipole.x*(atom2.inducedDipolePolar.x*gux5 + atom2.inducedDipolePolar.y*gux6 + atom2.inducedDipolePolar.z*gux7)\n"
"                            + atom1.inducedDipole.y*(atom2.inducedDipolePolar.x*guy5 + atom2.inducedDipolePolar.y*guy6 + atom2.inducedDipolePolar.z*guy7)\n"
"                            + atom1.inducedDipole.z*(atom2.inducedDipolePolar.x*guz5 + atom2.inducedDipolePolar.y*guz6 + atom2.inducedDipolePolar.z*guz7)\n"
"                            + atom2.inducedDipole.x*(atom1.inducedDipolePolar.x*gux5 + atom1.inducedDipolePolar.y*gux6 + atom1.inducedDipolePolar.z*gux7)\n"
"                            + atom2.inducedDipole.y*(atom1.inducedDipolePolar.x*guy5 + atom1.inducedDipolePolar.y*guy6 + atom1.inducedDipolePolar.z*guy7)\n"
"                            + atom2.inducedDipole.z*(atom1.inducedDipolePolar.x*guz5 + atom1.inducedDipolePolar.y*guz6 + atom1.inducedDipolePolar.z*guz7));\n"
"\n"
"        dpdy -= 2*(atom1.inducedDipole.x*(atom2.inducedDipolePolar.x*gux6 + atom2.inducedDipolePolar.y*gux8 + atom2.inducedDipolePolar.z*gux9)\n"
"                            + atom1.inducedDipole.y*(atom2.inducedDipolePolar.x*guy6 + atom2.inducedDipolePolar.y*guy8 + atom2.inducedDipolePolar.z*guy9)\n"
"                            + atom1.inducedDipole.z*(atom2.inducedDipolePolar.x*guz6 + atom2.inducedDipolePolar.y*guz8 + atom2.inducedDipolePolar.z*guz9)\n"
"                            + atom2.inducedDipole.x*(atom1.inducedDipolePolar.x*gux6 + atom1.inducedDipolePolar.y*gux8 + atom1.inducedDipolePolar.z*gux9)\n"
"                            + atom2.inducedDipole.y*(atom1.inducedDipolePolar.x*guy6 + atom1.inducedDipolePolar.y*guy8 + atom1.inducedDipolePolar.z*guy9)\n"
"                            + atom2.inducedDipole.z*(atom1.inducedDipolePolar.x*guz6 + atom1.inducedDipolePolar.y*guz8 + atom1.inducedDipolePolar.z*guz9));\n"
"\n"
"        dpdz -= 2*(atom1.inducedDipole.x*(atom2.inducedDipolePolar.x*gux7 + atom2.inducedDipolePolar.y*gux9 + atom2.inducedDipolePolar.z*gux10)\n"
"                            + atom1.inducedDipole.y*(atom2.inducedDipolePolar.x*guy7 + atom2.inducedDipolePolar.y*guy9 + atom2.inducedDipolePolar.z*guy10)\n"
"                            + atom1.inducedDipole.z*(atom2.inducedDipolePolar.x*guz7 + atom2.inducedDipolePolar.y*guz9 + atom2.inducedDipolePolar.z*guz10)\n"
"                            + atom2.inducedDipole.x*(atom1.inducedDipolePolar.x*gux7 + atom1.inducedDipolePolar.y*gux9 + atom1.inducedDipolePolar.z*gux10)\n"
"                            + atom2.inducedDipole.y*(atom1.inducedDipolePolar.x*guy7 + atom1.inducedDipolePolar.y*guy9 + atom1.inducedDipolePolar.z*guy10)\n"
"                            + atom2.inducedDipole.z*(atom1.inducedDipolePolar.x*guz7 + atom1.inducedDipolePolar.y*guz9 + atom1.inducedDipolePolar.z*guz10));\n"
"#endif\n"
"#endif\n"
"#endif\n"
"";
const string CommonAmoebaKernelSources::gkPairForce2 = "\n"
"#if defined F1 || defined F2 || defined T1\n"
"    real gqxx5 = 2*a20 + xr2*(5*a21 + xr2*a22);\n"
"    real gqxx6 = yr*xr*(2*a21 + xr2*a22);\n"
"    real gqxx7 = zr*xr*(2*a21 + xr2*a22);\n"
"    real gqxx8 = xr2*(a21 + yr2*a22);\n"
"    real gqxx9 = zr*yr*xr2*a22;\n"
"    real gqxx10 = xr2*(a21 + zr2*a22);\n"
"    real gqyy5 = yr2*(a21 + xr2*a22);\n"
"    real gqyy6 = xr*yr*(2*a21 + yr2*a22);\n"
"    real gqyy7 = xr*zr*yr2*a22;\n"
"    real gqyy8 = 2*a20 + yr2*(5*a21 + yr2*a22);\n"
"    real gqyy9 = yr*zr*(2*a21 + yr2*a22);\n"
"    real gqyy10 = yr2*(a21 + zr2*a22);\n"
"    real gqzz5 = zr2*(a21 + xr2*a22);\n"
"    real gqzz6 = xr*yr*zr2*a22;\n"
"    real gqzz7 = xr*zr*(2*a21 + zr2*a22);\n"
"    real gqzz8 = zr2*(a21 + yr2*a22);\n"
"    real gqzz9 = yr*zr*(2*a21 + zr2*a22);\n"
"    real gqzz10 = 2*a20 + zr2*(5*a21 + zr2*a22);\n"
"    real gqxy5 = xr*yr*(3*a21 + xr2*a22);\n"
"    real gqxy6 = a20 + (xr2 + yr2)*a21 + xr2*yr2*a22;\n"
"    real gqxy7 = zr*yr*(a21 + xr2*a22);\n"
"    real gqxy8 = xr*yr*(3*a21 + yr2*a22);\n"
"    real gqxy9 = zr*xr*(a21 + yr2*a22);\n"
"    real gqxy10 = xr*yr*(a21 + zr2*a22);\n"
"    real gqxz5 = xr*zr*(3*a21 + xr2*a22);\n"
"    real gqxz6 = yr*zr*(a21 + xr2*a22);\n"
"    real gqxz7 = a20 + (xr2 + zr2)*a21 + xr2*zr2*a22;\n"
"    real gqxz8 = xr*zr*(a21 + yr2*a22);\n"
"    real gqxz9 = xr*yr*(a21 + zr2*a22);\n"
"    real gqxz10 = xr*zr*(3*a21 + zr2*a22);\n"
"    real gqyz5 = zr*yr*(a21 + xr2*a22);\n"
"    real gqyz6 = xr*zr*(a21 + yr2*a22);\n"
"    real gqyz7 = xr*yr*(a21 + zr2*a22);\n"
"    real gqyz8 = yr*zr*(3*a21 + yr2*a22);\n"
"    real gqyz9 = a20 + (yr2 + zr2)*a21 + yr2*zr2*a22;\n"
"    real gqyz10 = yr*zr*(3*a21 + zr2*a22);\n"
"#if defined F1\n"
"    energy += atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqxx8 + atom2.quadrupoleZZ*gqxx10 + 2*(atom2.quadrupoleXY*gqxx6 + atom2.quadrupoleXZ*gqxx7 + atom2.quadrupoleYZ*gqxx9))\n"
"              + atom1.quadrupoleYY*(atom2.quadrupoleXX*gqyy5 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqyy10 + 2*(atom2.quadrupoleXY*gqyy6 + atom2.quadrupoleXZ*gqyy7 + atom2.quadrupoleYZ*gqyy9))\n"
"              + atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqzz5 + atom2.quadrupoleYY*gqzz8 + atom2.quadrupoleZZ*gqzz10 + 2*(atom2.quadrupoleXY*gqzz6 + atom2.quadrupoleXZ*gqzz7 + atom2.quadrupoleYZ*gqzz9))\n"
"              + 2*(atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxy5 + atom2.quadrupoleYY*gqxy8 + atom2.quadrupoleZZ*gqxy10\n"
"              + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxy7 + atom2.quadrupoleYZ*gqxy9))\n"
"              + atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxz5 + atom2.quadrupoleYY*gqxz8 + atom2.quadrupoleZZ*gqxz10\n"
"              + 2*(atom2.quadrupoleXY*gqxz6 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqxz9))\n"
"              + atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqyz5 + atom2.quadrupoleYY*gqyz8 + atom2.quadrupoleZZ*gqyz10\n"
"              + 2*(atom2.quadrupoleXY*gqyz6 + atom2.quadrupoleXZ*gqyz7 + atom2.quadrupoleYZ*gqyz9)));\n"
"\n"
"    energy += atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqyy5 + atom2.quadrupoleZZ*gqzz5 + 2*(atom2.quadrupoleXY*gqxy5 + atom2.quadrupoleXZ*gqxz5 + atom2.quadrupoleYZ*gqyz5))\n"
"             + atom1.quadrupoleYY*(atom2.quadrupoleXX*gqxx8 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqzz8\n"
"             + 2*(atom2.quadrupoleXY*gqxy8 + atom2.quadrupoleXZ*gqxz8 + atom2.quadrupoleYZ*gqyz8))\n"
"             + atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqxx10 + atom2.quadrupoleYY*gqyy10 + atom2.quadrupoleZZ*gqzz10\n"
"             + 2*(atom2.quadrupoleXY*gqxy10 + atom2.quadrupoleXZ*gqxz10 + atom2.quadrupoleYZ*gqyz10))\n"
"             + 2*(atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6\n"
"             + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6))\n"
"             + atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7\n"
"             + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7))\n"
"             + atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9\n"
"             + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9)));\n"
"\n"
"    dedx += atom2.dipole.x*(atom1.quadrupoleXX*gqxx5 + atom1.quadrupoleYY*gqyy5 + atom1.quadrupoleZZ*gqzz5 + 2*(atom1.quadrupoleXY*gqxy5 + atom1.quadrupoleXZ*gqxz5 + atom1.quadrupoleYZ*gqyz5)) +\n"
"              atom2.dipole.y*(atom1.quadrupoleXX*gqxx6 + atom1.quadrupoleYY*gqyy6 + atom1.quadrupoleZZ*gqzz6 + 2*(atom1.quadrupoleXY*gqxy6 + atom1.quadrupoleXZ*gqxz6 + atom1.quadrupoleYZ*gqyz6)) +\n"
"              atom2.dipole.z*(atom1.quadrupoleXX*gqxx7 + atom1.quadrupoleYY*gqyy7 + atom1.quadrupoleZZ*gqzz7 + 2*(atom1.quadrupoleXY*gqxy7 + atom1.quadrupoleXZ*gqxz7 + atom1.quadrupoleYZ*gqyz7));\n"
"\n"
"    dedx -= atom1.dipole.x*(atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqyy5 + atom2.quadrupoleZZ*gqzz5 + 2*(atom2.quadrupoleXY*gqxy5 + atom2.quadrupoleXZ*gqxz5 + atom2.quadrupoleYZ*gqyz5)) +\n"
"              atom1.dipole.y*(atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6 + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6)) +\n"
"              atom1.dipole.z*(atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7 + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7));\n"
"\n"
"    dedy += atom2.dipole.x*(atom1.quadrupoleXX*gqxx6 + atom1.quadrupoleYY*gqyy6 + atom1.quadrupoleZZ*gqzz6 + 2*(atom1.quadrupoleXY*gqxy6 + atom1.quadrupoleXZ*gqxz6 + atom1.quadrupoleYZ*gqyz6)) +\n"
"              atom2.dipole.y*(atom1.quadrupoleXX*gqxx8 + atom1.quadrupoleYY*gqyy8 + atom1.quadrupoleZZ*gqzz8 + 2*(atom1.quadrupoleXY*gqxy8 + atom1.quadrupoleXZ*gqxz8 + atom1.quadrupoleYZ*gqyz8)) +\n"
"              atom2.dipole.z*(atom1.quadrupoleXX*gqxx9 + atom1.quadrupoleYY*gqyy9 + atom1.quadrupoleZZ*gqzz9 + 2*(atom1.quadrupoleXY*gqxy9 + atom1.quadrupoleXZ*gqxz9 + atom1.quadrupoleYZ*gqyz9));\n"
"\n"
"    dedy -= atom1.dipole.x*(atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6 + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6)) +\n"
"              atom1.dipole.y*(atom2.quadrupoleXX*gqxx8 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqzz8 + 2*(atom2.quadrupoleXY*gqxy8 + atom2.quadrupoleXZ*gqxz8 + atom2.quadrupoleYZ*gqyz8)) +\n"
"              atom1.dipole.z*(atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9 + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9));\n"
"\n"
"    dedz += atom2.dipole.x*(atom1.quadrupoleXX*gqxx7 + atom1.quadrupoleYY*gqyy7 + atom1.quadrupoleZZ*gqzz7 + 2*(atom1.quadrupoleXY*gqxy7 + atom1.quadrupoleXZ*gqxz7 + atom1.quadrupoleYZ*gqyz7)) +\n"
"              atom2.dipole.y*(atom1.quadrupoleXX*gqxx9 + atom1.quadrupoleYY*gqyy9 + atom1.quadrupoleZZ*gqzz9 + 2*(atom1.quadrupoleXY*gqxy9 + atom1.quadrupoleXZ*gqxz9 + atom1.quadrupoleYZ*gqyz9)) +\n"
"              atom2.dipole.z*(atom1.quadrupoleXX*gqxx10 + atom1.quadrupoleYY*gqyy10 + atom1.quadrupoleZZ*gqzz10 + 2*(atom1.quadrupoleXY*gqxy10 + atom1.quadrupoleXZ*gqxz10 + atom1.quadrupoleYZ*gqyz10));\n"
"\n"
"    dedz -= atom1.dipole.x*(atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7 + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7)) +\n"
"              atom1.dipole.y*(atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9 + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9)) +\n"
"              atom1.dipole.z*(atom2.quadrupoleXX*gqxx10 + atom2.quadrupoleYY*gqyy10 + atom2.quadrupoleZZ*gqzz10 + 2*(atom2.quadrupoleXY*gqxy10 + atom2.quadrupoleXZ*gqxz10 + atom2.quadrupoleYZ*gqyz10));\n"
"#endif\n"
"#if defined F2\n"
"    dpdx += sxk*(atom1.quadrupoleXX*gqxx5 + atom1.quadrupoleYY*gqyy5 + atom1.quadrupoleZZ*gqzz5 + 2*(atom1.quadrupoleXY*gqxy5 + atom1.quadrupoleXZ*gqxz5 + atom1.quadrupoleYZ*gqyz5)) +\n"
"            syk*(atom1.quadrupoleXX*gqxx6 + atom1.quadrupoleYY*gqyy6 + atom1.quadrupoleZZ*gqzz6 + 2*(atom1.quadrupoleXY*gqxy6 + atom1.quadrupoleXZ*gqxz6 + atom1.quadrupoleYZ*gqyz6)) +\n"
"            szk*(atom1.quadrupoleXX*gqxx7 + atom1.quadrupoleYY*gqyy7 + atom1.quadrupoleZZ*gqzz7 + 2*(atom1.quadrupoleXY*gqxy7 + atom1.quadrupoleXZ*gqxz7 + atom1.quadrupoleYZ*gqyz7));\n"
"\n"
"    dpdx -= sxi*(atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqyy5 + atom2.quadrupoleZZ*gqzz5 + 2*(atom2.quadrupoleXY*gqxy5 + atom2.quadrupoleXZ*gqxz5 + atom2.quadrupoleYZ*gqyz5)) +\n"
"            syi*(atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6 + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6)) +\n"
"            szi*(atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7 + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7));\n"
"\n"
"    dpdy += sxk*(atom1.quadrupoleXX*gqxx6 + atom1.quadrupoleYY*gqyy6 + atom1.quadrupoleZZ*gqzz6 + 2*(atom1.quadrupoleXY*gqxy6 + atom1.quadrupoleXZ*gqxz6 + atom1.quadrupoleYZ*gqyz6)) +\n"
"            syk*(atom1.quadrupoleXX*gqxx8 + atom1.quadrupoleYY*gqyy8 + atom1.quadrupoleZZ*gqzz8 + 2*(atom1.quadrupoleXY*gqxy8 + atom1.quadrupoleXZ*gqxz8 + atom1.quadrupoleYZ*gqyz8)) +\n"
"            szk*(atom1.quadrupoleXX*gqxx9 + atom1.quadrupoleYY*gqyy9 + atom1.quadrupoleZZ*gqzz9 + 2*(atom1.quadrupoleXY*gqxy9 + atom1.quadrupoleXZ*gqxz9 + atom1.quadrupoleYZ*gqyz9));\n"
"\n"
"    dpdy -= sxi*(atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6 + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6)) +\n"
"            syi*(atom2.quadrupoleXX*gqxx8 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqzz8 + 2*(atom2.quadrupoleXY*gqxy8 + atom2.quadrupoleXZ*gqxz8 + atom2.quadrupoleYZ*gqyz8)) +\n"
"            szi*(atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9 + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9));\n"
"\n"
"    dpdz -= sxi*(atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7 + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7)) +\n"
"            syi*(atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9 + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9)) +\n"
"            szi*(atom2.quadrupoleXX*gqxx10 + atom2.quadrupoleYY*gqyy10 + atom2.quadrupoleZZ*gqzz10 + 2*(atom2.quadrupoleXY*gqxy10 + atom2.quadrupoleXZ*gqxz10 + atom2.quadrupoleYZ*gqyz10));\n"
"\n"
"    dpdz += sxk*(atom1.quadrupoleXX*gqxx7 + atom1.quadrupoleYY*gqyy7 + atom1.quadrupoleZZ*gqzz7 + 2*(atom1.quadrupoleXY*gqxy7 + atom1.quadrupoleXZ*gqxz7 + atom1.quadrupoleYZ*gqyz7)) +\n"
"            syk*(atom1.quadrupoleXX*gqxx9 + atom1.quadrupoleYY*gqyy9 + atom1.quadrupoleZZ*gqzz9 + 2*(atom1.quadrupoleXY*gqxy9 + atom1.quadrupoleXZ*gqxz9 + atom1.quadrupoleYZ*gqyz9)) +\n"
"            szk*(atom1.quadrupoleXX*gqxx10 + atom1.quadrupoleYY*gqyy10 + atom1.quadrupoleZZ*gqzz10 + 2*(atom1.quadrupoleXY*gqxy10 + atom1.quadrupoleXZ*gqxz10 + atom1.quadrupoleYZ*gqyz10));\n"
"#endif\n"
"#endif\n"
"\n"
"    // Born radii derivatives of the unweighted 2nd reaction;\n"
"    // potential gradient tensor;\n"
"\n"
"#if defined B1\n"
"    real gc25 = b01 + xr2*b02;\n"
"    real gc26 = xr*yr*b02;\n"
"    real gc27 = xr*zr*b02;\n"
"    real gc28 = b01 + yr2*b02;\n"
"    real gc29 = yr*zr*b02;\n"
"    real gc30 = b01 + zr2*b02;\n"
"    dsumdrB1 += atom1.q*(atom2.quadrupoleXX*gc25 + atom2.quadrupoleYY*gc28 + atom2.quadrupoleZZ*gc30 + 2*(atom2.quadrupoleXY*gc26 + atom2.quadrupoleXZ*gc27 + atom2.quadrupoleYZ*gc29));\n"
"    dsumdrB1 += atom2.q*(atom1.quadrupoleXX*gc25 + atom1.quadrupoleYY*gc28 + atom1.quadrupoleZZ*gc30 + 2*(atom1.quadrupoleXY*gc26 + atom1.quadrupoleXZ*gc27 + atom1.quadrupoleYZ*gc29));\n"
"#endif\n"
"#if defined B1 || defined B2\n"
"    real gux25 = xr*(3*b11 + xr2*b12);\n"
"    real gux26 = yr*(b11 + xr2*b12);\n"
"    real gux27 = zr*(b11 + xr2*b12);\n"
"    real gux28 = xr*(b11 + yr2*b12);\n"
"    real gux29 = zr*xr*yr*b12;\n"
"    real gux30 = xr*(b11 + zr2*b12);\n"
"    real guy25 = yr*(b11 + xr2*b12);\n"
"    real guy26 = xr*(b11 + yr2*b12);\n"
"    real guy27 = gux29;\n"
"    real guy28 = yr*(3*b11 + yr2*b12);\n"
"    real guy29 = zr*(b11 + yr2*b12);\n"
"    real guy30 = yr*(b11 + zr2*b12);\n"
"    real guz25 = zr*(b11 + xr2*b12);\n"
"    real guz26 = gux29;\n"
"    real guz27 = xr*(b11 + zr2*b12);\n"
"    real guz28 = zr*(b11 + yr2*b12);\n"
"    real guz29 = yr*(b11 + zr2*b12);\n"
"    real guz30 = zr*(3*b11 + zr2*b12);\n"
"#endif\n"
"#if defined B2\n"
"    dsumdrB2 -= sxi*(atom2.quadrupoleXX*gux25 + atom2.quadrupoleYY*gux28 + atom2.quadrupoleZZ*gux30 + 2*(atom2.quadrupoleXY*gux26 + atom2.quadrupoleXZ*gux27 + atom2.quadrupoleYZ*gux29)) +\n"
"                syi*(atom2.quadrupoleXX*guy25 + atom2.quadrupoleYY*guy28 + atom2.quadrupoleZZ*guy30 + 2*(atom2.quadrupoleXY*guy26 + atom2.quadrupoleXZ*guy27 + atom2.quadrupoleYZ*guy29)) +\n"
"                szi*(atom2.quadrupoleXX*guz25 + atom2.quadrupoleYY*guz28 + atom2.quadrupoleZZ*guz30 + 2*(atom2.quadrupoleXY*guz26 + atom2.quadrupoleXZ*guz27 + atom2.quadrupoleYZ*guz29));\n"
"    dsumdrB2 += sxk*(atom1.quadrupoleXX*gux25 + atom1.quadrupoleYY*gux28 + atom1.quadrupoleZZ*gux30 + 2*(atom1.quadrupoleXY*gux26 + atom1.quadrupoleXZ*gux27 + atom1.quadrupoleYZ*gux29)) +\n"
"                syk*(atom1.quadrupoleXX*guy25 + atom1.quadrupoleYY*guy28 + atom1.quadrupoleZZ*guy30 + 2*(atom1.quadrupoleXY*guy26 + atom1.quadrupoleXZ*guy27 + atom1.quadrupoleYZ*guy29)) +\n"
"                szk*(atom1.quadrupoleXX*guz25 + atom1.quadrupoleYY*guz28 + atom1.quadrupoleZZ*guz30 + 2*(atom1.quadrupoleXY*guz26 + atom1.quadrupoleXZ*guz27 + atom1.quadrupoleYZ*guz29));\n"
"#endif\n"
"#if defined B1\n"
"    dsumdrB1 -= atom1.dipole.x*(atom2.quadrupoleXX*gux25 + atom2.quadrupoleYY*gux28 + atom2.quadrupoleZZ*gux30 + 2*(atom2.quadrupoleXY*gux26 + atom2.quadrupoleXZ*gux27 + atom2.quadrupoleYZ*gux29)) +\n"
"                atom1.dipole.y*(atom2.quadrupoleXX*guy25 + atom2.quadrupoleYY*guy28 + atom2.quadrupoleZZ*guy30 + 2*(atom2.quadrupoleXY*guy26 + atom2.quadrupoleXZ*guy27 + atom2.quadrupoleYZ*guy29)) +\n"
"                atom1.dipole.z*(atom2.quadrupoleXX*guz25 + atom2.quadrupoleYY*guz28 + atom2.quadrupoleZZ*guz30 + 2*(atom2.quadrupoleXY*guz26 + atom2.quadrupoleXZ*guz27 + atom2.quadrupoleYZ*guz29));\n"
"    dsumdrB1 += atom2.dipole.x*(atom1.quadrupoleXX*gux25 + atom1.quadrupoleYY*gux28 + atom1.quadrupoleZZ*gux30 + 2*(atom1.quadrupoleXY*gux26 + atom1.quadrupoleXZ*gux27 + atom1.quadrupoleYZ*gux29)) +\n"
"                atom2.dipole.y*(atom1.quadrupoleXX*guy25 + atom1.quadrupoleYY*guy28 + atom1.quadrupoleZZ*guy30 + 2*(atom1.quadrupoleXY*guy26 + atom1.quadrupoleXZ*guy27 + atom1.quadrupoleYZ*guy29)) +\n"
"                atom2.dipole.z*(atom1.quadrupoleXX*guz25 + atom1.quadrupoleYY*guz28 + atom1.quadrupoleZZ*guz30 + 2*(atom1.quadrupoleXY*guz26 + atom1.quadrupoleXZ*guz27 + atom1.quadrupoleYZ*guz29));\n"
"\n"
"    real gqxx25 = 2*b20 + xr2*(5*b21 + xr2*b22);\n"
"    real gqxx26 = yr*xr*(2*b21 + xr2*b22);\n"
"    real gqxx27 = zr*xr*(2*b21 + xr2*b22);\n"
"    real gqxx28 = xr2*(b21 + yr2*b22);\n"
"    real gqxx29 = zr*yr*xr2*b22;\n"
"    real gqxx30 = xr2*(b21 + zr2*b22);\n"
"    real gqyy25 = yr2*(b21 + xr2*b22);\n"
"    real gqyy26 = xr*yr*(2*b21 + yr2*b22);\n"
"    real gqyy27 = xr*zr*yr2*b22;\n"
"    real gqyy28 = 2*b20 + yr2*(5*b21 + yr2*b22);\n"
"    real gqyy29 = yr*zr*(2*b21 + yr2*b22);\n"
"    real gqyy30 = yr2*(b21 + zr2*b22);\n"
"    real gqzz25 = zr2*(b21 + xr2*b22);\n"
"    real gqzz26 = xr*yr*zr2*b22;\n"
"    real gqzz27 = xr*zr*(2*b21 + zr2*b22);\n"
"    real gqzz28 = zr2*(b21 + yr2*b22);\n"
"    real gqzz29 = yr*zr*(2*b21 + zr2*b22);\n"
"    real gqzz30 = 2*b20 + zr2*(5*b21 + zr2*b22);\n"
"    real gqxy25 = xr*yr*(3*b21 + xr2*b22);\n"
"    real gqxy26 = b20 + (xr2 + yr2)*b21 + xr2*yr2*b22;\n"
"    real gqxy27 = zr*yr*(b21 + xr2*b22);\n"
"    real gqxy28 = xr*yr*(3*b21 + yr2*b22);\n"
"    real gqxy29 = zr*xr*(b21 + yr2*b22);\n"
"    real gqxy30 = xr*yr*(b21 + zr2*b22);\n"
"    real gqxz25 = xr*zr*(3*b21 + xr2*b22);\n"
"    real gqxz26 = yr*zr*(b21 + xr2*b22);\n"
"    real gqxz27 = b20 + (xr2 + zr2)*b21 + xr2*zr2*b22;\n"
"    real gqxz28 = xr*zr*(b21 + yr2*b22);\n"
"    real gqxz29 = xr*yr*(b21 + zr2*b22);\n"
"    real gqxz30 = xr*zr*(3*b21 + zr2*b22);\n"
"    real gqyz25 = zr*yr*(b21 + xr2*b22);\n"
"    real gqyz26 = xr*zr*(b21 + yr2*b22);\n"
"    real gqyz27 = xr*yr*(b21 + zr2*b22);\n"
"    real gqyz28 = yr*zr*(3*b21 + yr2*b22);\n"
"    real gqyz29 = b20 + (yr2 + zr2)*b21 + yr2*zr2*b22;\n"
"    real gqyz30 = yr*zr*(3*b21 + zr2*b22);\n"
"\n"
"    dsumdrB1 +=\n"
"        atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx25 + atom2.quadrupoleYY*gqxx28 + atom2.quadrupoleZZ*gqxx30 + 2*(atom2.quadrupoleXY*gqxx26 + atom2.quadrupoleXZ*gqxx27 + atom2.quadrupoleYZ*gqxx29)) +\n"
"        atom1.quadrupoleYY*(atom2.quadrupoleXX*gqyy25 + atom2.quadrupoleYY*gqyy28 + atom2.quadrupoleZZ*gqyy30 + 2*(atom2.quadrupoleXY*gqyy26 + atom2.quadrupoleXZ*gqyy27 + atom2.quadrupoleYZ*gqyy29)) +\n"
"        atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqzz25 + atom2.quadrupoleYY*gqzz28 + atom2.quadrupoleZZ*gqzz30 + 2*(atom2.quadrupoleXY*gqzz26 + atom2.quadrupoleXZ*gqzz27 + atom2.quadrupoleYZ*gqzz29));\n"
"\n"
"    dsumdrB1 += 2*(\n"
"        atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxy25 + atom2.quadrupoleYY*gqxy28 + atom2.quadrupoleZZ*gqxy30 + 2*(atom2.quadrupoleXY*gqxy26 + atom2.quadrupoleXZ*gqxy27 + atom2.quadrupoleYZ*gqxy29)) +\n"
"        atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxz25 + atom2.quadrupoleYY*gqxz28 + atom2.quadrupoleZZ*gqxz30 + 2*(atom2.quadrupoleXY*gqxz26 + atom2.quadrupoleXZ*gqxz27 + atom2.quadrupoleYZ*gqxz29)) +\n"
"        atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqyz25 + atom2.quadrupoleYY*gqyz28 + atom2.quadrupoleZZ*gqyz30 + 2*(atom2.quadrupoleXY*gqyz26 + atom2.quadrupoleXZ*gqyz27 + atom2.quadrupoleYZ*gqyz29)));\n"
"\n"
"    dsumdrB1 +=\n"
"        atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx25 + atom2.quadrupoleYY*gqyy25 + atom2.quadrupoleZZ*gqzz25 + 2*(atom2.quadrupoleXY*gqxy25 + atom2.quadrupoleXZ*gqxz25 + atom2.quadrupoleYZ*gqyz25)) +\n"
"        atom1.quadrupoleYY*(atom2.quadrupoleXX*gqxx28 + atom2.quadrupoleYY*gqyy28 + atom2.quadrupoleZZ*gqzz28 + 2*(atom2.quadrupoleXY*gqxy28 + atom2.quadrupoleXZ*gqxz28 + atom2.quadrupoleYZ*gqyz28)) +\n"
"        atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqxx30 + atom2.quadrupoleYY*gqyy30 + atom2.quadrupoleZZ*gqzz30 + 2*(atom2.quadrupoleXY*gqxy30 + atom2.quadrupoleXZ*gqxz30 + atom2.quadrupoleYZ*gqyz30));\n"
"\n"
"    dsumdrB1 += 2*(\n"
"        atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxx26 + atom2.quadrupoleYY*gqyy26 + atom2.quadrupoleZZ*gqzz26 + 2*(atom2.quadrupoleXY*gqxy26 + atom2.quadrupoleXZ*gqxz26 + atom2.quadrupoleYZ*gqyz26)) +\n"
"        atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxx27 + atom2.quadrupoleYY*gqyy27 + atom2.quadrupoleZZ*gqzz27 + 2*(atom2.quadrupoleXY*gqxy27 + atom2.quadrupoleXZ*gqxz27 + atom2.quadrupoleYZ*gqyz27)) +\n"
"        atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqxx29 + atom2.quadrupoleYY*gqyy29 + atom2.quadrupoleZZ*gqzz29 + 2*(atom2.quadrupoleXY*gqxy29 + atom2.quadrupoleXZ*gqxz29 + atom2.quadrupoleYZ*gqyz29)));\n"
"\n"
"    dsumdrB1 *= 0.5f;\n"
"    *bornForce1 += atom2.bornRadius*dsumdrB1;\n"
"    *bornForce2 += atom1.bornRadius*dsumdrB1;\n"
"#endif\n"
"\n"
"    // unweighted 3rd reaction potential gradient tensor;\n"
"\n"
"#if defined F1\n"
"    real gc11 = xr*(3*a02 + xr2*a03);\n"
"    real gc12 = yr*(a02 + xr2*a03);\n"
"    real gc13 = zr*(a02 + xr2*a03);\n"
"    real gc14 = xr*(a02 + yr2*a03);\n"
"    real gc15 = xr*yr*zr*a03;\n"
"    real gc16 = xr*(a02 + zr2*a03);\n"
"    real gc17 = yr*(3*a02 + yr2*a03);\n"
"    real gc18 = zr*(a02 + yr2*a03);\n"
"    real gc19 = yr*(a02 + zr2*a03);\n"
"    real gc20 = zr*(3*a02 + zr2*a03);\n"
"    dedx += atom1.q*(atom2.quadrupoleXX*gc11 + atom2.quadrupoleYY*gc14 + atom2.quadrupoleZZ*gc16 + 2*(atom2.quadrupoleXY*gc12 + atom2.quadrupoleXZ*gc13 + atom2.quadrupoleYZ*gc15));\n"
"    dedx += atom2.q*(atom1.quadrupoleXX*gc11 + atom1.quadrupoleYY*gc14 + atom1.quadrupoleZZ*gc16 + 2*(atom1.quadrupoleXY*gc12 + atom1.quadrupoleXZ*gc13 + atom1.quadrupoleYZ*gc15));\n"
"    dedy += atom1.q*(atom2.quadrupoleXX*gc12 + atom2.quadrupoleYY*gc17 + atom2.quadrupoleZZ*gc19 + 2*(atom2.quadrupoleXY*gc14 + atom2.quadrupoleXZ*gc15 + atom2.quadrupoleYZ*gc18));\n"
"    dedy += atom2.q*(atom1.quadrupoleXX*gc12 + atom1.quadrupoleYY*gc17 + atom1.quadrupoleZZ*gc19 + 2*(atom1.quadrupoleXY*gc14 + atom1.quadrupoleXZ*gc15 + atom1.quadrupoleYZ*gc18));\n"
"    dedz += atom1.q*(atom2.quadrupoleXX*gc13 + atom2.quadrupoleYY*gc18 + atom2.quadrupoleZZ*gc20 + 2*(atom2.quadrupoleXY*gc15 + atom2.quadrupoleXZ*gc16 + atom2.quadrupoleYZ*gc19));\n"
"    dedz += atom2.q*(atom1.quadrupoleXX*gc13 + atom1.quadrupoleYY*gc18 + atom1.quadrupoleZZ*gc20 + 2*(atom1.quadrupoleXY*gc15 + atom1.quadrupoleXZ*gc16 + atom1.quadrupoleYZ*gc19));\n"
"#endif\n"
"#if defined F1 || defined F2\n"
"    real gux11 = 3*a11 + xr2*(6*a12 + xr2*a13);\n"
"    real gux12 = xr*yr*(3*a12 + xr2*a13);\n"
"    real gux13 = xr*zr*(3*a12 + xr2*a13);\n"
"    real gux14 = a11 + (xr2 + yr2)*a12 + xr2*yr2*a13;\n"
"    real gux15 = yr*zr*(a12 + xr2*a13);\n"
"    real gux16 = a11 + (xr2 + zr2)*a12 + xr2*zr2*a13;\n"
"    real gux17 = xr*yr*(3*a12 + yr2*a13);\n"
"    real gux18 = xr*zr*(a12 + yr2*a13);\n"
"    real gux19 = xr*yr*(a12 + zr2*a13);\n"
"    real gux20 = xr*zr*(3*a12 + zr2*a13);\n"
"    real guy11 = gux12;\n"
"    real guy12 = gux14;\n"
"    real guy13 = gux15;\n"
"    real guy14 = gux17;\n"
"    real guy15 = gux18;\n"
"    real guy16 = gux19;\n"
"    real guy17 = 3*a11 + yr2*(6*a12 + yr2*a13);\n"
"    real guy18 = yr*zr*(3*a12 + yr2*a13);\n"
"    real guy19 = a11 + (yr2 + zr2)*a12 + yr2*zr2*a13;\n"
"    real guy20 = yr*zr*(3*a12 + zr2*a13);\n"
"    real guz11 = gux13;\n"
"    real guz12 = gux15;\n"
"    real guz13 = gux16;\n"
"    real guz14 = gux18;\n"
"    real guz15 = gux19;\n"
"    real guz16 = gux20;\n"
"    real guz17 = guy18;\n"
"    real guz18 = guy19;\n"
"    real guz19 = guy20;\n"
"    real guz20 = 3*a11 + zr2*(6*a12 + zr2*a13);\n"
"#if defined F1\n"
"    dedx -= atom1.dipole.x*(atom2.quadrupoleXX*gux11 + atom2.quadrupoleYY*gux14 + atom2.quadrupoleZZ*gux16 + 2*(atom2.quadrupoleXY*gux12 + atom2.quadrupoleXZ*gux13 + atom2.quadrupoleYZ*gux15)) +\n"
"                       atom1.dipole.y*(atom2.quadrupoleXX*guy11 + atom2.quadrupoleYY*guy14 + atom2.quadrupoleZZ*guy16 + 2*(atom2.quadrupoleXY*guy12 + atom2.quadrupoleXZ*guy13 + atom2.quadrupoleYZ*guy15)) +\n"
"                       atom1.dipole.z*(atom2.quadrupoleXX*guz11 + atom2.quadrupoleYY*guz14 + atom2.quadrupoleZZ*guz16 + 2*(atom2.quadrupoleXY*guz12 + atom2.quadrupoleXZ*guz13 + atom2.quadrupoleYZ*guz15));\n"
"\n"
"    dedx += atom2.dipole.x*(atom1.quadrupoleXX*gux11 + atom1.quadrupoleYY*gux14 + atom1.quadrupoleZZ*gux16 + 2*(atom1.quadrupoleXY*gux12 + atom1.quadrupoleXZ*gux13 + atom1.quadrupoleYZ*gux15)) +\n"
"                       atom2.dipole.y*(atom1.quadrupoleXX*guy11 + atom1.quadrupoleYY*guy14 + atom1.quadrupoleZZ*guy16 + 2*(atom1.quadrupoleXY*guy12 + atom1.quadrupoleXZ*guy13 + atom1.quadrupoleYZ*guy15)) +\n"
"                       atom2.dipole.z*(atom1.quadrupoleXX*guz11 + atom1.quadrupoleYY*guz14 + atom1.quadrupoleZZ*guz16 + 2*(atom1.quadrupoleXY*guz12 + atom1.quadrupoleXZ*guz13 + atom1.quadrupoleYZ*guz15));\n"
"\n"
"    dedy -= atom1.dipole.x*(atom2.quadrupoleXX*gux12 + atom2.quadrupoleYY*gux17 + atom2.quadrupoleZZ*gux19 + 2*(atom2.quadrupoleXY*gux14 + atom2.quadrupoleXZ*gux15 + atom2.quadrupoleYZ*gux18)) +\n"
"                       atom1.dipole.y*(atom2.quadrupoleXX*guy12 + atom2.quadrupoleYY*guy17 + atom2.quadrupoleZZ*guy19 + 2*(atom2.quadrupoleXY*guy14 + atom2.quadrupoleXZ*guy15 + atom2.quadrupoleYZ*guy18)) +\n"
"                       atom1.dipole.z*(atom2.quadrupoleXX*guz12 + atom2.quadrupoleYY*guz17 + atom2.quadrupoleZZ*guz19 + 2*(atom2.quadrupoleXY*guz14 + atom2.quadrupoleXZ*guz15 + atom2.quadrupoleYZ*guz18));\n"
"\n"
"    dedy += atom2.dipole.x*(atom1.quadrupoleXX*gux12 + atom1.quadrupoleYY*gux17 + atom1.quadrupoleZZ*gux19 + 2*(atom1.quadrupoleXY*gux14 + atom1.quadrupoleXZ*gux15 + atom1.quadrupoleYZ*gux18)) +\n"
"                       atom2.dipole.y*(atom1.quadrupoleXX*guy12 + atom1.quadrupoleYY*guy17 + atom1.quadrupoleZZ*guy19 + 2*(atom1.quadrupoleXY*guy14 + atom1.quadrupoleXZ*guy15 + atom1.quadrupoleYZ*guy18)) +\n"
"                       atom2.dipole.z*(atom1.quadrupoleXX*guz12 + atom1.quadrupoleYY*guz17 + atom1.quadrupoleZZ*guz19 + 2*(atom1.quadrupoleXY*guz14 + atom1.quadrupoleXZ*guz15 + atom1.quadrupoleYZ*guz18));\n"
"\n"
"    dedz -= atom1.dipole.x*(atom2.quadrupoleXX*gux13 + atom2.quadrupoleYY*gux18 + atom2.quadrupoleZZ*gux20 + 2*(atom2.quadrupoleXY*gux15 + atom2.quadrupoleXZ*gux16 + atom2.quadrupoleYZ*gux19)) +\n"
"                       atom1.dipole.y*(atom2.quadrupoleXX*guy13 + atom2.quadrupoleYY*guy18 + atom2.quadrupoleZZ*guy20 + 2*(atom2.quadrupoleXY*guy15 + atom2.quadrupoleXZ*guy16 + atom2.quadrupoleYZ*guy19)) +\n"
"                       atom1.dipole.z*(atom2.quadrupoleXX*guz13 + atom2.quadrupoleYY*guz18 + atom2.quadrupoleZZ*guz20 + 2*(atom2.quadrupoleXY*guz15 + atom2.quadrupoleXZ*guz16 + atom2.quadrupoleYZ*guz19));\n"
"\n"
"    dedz += atom2.dipole.x*(atom1.quadrupoleXX*gux13 + atom1.quadrupoleYY*gux18 + atom1.quadrupoleZZ*gux20 + 2*(atom1.quadrupoleXY*gux15 + atom1.quadrupoleXZ*gux16 + atom1.quadrupoleYZ*gux19)) +\n"
"                       atom2.dipole.y*(atom1.quadrupoleXX*guy13 + atom1.quadrupoleYY*guy18 + atom1.quadrupoleZZ*guy20 + 2*(atom1.quadrupoleXY*guy15 + atom1.quadrupoleXZ*guy16 + atom1.quadrupoleYZ*guy19)) +\n"
"                       atom2.dipole.z*(atom1.quadrupoleXX*guz13 + atom1.quadrupoleYY*guz18 + atom1.quadrupoleZZ*guz20 + 2*(atom1.quadrupoleXY*guz15 + atom1.quadrupoleXZ*guz16 + atom1.quadrupoleYZ*guz19));\n"
"#endif\n"
"#if defined F2\n"
"    dpdx -= sxi*(atom2.quadrupoleXX*gux11 + atom2.quadrupoleYY*gux14 + atom2.quadrupoleZZ*gux16 + 2*(atom2.quadrupoleXY*gux12 + atom2.quadrupoleXZ*gux13 + atom2.quadrupoleYZ*gux15)) +\n"
"            syi*(atom2.quadrupoleXX*guy11 + atom2.quadrupoleYY*guy14 + atom2.quadrupoleZZ*guy16 + 2*(atom2.quadrupoleXY*guy12 + atom2.quadrupoleXZ*guy13 + atom2.quadrupoleYZ*guy15)) +\n"
"            szi*(atom2.quadrupoleXX*guz11 + atom2.quadrupoleYY*guz14 + atom2.quadrupoleZZ*guz16 + 2*(atom2.quadrupoleXY*guz12 + atom2.quadrupoleXZ*guz13 + atom2.quadrupoleYZ*guz15));\n"
"\n"
"    dpdx += sxk*(atom1.quadrupoleXX*gux11 + atom1.quadrupoleYY*gux14 + atom1.quadrupoleZZ*gux16 + 2*(atom1.quadrupoleXY*gux12 + atom1.quadrupoleXZ*gux13 + atom1.quadrupoleYZ*gux15)) +\n"
"            syk*(atom1.quadrupoleXX*guy11 + atom1.quadrupoleYY*guy14 + atom1.quadrupoleZZ*guy16 + 2*(atom1.quadrupoleXY*guy12 + atom1.quadrupoleXZ*guy13 + atom1.quadrupoleYZ*guy15)) +\n"
"            szk*(atom1.quadrupoleXX*guz11 + atom1.quadrupoleYY*guz14 + atom1.quadrupoleZZ*guz16 + 2*(atom1.quadrupoleXY*guz12 + atom1.quadrupoleXZ*guz13 + atom1.quadrupoleYZ*guz15));\n"
"\n"
"    dpdy -= sxi*(atom2.quadrupoleXX*gux12 + atom2.quadrupoleYY*gux17 + atom2.quadrupoleZZ*gux19 + 2*(atom2.quadrupoleXY*gux14 + atom2.quadrupoleXZ*gux15 + atom2.quadrupoleYZ*gux18)) +\n"
"            syi*(atom2.quadrupoleXX*guy12 + atom2.quadrupoleYY*guy17 + atom2.quadrupoleZZ*guy19 + 2*(atom2.quadrupoleXY*guy14 + atom2.quadrupoleXZ*guy15 + atom2.quadrupoleYZ*guy18)) +\n"
"            szi*(atom2.quadrupoleXX*guz12 + atom2.quadrupoleYY*guz17 + atom2.quadrupoleZZ*guz19 + 2*(atom2.quadrupoleXY*guz14 + atom2.quadrupoleXZ*guz15 + atom2.quadrupoleYZ*guz18));\n"
"\n"
"    dpdy += sxk*(atom1.quadrupoleXX*gux12 + atom1.quadrupoleYY*gux17 + atom1.quadrupoleZZ*gux19 + 2*(atom1.quadrupoleXY*gux14 + atom1.quadrupoleXZ*gux15 + atom1.quadrupoleYZ*gux18)) +\n"
"            syk*(atom1.quadrupoleXX*guy12 + atom1.quadrupoleYY*guy17 + atom1.quadrupoleZZ*guy19 + 2*(atom1.quadrupoleXY*guy14 + atom1.quadrupoleXZ*guy15 + atom1.quadrupoleYZ*guy18)) +\n"
"            szk*(atom1.quadrupoleXX*guz12 + atom1.quadrupoleYY*guz17 + atom1.quadrupoleZZ*guz19 + 2*(atom1.quadrupoleXY*guz14 + atom1.quadrupoleXZ*guz15 + atom1.quadrupoleYZ*guz18));\n"
"\n"
"    dpdz -= sxi*(atom2.quadrupoleXX*gux13 + atom2.quadrupoleYY*gux18 + atom2.quadrupoleZZ*gux20 + 2*(atom2.quadrupoleXY*gux15 + atom2.quadrupoleXZ*gux16 + atom2.quadrupoleYZ*gux19)) +\n"
"            syi*(atom2.quadrupoleXX*guy13 + atom2.quadrupoleYY*guy18 + atom2.quadrupoleZZ*guy20 + 2*(atom2.quadrupoleXY*guy15 + atom2.quadrupoleXZ*guy16 + atom2.quadrupoleYZ*guy19)) +\n"
"            szi*(atom2.quadrupoleXX*guz13 + atom2.quadrupoleYY*guz18 + atom2.quadrupoleZZ*guz20 + 2*(atom2.quadrupoleXY*guz15 + atom2.quadrupoleXZ*guz16 + atom2.quadrupoleYZ*guz19));\n"
"\n"
"    dpdz += sxk*(atom1.quadrupoleXX*gux13 + atom1.quadrupoleYY*gux18 + atom1.quadrupoleZZ*gux20 + 2*(atom1.quadrupoleXY*gux15 + atom1.quadrupoleXZ*gux16 + atom1.quadrupoleYZ*gux19)) +\n"
"            syk*(atom1.quadrupoleXX*guy13 + atom1.quadrupoleYY*guy18 + atom1.quadrupoleZZ*guy20 + 2*(atom1.quadrupoleXY*guy15 + atom1.quadrupoleXZ*guy16 + atom1.quadrupoleYZ*guy19)) +\n"
"            szk*(atom1.quadrupoleXX*guz13 + atom1.quadrupoleYY*guz18 + atom1.quadrupoleZZ*guz20 + 2*(atom1.quadrupoleXY*guz15 + atom1.quadrupoleXZ*guz16 + atom1.quadrupoleYZ*guz19));\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#if defined F1\n"
"    real gqxx11 = xr*(12*a21 + xr2*(9*a22 + xr2*a23));\n"
"    real gqxx12 = yr*(2*a21 + xr2*(5*a22 + xr2*a23));\n"
"    real gqxx13 = zr*(2*a21 + xr2*(5*a22 + xr2*a23));\n"
"    real gqxx14 = xr*(2*a21 + yr2*2*a22 + xr2*(a22 + yr2*a23));\n"
"    real gqxx15 = xr*yr*zr*(2*a22 + xr2*a23);\n"
"    real gqxx16 = xr*(2*a21 + zr2*2*a22 + xr2*(a22 + zr2*a23));\n"
"    real gqxx17 = yr*xr2*(3*a22 + yr2*a23);\n"
"    real gqxx18 = zr*xr2*(a22 + yr2*a23);\n"
"    real gqxx19 = yr*xr2*(a22 + zr2*a23);\n"
"    real gqxx20 = zr*xr2*(3*a22 + zr2*a23);\n"
"\n"
"    real gqxy11 = yr*(3*a21 + xr2*(6*a22 + xr2*a23));\n"
"    real gqxy12 = xr*(3*(a21 + yr2*a22) + xr2*(a22 + yr2*a23));\n"
"\n"
"    real gqxy13 = xr*yr*zr*(3*a22 + xr2*a23);\n"
"\n"
"    real gqxy14 = yr*(3*(a21 + xr2*a22) + yr2*(a22 + xr2*a23));\n"
"    real gqxy15 = zr*(a21 + (yr2 + xr2)*a22 + yr2*xr2*a23);\n"
"    real gqxy16 = yr*(a21 + (xr2 + zr2)*a22 + xr2*zr2*a23);\n"
"    real gqxy17 = xr*(3*(a21 + yr2*a22) + yr2*(3*a22 + yr2*a23));\n"
"    real gqxy18 = xr*yr*zr*(3*a22 + yr2*a23);\n"
"    real gqxy19 = xr*(a21 + (yr2 + zr2)*a22 + yr2*zr2*a23);\n"
"    real gqxy20 = xr*yr*zr*(3*a22 + zr2*a23);\n"
"    real gqxz11 = zr*(3*a21 + xr2*(6*a22 + xr2*a23));\n"
"\n"
"    real gqxz12 = xr*yr*zr*(3*a22 + xr2*a23);\n"
"\n"
"    real gqxz13 = xr*(3*(a21 + zr2*a22) + xr2*(a22 + zr2*a23));\n"
"    real gqxz14 = zr*(a21 + (xr2 + yr2)*a22 + xr2*yr2*a23);\n"
"    real gqxz15 = yr*(a21 + (xr2 + zr2)*a22 + zr2*xr2*a23);\n"
"    real gqxz16 = zr*(3*(a21 + xr2*a22) + zr2*(a22 + xr2*a23));\n"
"    real gqxz17 = xr*yr*zr*(3*a22 + yr2*a23);\n"
"    real gqxz18 = xr*(a21 + (zr2 + yr2)*a22 + zr2*yr2*a23);\n"
"    real gqxz19 = xr*yr*zr*(3*a22 + zr2*a23);\n"
"    real gqxz20 = xr*(3*a21 + zr2*(6*a22 + zr2*a23));\n"
"    real gqyy11 = xr*yr2*(3*a22 + xr2*a23);\n"
"    real gqyy12 = yr*(2*a21 + xr2*2*a22 + yr2*(a22 + xr2*a23));\n"
"    real gqyy13 = zr*yr2*(a22 + xr2*a23);\n"
"    real gqyy14 = xr*(2*a21 + yr2*(5*a22 + yr2*a23));\n"
"    real gqyy15 = xr*yr*zr*(2*a22 + yr2*a23);\n"
"    real gqyy16 = xr*yr2*(a22 + zr2*a23);\n"
"    real gqyy17 = yr*(12*a21 + yr2*(9*a22 + yr2*a23));\n"
"    real gqyy18 = zr*(2*a21 + yr2*(5*a22 + yr2*a23));\n"
"    real gqyy19 = yr*(2*a21 + zr2*2*a22 + yr2*(a22 + zr2*a23));\n"
"    real gqyy20 = zr*yr2*(3*a22 + zr2*a23);\n"
"    real gqyz11 = xr*yr*zr*(3*a22 + xr2*a23);\n"
"    real gqyz12 = zr*(a21 + (xr2 + yr2)*a22 + xr2*yr2*a23);\n"
"    real gqyz13 = yr*(a21 + (xr2 + zr2)*a22 + xr2*zr2*a23);\n"
"    real gqyz14 = xr*yr*zr*(3*a22 + yr2*a23);\n"
"    real gqyz15 = xr*(a21 + (yr2 + zr2)*a22 + yr2*zr2*a23);\n"
"    real gqyz16 = xr*yr*zr*(3*a22 + zr2*a23);\n"
"    real gqyz17 = zr*(3*a21 + yr2*(6*a22 + yr2*a23));\n"
"    real gqyz18 = yr*(3*(a21 + zr2*a22) + yr2*(a22 + zr2*a23));\n"
"    real gqyz19 = zr*(3*(a21 + yr2*a22) + zr2*(a22 + yr2*a23));\n"
"    real gqyz20 = yr*(3*a21 + zr2*(6*a22 + zr2*a23));\n"
"    real gqzz11 = xr*zr2*(3*a22 + xr2*a23);\n"
"    real gqzz12 = yr*(zr2*a22 + xr2*(zr2*a23));\n"
"    real gqzz13 = zr*(2*a21 + xr2*2*a22 + zr2*(a22 + xr2*a23));\n"
"    real gqzz14 = xr*zr2*(a22 + yr2*a23);\n"
"    real gqzz15 = xr*yr*zr*(2*a22 + zr2*a23);\n"
"    real gqzz16 = xr*(2*a21 + zr2*(5*a22 + zr2*a23));\n"
"    real gqzz17 = yr*zr2*(3*a22 + yr2*a23);\n"
"    real gqzz18 = zr*(2*a21 + yr2*2*a22 + zr2*(a22 + yr2*a23));\n"
"    real gqzz19 = yr*(2*a21 + zr2*(5*a22 + zr2*a23));\n"
"    real gqzz20 = zr*(12*a21 + zr2*(9*a22 + zr2*a23));\n"
"\n"
"    dedx += atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx11 + atom2.quadrupoleYY*gqxx14 + atom2.quadrupoleZZ*gqxx16 + 2*(atom2.quadrupoleXY*gqxx12 + atom2.quadrupoleXZ*gqxx13 + atom2.quadrupoleYZ*gqxx15)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqyy11 + atom2.quadrupoleYY*gqyy14 + atom2.quadrupoleZZ*gqyy16 + 2*(atom2.quadrupoleXY*gqyy12 + atom2.quadrupoleXZ*gqyy13 + atom2.quadrupoleYZ*gqyy15)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqzz11 + atom2.quadrupoleYY*gqzz14 + atom2.quadrupoleZZ*gqzz16 + 2*(atom2.quadrupoleXY*gqzz12 + atom2.quadrupoleXZ*gqzz13 + atom2.quadrupoleYZ*gqzz15)) +\n"
"          2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxy11 + atom2.quadrupoleYY*gqxy14 + atom2.quadrupoleZZ*gqxy16 + 2*(atom2.quadrupoleXY*gqxy12 + atom2.quadrupoleXZ*gqxy13 + atom2.quadrupoleYZ*gqxy15)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxz11 + atom2.quadrupoleYY*gqxz14 + atom2.quadrupoleZZ*gqxz16 + 2*(atom2.quadrupoleXY*gqxz12 + atom2.quadrupoleXZ*gqxz13 + atom2.quadrupoleYZ*gqxz15)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqyz11 + atom2.quadrupoleYY*gqyz14 + atom2.quadrupoleZZ*gqyz16 + 2*(atom2.quadrupoleXY*gqyz12 + atom2.quadrupoleXZ*gqyz13 + atom2.quadrupoleYZ*gqyz15))) +\n"
"\n"
"            atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx11 + atom2.quadrupoleYY*gqyy11 + atom2.quadrupoleZZ*gqzz11 + 2*(atom2.quadrupoleXY*gqxy11 + atom2.quadrupoleXZ*gqxz11 + atom2.quadrupoleYZ*gqyz11)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqxx14 + atom2.quadrupoleYY*gqyy14 + atom2.quadrupoleZZ*gqzz14 + 2*(atom2.quadrupoleXY*gqxy14 + atom2.quadrupoleXZ*gqxz14 + atom2.quadrupoleYZ*gqyz14)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqxx16 + atom2.quadrupoleYY*gqyy16 + atom2.quadrupoleZZ*gqzz16 + 2*(atom2.quadrupoleXY*gqxy16 + atom2.quadrupoleXZ*gqxz16 + atom2.quadrupoleYZ*gqyz16)) +\n"
"\n"
"          2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxx12 + atom2.quadrupoleYY*gqyy12 + atom2.quadrupoleZZ*gqzz12 + 2*(atom2.quadrupoleXY*gqxy12 + atom2.quadrupoleXZ*gqxz12 + atom2.quadrupoleYZ*gqyz12)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxx13 + atom2.quadrupoleYY*gqyy13 + atom2.quadrupoleZZ*gqzz13 + 2*(atom2.quadrupoleXY*gqxy13 + atom2.quadrupoleXZ*gqxz13 + atom2.quadrupoleYZ*gqyz13)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqxx15 + atom2.quadrupoleYY*gqyy15 + atom2.quadrupoleZZ*gqzz15 + 2*(atom2.quadrupoleXY*gqxy15 + atom2.quadrupoleXZ*gqxz15 + atom2.quadrupoleYZ*gqyz15)));\n"
"\n"
"    dedy += atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx12 + atom2.quadrupoleYY*gqxx17 + atom2.quadrupoleZZ*gqxx19 + 2*(atom2.quadrupoleXY*gqxx14 + atom2.quadrupoleXZ*gqxx15 + atom2.quadrupoleYZ*gqxx18)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqyy12 + atom2.quadrupoleYY*gqyy17 + atom2.quadrupoleZZ*gqyy19 + 2*(atom2.quadrupoleXY*gqyy14 + atom2.quadrupoleXZ*gqyy15 + atom2.quadrupoleYZ*gqyy18)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqzz12 + atom2.quadrupoleYY*gqzz17 + atom2.quadrupoleZZ*gqzz19 + 2*(atom2.quadrupoleXY*gqzz14 + atom2.quadrupoleXZ*gqzz15 + atom2.quadrupoleYZ*gqzz18)) +\n"
"\n"
"          2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxy12 + atom2.quadrupoleYY*gqxy17 + atom2.quadrupoleZZ*gqxy19 + 2*(atom2.quadrupoleXY*gqxy14 + atom2.quadrupoleXZ*gqxy15 + atom2.quadrupoleYZ*gqxy18)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxz12 + atom2.quadrupoleYY*gqxz17 + atom2.quadrupoleZZ*gqxz19 + 2*(atom2.quadrupoleXY*gqxz14 + atom2.quadrupoleXZ*gqxz15 + atom2.quadrupoleYZ*gqxz18)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqyz12 + atom2.quadrupoleYY*gqyz17 + atom2.quadrupoleZZ*gqyz19 + 2*(atom2.quadrupoleXY*gqyz14 + atom2.quadrupoleXZ*gqyz15 + atom2.quadrupoleYZ*gqyz18))) +\n"
"\n"
"            atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx12 + atom2.quadrupoleYY*gqyy12 + atom2.quadrupoleZZ*gqzz12 + 2*(atom2.quadrupoleXY*gqxy12 + atom2.quadrupoleXZ*gqxz12 + atom2.quadrupoleYZ*gqyz12)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqxx17 + atom2.quadrupoleYY*gqyy17 + atom2.quadrupoleZZ*gqzz17 + 2*(atom2.quadrupoleXY*gqxy17 + atom2.quadrupoleXZ*gqxz17 + atom2.quadrupoleYZ*gqyz17)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqxx19 + atom2.quadrupoleYY*gqyy19 + atom2.quadrupoleZZ*gqzz19 + 2*(atom2.quadrupoleXY*gqxy19 + atom2.quadrupoleXZ*gqxz19 + atom2.quadrupoleYZ*gqyz19)) +\n"
"\n"
"          2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxx14 + atom2.quadrupoleYY*gqyy14 + atom2.quadrupoleZZ*gqzz14 + 2*(atom2.quadrupoleXY*gqxy14 + atom2.quadrupoleXZ*gqxz14 + atom2.quadrupoleYZ*gqyz14)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxx15 + atom2.quadrupoleYY*gqyy15 + atom2.quadrupoleZZ*gqzz15 + 2*(atom2.quadrupoleXY*gqxy15 + atom2.quadrupoleXZ*gqxz15 + atom2.quadrupoleYZ*gqyz15)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqxx18 + atom2.quadrupoleYY*gqyy18 + atom2.quadrupoleZZ*gqzz18 + 2*(atom2.quadrupoleXY*gqxy18 + atom2.quadrupoleXZ*gqxz18 + atom2.quadrupoleYZ*gqyz18)));\n"
"\n"
"    dedz += atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx13 + atom2.quadrupoleYY*gqxx18 + atom2.quadrupoleZZ*gqxx20 + 2*(atom2.quadrupoleXY*gqxx15 + atom2.quadrupoleXZ*gqxx16 + atom2.quadrupoleYZ*gqxx19)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqyy13 + atom2.quadrupoleYY*gqyy18 + atom2.quadrupoleZZ*gqyy20 + 2*(atom2.quadrupoleXY*gqyy15 + atom2.quadrupoleXZ*gqyy16 + atom2.quadrupoleYZ*gqyy19)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqzz13 + atom2.quadrupoleYY*gqzz18 + atom2.quadrupoleZZ*gqzz20 + 2*(atom2.quadrupoleXY*gqzz15 + atom2.quadrupoleXZ*gqzz16 + atom2.quadrupoleYZ*gqzz19)) +\n"
"\n"
"           2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxy13 + atom2.quadrupoleYY*gqxy18 + atom2.quadrupoleZZ*gqxy20 + 2*(atom2.quadrupoleXY*gqxy15 + atom2.quadrupoleXZ*gqxy16 + atom2.quadrupoleYZ*gqxy19)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxz13 + atom2.quadrupoleYY*gqxz18 + atom2.quadrupoleZZ*gqxz20 + 2*(atom2.quadrupoleXY*gqxz15 + atom2.quadrupoleXZ*gqxz16 + atom2.quadrupoleYZ*gqxz19)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqyz13 + atom2.quadrupoleYY*gqyz18 + atom2.quadrupoleZZ*gqyz20 + 2*(atom2.quadrupoleXY*gqyz15 + atom2.quadrupoleXZ*gqyz16 + atom2.quadrupoleYZ*gqyz19))) +\n"
"\n"
"            atom1.quadrupoleXX*(atom2.quadrupoleXX*gqxx13 + atom2.quadrupoleYY*gqyy13 + atom2.quadrupoleZZ*gqzz13 + 2*(atom2.quadrupoleXY*gqxy13 + atom2.quadrupoleXZ*gqxz13 + atom2.quadrupoleYZ*gqyz13)) +\n"
"            atom1.quadrupoleYY*(atom2.quadrupoleXX*gqxx18 + atom2.quadrupoleYY*gqyy18 + atom2.quadrupoleZZ*gqzz18 + 2*(atom2.quadrupoleXY*gqxy18 + atom2.quadrupoleXZ*gqxz18 + atom2.quadrupoleYZ*gqyz18)) +\n"
"            atom1.quadrupoleZZ*(atom2.quadrupoleXX*gqxx20 + atom2.quadrupoleYY*gqyy20 + atom2.quadrupoleZZ*gqzz20 + 2*(atom2.quadrupoleXY*gqxy20 + atom2.quadrupoleXZ*gqxz20 + atom2.quadrupoleYZ*gqyz20)) +\n"
"\n"
"           2*(\n"
"            atom1.quadrupoleXY*(atom2.quadrupoleXX*gqxx15 + atom2.quadrupoleYY*gqyy15 + atom2.quadrupoleZZ*gqzz15 + 2*(atom2.quadrupoleXY*gqxy15 + atom2.quadrupoleXZ*gqxz15 + atom2.quadrupoleYZ*gqyz15)) +\n"
"            atom1.quadrupoleXZ*(atom2.quadrupoleXX*gqxx16 + atom2.quadrupoleYY*gqyy16 + atom2.quadrupoleZZ*gqzz16 + 2*(atom2.quadrupoleXY*gqxy16 + atom2.quadrupoleXZ*gqxz16 + atom2.quadrupoleYZ*gqyz16)) +\n"
"            atom1.quadrupoleYZ*(atom2.quadrupoleXX*gqxx19 + atom2.quadrupoleYY*gqyy19 + atom2.quadrupoleZZ*gqzz19 + 2*(atom2.quadrupoleXY*gqxy19 + atom2.quadrupoleXZ*gqxz19 + atom2.quadrupoleYZ*gqyz19)));\n"
"#endif\n"
"\n"
"\n"
"#if defined T1\n"
"    if (xr != 0 || yr != 0 || zr != 0) {\n"
"\n"
"        real gux1 = xr*a10;\n"
"        real guy1 = yr*a10;\n"
"        real guz1 = zr*a10;\n"
"\n"
"        real gc2 = xr*a01;\n"
"        real gc3 = yr*a01;\n"
"        real gc4 = zr*a01;\n"
"        real fid1 = atom2.dipole.x*gux2 + atom2.dipole.y*gux3 + atom2.dipole.z*gux4 + 0.5f*(atom2.q*gux1 + atom2.quadrupoleXX*gux5 + atom2.quadrupoleYY*gux8 + atom2.quadrupoleZZ*gux10 +\n"
"                           2*(atom2.quadrupoleXY*gux6 + atom2.quadrupoleXZ*gux7 + atom2.quadrupoleYZ*gux9) +\n"
"                          atom2.q*gc2 + atom2.quadrupoleXX*gqxx2 + atom2.quadrupoleYY*gqyy2 + atom2.quadrupoleZZ*gqzz2 +\n"
"                           2*(atom2.quadrupoleXY*gqxy2 + atom2.quadrupoleXZ*gqxz2 + atom2.quadrupoleYZ*gqyz2));\n"
"\n"
"        real fid2 = atom2.dipole.x*guy2 + atom2.dipole.y*guy3 + atom2.dipole.z*guy4 + 0.5f*(atom2.q*guy1 + atom2.quadrupoleXX*guy5 + atom2.quadrupoleYY*guy8 + atom2.quadrupoleZZ*guy10 +\n"
"                           2*(atom2.quadrupoleXY*guy6 + atom2.quadrupoleXZ*guy7 + atom2.quadrupoleYZ*guy9) +\n"
"                          atom2.q*gc3 + atom2.quadrupoleXX*gqxx3 + atom2.quadrupoleYY*gqyy3 + atom2.quadrupoleZZ*gqzz3 + \n"
"                           2*(atom2.quadrupoleXY*gqxy3 + atom2.quadrupoleXZ*gqxz3 + atom2.quadrupoleYZ*gqyz3));\n"
"\n"
"        real fid3 = atom2.dipole.x*guz2 + atom2.dipole.y*guz3 + atom2.dipole.z*guz4 + 0.5f*(atom2.q*guz1 + atom2.quadrupoleXX*guz5 + atom2.quadrupoleYY*guz8 + atom2.quadrupoleZZ*guz10 +\n"
"                           2*(atom2.quadrupoleXY*guz6 + atom2.quadrupoleXZ*guz7 + atom2.quadrupoleYZ*guz9) +\n"
"                           atom2.q*gc4 + atom2.quadrupoleXX*gqxx4 + atom2.quadrupoleYY*gqyy4 + atom2.quadrupoleZZ*gqzz4 +\n"
"                           2*(atom2.quadrupoleXY*gqxy4 + atom2.quadrupoleXZ*gqxz4 + atom2.quadrupoleYZ*gqyz4));\n"
"\n"
"        real trq1 = atom1.dipole.y*fid3 - atom1.dipole.z*fid2;\n"
"        real trq2 = atom1.dipole.z*fid1 - atom1.dipole.x*fid3;\n"
"        real trq3 = atom1.dipole.x*fid2 - atom1.dipole.y*fid1;\n"
"\n"
"        // torque on quadrupoles due to permanent reaction field gradient\n"
"\n"
"        real fidg11 =\n"
"                (atom2.q*xr2*a20 + atom2.dipole.x*gqxx2 + atom2.dipole.y*gqxx3 + atom2.dipole.z*gqxx4\n"
"                       + atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqxx8 + atom2.quadrupoleZZ*gqxx10\n"
"                       + 2*(atom2.quadrupoleXY*gqxx6 + atom2.quadrupoleXZ*gqxx7 + atom2.quadrupoleYZ*gqxx9)\n"
"                       + atom2.q*gc5 + atom2.dipole.x*gux5 + atom2.dipole.y*guy5 + atom2.dipole.z*guz5\n"
"                       + atom2.quadrupoleXX*gqxx5 + atom2.quadrupoleYY*gqyy5 + atom2.quadrupoleZZ*gqzz5\n"
"                       + 2*(atom2.quadrupoleXY*gqxy5 + atom2.quadrupoleXZ*gqxz5 + atom2.quadrupoleYZ*gqyz5));\n"
"\n"
"        real fidg12 =\n"
"                (atom2.q*xr*yr*a20 + atom2.dipole.x*gqxy2 + atom2.dipole.y*gqxy3 + atom2.dipole.z*gqxy4\n"
"                       + atom2.quadrupoleXX*gqxy5 + atom2.quadrupoleYY*gqxy8 + atom2.quadrupoleZZ*gqxy10\n"
"                       + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxy7 + atom2.quadrupoleYZ*gqxy9)\n"
"                       + atom2.q*gc6 + atom2.dipole.x*gux6 + atom2.dipole.y*guy6 + atom2.dipole.z*guz6\n"
"                       + atom2.quadrupoleXX*gqxx6 + atom2.quadrupoleYY*gqyy6 + atom2.quadrupoleZZ*gqzz6\n"
"                       + 2*(atom2.quadrupoleXY*gqxy6 + atom2.quadrupoleXZ*gqxz6 + atom2.quadrupoleYZ*gqyz6));\n"
"\n"
"        real fidg13 =\n"
"                (atom2.q*xr*zr*a20 + atom2.dipole.x*gqxz2 + atom2.dipole.y*gqxz3 + atom2.dipole.z*gqxz4\n"
"                       + atom2.quadrupoleXX*gqxz5 + atom2.quadrupoleYY*gqxz8 + atom2.quadrupoleZZ*gqxz10\n"
"                       + 2*(atom2.quadrupoleXY*gqxz6 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqxz9)\n"
"                       + atom2.q*gc7 + atom2.dipole.x*gux7 + atom2.dipole.y*guy7 + atom2.dipole.z*guz7\n"
"                       + atom2.quadrupoleXX*gqxx7 + atom2.quadrupoleYY*gqyy7 + atom2.quadrupoleZZ*gqzz7\n"
"                       + 2*(atom2.quadrupoleXY*gqxy7 + atom2.quadrupoleXZ*gqxz7 + atom2.quadrupoleYZ*gqyz7));\n"
"\n"
"        real fidg22 =\n"
"                (atom2.q*yr2*a20 + atom2.dipole.x*gqyy2 + atom2.dipole.y*gqyy3 + atom2.dipole.z*gqyy4\n"
"                       + atom2.quadrupoleXX*gqyy5 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqyy10\n"
"                       + 2*(atom2.quadrupoleXY*gqyy6 + atom2.quadrupoleXZ*gqyy7 + atom2.quadrupoleYZ*gqyy9)\n"
"                       + atom2.q*gc8 + atom2.dipole.x*gux8 + atom2.dipole.y*guy8 + atom2.dipole.z*guz8\n"
"                       + atom2.quadrupoleXX*gqxx8 + atom2.quadrupoleYY*gqyy8 + atom2.quadrupoleZZ*gqzz8\n"
"                       + 2*(atom2.quadrupoleXY*gqxy8 + atom2.quadrupoleXZ*gqxz8 + atom2.quadrupoleYZ*gqyz8));\n"
"\n"
"        real fidg23 =\n"
"                (atom2.q*yr*zr*a20 + atom2.dipole.x*gqyz2 + atom2.dipole.y*gqyz3 + atom2.dipole.z*gqyz4\n"
"                       + atom2.quadrupoleXX*gqyz5 + atom2.quadrupoleYY*gqyz8 + atom2.quadrupoleZZ*gqyz10\n"
"                       + 2*(atom2.quadrupoleXY*gqyz6 + atom2.quadrupoleXZ*gqyz7 + atom2.quadrupoleYZ*gqyz9)\n"
"                       + atom2.q*gc9 + atom2.dipole.x*gux9 + atom2.dipole.y*guy9 + atom2.dipole.z*guz9\n"
"                       + atom2.quadrupoleXX*gqxx9 + atom2.quadrupoleYY*gqyy9 + atom2.quadrupoleZZ*gqzz9\n"
"                       + 2*(atom2.quadrupoleXY*gqxy9 + atom2.quadrupoleXZ*gqxz9 + atom2.quadrupoleYZ*gqyz9));\n"
"\n"
"        real fidg33 =\n"
"                (atom2.q*zr2*a20 + atom2.dipole.x*gqzz2 + atom2.dipole.y*gqzz3 + atom2.dipole.z*gqzz4\n"
"                       + atom2.quadrupoleXX*gqzz5 + atom2.quadrupoleYY*gqzz8 + atom2.quadrupoleZZ*gqzz10\n"
"                       + 2*(atom2.quadrupoleXY*gqzz6 + atom2.quadrupoleXZ*gqzz7 + atom2.quadrupoleYZ*gqzz9)\n"
"                       + atom2.q*gc10 + atom2.dipole.x*gux10 + atom2.dipole.y*guy10 + atom2.dipole.z*guz10\n"
"                       + atom2.quadrupoleXX*gqxx10 + atom2.quadrupoleYY*gqyy10 + atom2.quadrupoleZZ*gqzz10\n"
"                    + 2*(atom2.quadrupoleXY*gqxy10 + atom2.quadrupoleXZ*gqxz10 + atom2.quadrupoleYZ*gqyz10));\n"
"\n"
"        trq1 -= (atom1.quadrupoleXY*fidg13 + atom1.quadrupoleYY*fidg23 + atom1.quadrupoleYZ*fidg33 -atom1.quadrupoleXZ*fidg12-atom1.quadrupoleYZ*fidg22-atom1.quadrupoleZZ*fidg23);\n"
"        trq2 -= (atom1.quadrupoleXZ*fidg11 + atom1.quadrupoleYZ*fidg12 + atom1.quadrupoleZZ*fidg13 -atom1.quadrupoleXX*fidg13-atom1.quadrupoleXY*fidg23-atom1.quadrupoleXZ*fidg33);\n"
"        trq3 -= (atom1.quadrupoleXX*fidg12 + atom1.quadrupoleXY*fidg22 + atom1.quadrupoleXZ*fidg23 -atom1.quadrupoleXY*fidg11-atom1.quadrupoleYY*fidg12-atom1.quadrupoleYZ*fidg13);\n"
"\n"
"        torque->x = trq1;\n"
"        torque->y = trq2;\n"
"        torque->z = trq3;\n"
"\n"
"    } else {\n"
"        torque->x = 0;\n"
"        torque->y = 0;\n"
"        torque->z = 0;\n"
"    }\n"
"#endif\n"
"\n"
"#if defined B2 \n"
"    dsumdrB2 *= 0.5f;\n"
"    *bornForce1 += 0.5f*atom2.bornRadius*dsumdrB2;\n"
"    *bornForce2 += 0.5f*atom1.bornRadius*dsumdrB2;\n"
"#endif\n"
"\n"
"#if defined T2\n"
"    // torque due to induced reaction field gradient on quadrupoles;\n"
"\n"
"    real fidg11 = sxk*gqxx2 + syk*gqxx3 + szk*gqxx4 + sxk*gux5 + syk*guy5 + szk*guz5;\n"
"    real fidg12 = sxk*gqxy2 + syk*gqxy3 + szk*gqxy4 + sxk*gux6 + syk*guy6 + szk*guz6;\n"
"    real fidg13 = sxk*gqxz2 + syk*gqxz3 + szk*gqxz4 + sxk*gux7 + syk*guy7 + szk*guz7;\n"
"    real fidg22 = sxk*gqyy2 + syk*gqyy3 + szk*gqyy4 + sxk*gux8 + syk*guy8 + szk*guz8;\n"
"    real fidg23 = sxk*gqyz2 + syk*gqyz3 + szk*gqyz4 + sxk*gux9 + syk*guy9 + szk*guz9;\n"
"    real fidg33 = sxk*gqzz2 + syk*gqzz3 + szk*gqzz4 + sxk*gux10 + syk*guy10 + szk*guz10;\n"
"\n"
"    trqi1 -= atom1.quadrupoleXY*fidg13 + atom1.quadrupoleYY*fidg23 + atom1.quadrupoleYZ*fidg33\n"
"                                -atom1.quadrupoleXZ*fidg12 - atom1.quadrupoleYZ*fidg22 - atom1.quadrupoleZZ*fidg23;\n"
"\n"
"    trqi2 -= atom1.quadrupoleXZ*fidg11 + atom1.quadrupoleYZ*fidg12 + atom1.quadrupoleZZ*fidg13\n"
"                                -atom1.quadrupoleXX*fidg13 - atom1.quadrupoleXY*fidg23 - atom1.quadrupoleXZ*fidg33;\n"
"\n"
"    trqi3 -= atom1.quadrupoleXX*fidg12 + atom1.quadrupoleXY*fidg22 + atom1.quadrupoleXZ*fidg23\n"
"                                -atom1.quadrupoleXY*fidg11 - atom1.quadrupoleYY*fidg12 - atom1.quadrupoleYZ*fidg13;\n"
"\n"
"    torque->x += 0.5f*trqi1;\n"
"    torque->y += 0.5f*trqi2;\n"
"    torque->z += 0.5f*trqi3;\n"
"#endif\n"
"\n"
"#if defined F1\n"
"\n"
"    *outputEnergy = energy;\n"
"\n"
"    if ((xr != 0 || yr != 0 || zr != 0)) {\n"
"        force->x = dedx;\n"
"        force->y = dedy;\n"
"        force->z = dedz;\n"
"    } else {\n"
"        force->x = force->y = force->z = 0;\n"
"    }\n"
"\n"
"#endif\n"
"\n"
"#if defined F2\n"
"    *outputEnergy += 0.5f*energy;\n"
"\n"
"    dpdx *= 0.5f;\n"
"    dpdy *= 0.5f;\n"
"    dpdz *= 0.5f;\n"
"\n"
"    if ((xr != 0 || yr != 0 || zr != 0)) {\n"
"        force->x += dpdx;\n"
"        force->y += dpdy;\n"
"        force->z += dpdz;\n"
"    }\n"
"#endif\n"
"}\n"
"";
const string CommonAmoebaKernelSources::hippoComputeField = "DEVICE void computeDirectFieldDampingFactors(real alpha, real r, real* fdamp3, real* fdamp5, real* fdamp7) {\n"
"    real ar = alpha*r;\n"
"    real ar2 = ar*ar;\n"
"    real ar3 = ar2*ar;\n"
"    real ar4 = ar2*ar2;\n"
"    real expAR = EXP(-ar);\n"
"    real one = 1;\n"
"    *fdamp3 = 1 - (1 + ar + ar2*(one/2))*expAR;\n"
"    *fdamp5 = 1 - (1 + ar + ar2*(one/2) + ar3*(one/6))*expAR;\n"
"    *fdamp7 = 1 - (1 + ar + ar2*(one/2) + ar3*(one/6) + ar4*(one/30))*expAR;\n"
"}\n"
"\n"
"DEVICE void computeMutualFieldDampingFactors(real alphaI, real alphaJ, real r, real* fdamp3, real* fdamp5) {\n"
"    real arI = alphaI*r;\n"
"    real arI2 = arI*arI;\n"
"    real arI3 = arI2*arI;\n"
"    real expARI = EXP(-arI);\n"
"    real one = 1;\n"
"    real seven = 7;\n"
"    if (alphaI == alphaJ) {\n"
"        real arI4 = arI3*arI;\n"
"        real arI5 = arI4*arI;\n"
"        *fdamp3 = 1 - (1 + arI + arI2*(one/2) + arI3*(seven/48) + arI4*(one/48))*expARI;\n"
"        *fdamp5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/144))*expARI;\n"
"    }\n"
"    else {\n"
"        real arJ = alphaJ*r;\n"
"        real arJ2 = arJ*arJ;\n"
"        real arJ3 = arJ2*arJ;\n"
"        real expARJ = EXP(-arJ);\n"
"        real aI2 = alphaI*alphaI;\n"
"        real aJ2 = alphaJ*alphaJ;\n"
"        real A = aJ2/(aJ2-aI2);\n"
"        real B = aI2/(aI2-aJ2);\n"
"        real A2expARI = A*A*expARI;\n"
"        real B2expARJ = B*B*expARJ;\n"
"        *fdamp3 = 1 - (1 + arI + arI2*(one/2))*A2expARI -\n"
"                      (1 + arJ + arJ2*(one/2))*B2expARJ -\n"
"                      (1 + arI)*2*B*A2expARI -\n"
"                      (1 + arJ)*2*A*B2expARJ;\n"
"        *fdamp5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6))*A2expARI -\n"
"                      (1 + arJ + arJ2*(one/2) + arJ3*(one/6))*B2expARJ -\n"
"                      (1 + arI + arI2*(one/3))*2*B*A2expARI -\n"
"                      (1 + arJ + arJ2*(one/3))*2*A*B2expARJ;\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute the electrostatic field.\n"
" */\n"
"KERNEL void computeField(GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* RESTRICT exclusionTiles, GLOBAL mm_ulong* RESTRICT fieldBuffers,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const unsigned int* RESTRICT interactingAtoms\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = warp*NUM_TILES_WITH_EXCLUSIONS/totalWarps;\n"
"    const unsigned int lastExclusionTile = (warp+1)*NUM_TILES_WITH_EXCLUSIONS/totalWarps;\n"
"    for (int tile = firstExclusionTile; tile < lastExclusionTile; tile++) {\n"
"        const int2 tileIndices = exclusionTiles[tile];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real3 field = make_real3(0);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 pos1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"        unsigned int excl = exclusions[tile*TILE_SIZE+tgx];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            localData[LOCAL_ID].x = pos1.x;\n"
"            localData[LOCAL_ID].y = pos1.y;\n"
"            localData[LOCAL_ID].z = pos1.z;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real3 pos2 = make_real3(localData[atom2].x, localData[atom2].y, localData[atom2].z);\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    real3 tempField1 = make_real3(0);\n"
"                    real3 tempField2 = make_real3(0);\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                    if (!isExcluded && atom1 != atom2) {\n"
"                        COMPUTE_FIELD\n"
"                    }\n"
"                    field += tempField1;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"                excl >>= 1;\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[LOCAL_ID].x = tempPosq.x;\n"
"            localData[LOCAL_ID].y = tempPosq.y;\n"
"            localData[LOCAL_ID].z = tempPosq.z;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            localData[localAtomIndex].fx = 0;\n"
"            localData[localAtomIndex].fy = 0;\n"
"            localData[localAtomIndex].fz = 0;\n"
"            SYNC_WARPS;\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"                real3 pos2 = make_real3(localData[atom2].x, localData[atom2].y, localData[atom2].z);\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+tj;\n"
"                    real3 tempField1 = make_real3(0);\n"
"                    real3 tempField2 = make_real3(0);\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                    if (!isExcluded) {\n"
"                        COMPUTE_FIELD\n"
"                    }\n"
"                    field += tempField1;\n"
"                    localData[tbx+tj].fx += tempField2.x;\n"
"                    localData[tbx+tj].fy += tempField2.y;\n"
"                    localData[tbx+tj].fz += tempField2.z;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"                excl >>= 1;\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&fieldBuffers[offset1], (mm_ulong) ((mm_long) (field.x*0x100000000)));\n"
"        ATOMIC_ADD(&fieldBuffers[offset1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (field.y*0x100000000)));\n"
"        ATOMIC_ADD(&fieldBuffers[offset1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (field.z*0x100000000)));\n"
"        if (x != y) {\n"
"            unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&fieldBuffers[offset2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int tile = (int) (warp*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (long)numTiles)/totalWarps);\n"
"    int end = (int) ((warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (long)numTiles)/totalWarps);\n"
"#else\n"
"    int tile = (int) (warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"    \n"
"    while (tile < end) {\n"
"        real3 field = make_real3(0);\n"
"        bool includeTile = true;\n"
"        \n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[tile];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*tile));\n"
"        x = (tile-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (tile-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < tile) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < tile)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != tile);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"            \n"
"            real4 pos1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[tile*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                real4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                localData[localAtomIndex].fx = 0;\n"
"                localData[localAtomIndex].fy = 0;\n"
"                localData[localAtomIndex].fz = 0;\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[LOCAL_ID], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = make_real3(localData[atom2].x, localData[atom2].y, localData[atom2].z);\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real3 tempField1 = make_real3(0);\n"
"                        real3 tempField2 = make_real3(0);\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_FIELD\n"
"                        }\n"
"                        field += tempField1;\n"
"                        localData[tbx+tj].fx += tempField2.x;\n"
"                        localData[tbx+tj].fy += tempField2.y;\n"
"                        localData[tbx+tj].fz += tempField2.z;\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = make_real3(localData[atom2].x, localData[atom2].y, localData[atom2].z);\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real3 tempField1 = make_real3(0);\n"
"                        real3 tempField2 = make_real3(0);\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_FIELD\n"
"                        }\n"
"                        field += tempField1;\n"
"                        localData[tbx+tj].fx += tempField2.x;\n"
"                        localData[tbx+tj].fy += tempField2.y;\n"
"                        localData[tbx+tj].fz += tempField2.z;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"        \n"
"            // Write results.\n"
"\n"
"            ATOMIC_ADD(&fieldBuffers[atom1], (mm_ulong) ((mm_long) (field.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (field.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (field.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                ATOMIC_ADD(&fieldBuffers[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"                ATOMIC_ADD(&fieldBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"                ATOMIC_ADD(&fieldBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"            }\n"
"        }\n"
"        tile++;\n"
"    }\n"
"}\n"
"\n"
"#define COMPUTING_EXCEPTIONS\n"
"\n"
"/**\n"
" * Compute the electrostatic field from nonbonded exceptions.\n"
" */\n"
"KERNEL void computeFieldExceptions(GLOBAL const real4* RESTRICT posq, GLOBAL mm_ulong* RESTRICT fieldBuffers,\n"
"        GLOBAL const int2* RESTRICT exceptionAtoms, GLOBAL const real* RESTRICT exceptionScale\n"
"#ifdef USE_CUTOFF\n"
"        , real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    for (int index = GLOBAL_ID; index < NUM_EXCEPTIONS; index += GLOBAL_SIZE) {\n"
"        int2 atoms = exceptionAtoms[index];\n"
"        int atom1 = atoms.x;\n"
"        int atom2 = atoms.y;\n"
"        real4 pos1 = posq[atom1];\n"
"        real4 pos2 = posq[atom2];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"        LOAD_ATOM2_PARAMETERS_FROM_GLOBAL\n"
"        real scale = exceptionScale[index];\n"
"        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"            real invR = RSQRT(r2);\n"
"            real r = r2*invR;\n"
"            real3 tempField1 = make_real3(0);\n"
"            real3 tempField2 = make_real3(0);\n"
"            COMPUTE_FIELD\n"
"            ATOMIC_ADD(&fieldBuffers[atom1], (mm_ulong) ((mm_long) (tempField1.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempField1.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempField1.z*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom2], (mm_ulong) ((mm_long) (tempField2.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempField2.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempField2.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"        }\n"
"#endif\n"
"    }\n"
"}";
const string CommonAmoebaKernelSources::hippoFixedField = "real invR2 = invR*invR;\n"
"real invR3 = invR*invR2;\n"
"real invR5 = invR3*invR2;\n"
"real invR7 = invR5*invR2;\n"
"\n"
"#if USE_EWALD\n"
"// Calculate the error function damping terms.\n"
"\n"
"real ralpha = PME_ALPHA*r;\n"
"real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    const real erfcAlphaR = erfc(ralpha);\n"
"#else\n"
"    // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"    // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"    // error of 1.5e-7.\n"
"\n"
"    const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"    const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"real bn0 = erfcAlphaR*invR;\n"
"real alsq2 = 2*PME_ALPHA*PME_ALPHA;\n"
"real alsq2n = 1/(SQRT_PI*PME_ALPHA);\n"
"alsq2n *= alsq2;\n"
"real bn1 = (bn0+alsq2n*exp2a)*invR2;\n"
"alsq2n *= alsq2;\n"
"real bn2 = (3*bn1+alsq2n*exp2a)*invR2;\n"
"alsq2n *= alsq2;\n"
"real bn3 = (5*bn2+alsq2n*exp2a)*invR2;\n"
"#endif\n"
"\n"
"// Calculate the field at particle 1 due to multipoles at particle 2\n"
"\n"
"real fdamp3, fdamp5, fdamp7;\n"
"computeDirectFieldDampingFactors(alpha2, r, &fdamp3, &fdamp5, &fdamp7);\n"
"#ifndef COMPUTING_EXCEPTIONS\n"
"real scale = 1;\n"
"#endif\n"
"#ifdef USE_EWALD\n"
"real rr3 = bn1 - (1-scale)*invR3;\n"
"real rr3j = bn1 - (1-scale*fdamp3)*invR3;\n"
"real rr5j = bn2 - (1-scale*fdamp5)*3*invR5;\n"
"real rr7j = bn3 - (1-scale*fdamp7)*15*invR7;\n"
"#else\n"
"real rr3 = scale*invR3;\n"
"real rr3j = scale*fdamp3*invR3;\n"
"real rr5j = scale*3*fdamp5*invR5;\n"
"real rr7j = scale*15*fdamp7*invR7;\n"
"#endif\n"
"real qZZ2 = -qXX2-qYY2;\n"
"real3 qDotDelta2 = make_real3(delta.x*qXX2 + delta.y*qXY2 + delta.z*qXZ2,\n"
"                              delta.x*qXY2 + delta.y*qYY2 + delta.z*qYZ2,\n"
"                              delta.x*qXZ2 + delta.y*qYZ2 + delta.z*qZZ2);\n"
"real dipoleDelta2 = dot(dipole2, delta);\n"
"real qdpoleDelta2 = dot(qDotDelta2, delta);\n"
"real factor2 = rr3*coreCharge2 + rr3j*valenceCharge2 - rr5j*dipoleDelta2 + rr7j*qdpoleDelta2;\n"
"tempField1 = -delta*factor2 - dipole2*rr3j + qDotDelta2*2*rr5j;\n"
"\n"
"// Calculate the field at particle 2 due to multipoles at particle 1\n"
"\n"
"computeDirectFieldDampingFactors(alpha1, r, &fdamp3, &fdamp5, &fdamp7);\n"
"#ifdef USE_EWALD\n"
"real rr3i = bn1 - (1-scale*fdamp3)*invR3;\n"
"real rr5i = bn2 - (1-scale*fdamp5)*3*invR5;\n"
"real rr7i = bn3 - (1-scale*fdamp7)*15*invR7;\n"
"#else\n"
"real rr3i = scale*fdamp3*invR3;\n"
"real rr5i = scale*3*fdamp5*invR5;\n"
"real rr7i = scale*15*fdamp7*invR7;\n"
"#endif\n"
"real qZZ1 = -qXX1-qYY1;\n"
"real3 qDotDelta1 = make_real3(delta.x*qXX1 + delta.y*qXY1 + delta.z*qXZ1,\n"
"                              delta.x*qXY1 + delta.y*qYY1 + delta.z*qYZ1,\n"
"                              delta.x*qXZ1 + delta.y*qYZ1 + delta.z*qZZ1);\n"
"real dipoleDelta1 = dot(dipole1, delta);\n"
"real qdpoleDelta1 = dot(qDotDelta1, delta);\n"
"real factor1 = rr3*coreCharge1 + rr3i*valenceCharge1 + rr5i*dipoleDelta1 + rr7i*qdpoleDelta1;\n"
"tempField2 = delta*factor1 - dipole1*rr3i - qDotDelta1*2*rr5i;\n"
"";
const string CommonAmoebaKernelSources::hippoInteraction = "#ifdef USE_CUTOFF\n"
"unsigned int includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"unsigned int includeInteraction = (!isExcluded);\n"
"#endif\n"
"\n"
"// Convert to quasi-internal coordinates.\n"
"\n"
"real mat[3][3];\n"
"formQIRotationMatrix(delta, rInv, mat);\n"
"real3 labForce = make_real3(0);\n"
"real3 qiDipole1 = rotateVectorToQI(dipole1, mat);\n"
"real3 qiDipole2 = rotateVectorToQI(dipole2, mat);\n"
"real3 qiInducedDipole1 = rotateVectorToQI(inducedDipole1, mat);\n"
"real3 qiInducedDipole2 = rotateVectorToQI(inducedDipole2, mat);\n"
"real qiQXX1, qiQXY1, qiQXZ1, qiQYY1, qiQYZ1, qiQZZ1;\n"
"real qiQXX2, qiQXY2, qiQXZ2, qiQYY2, qiQYZ2, qiQZZ2;\n"
"rotateQuadrupoleToQI(qXX1, qXY1, qXZ1, qYY1, qYZ1, &qiQXX1, &qiQXY1, &qiQXZ1, &qiQYY1, &qiQYZ1, &qiQZZ1, mat);\n"
"rotateQuadrupoleToQI(qXX2, qXY2, qXZ2, qYY2, qYZ2, &qiQXX2, &qiQXY2, &qiQXZ2, &qiQYY2, &qiQYZ2, &qiQZZ2, mat);\n"
"\n"
"// Compute intermediates used for dipole and quadrupole calculations.\n"
"\n"
"real dir = qiDipole1.z*r;\n"
"real3 qxI = make_real3(qiQXX1, qiQXY1, qiQXZ1);\n"
"real3 qyI = make_real3(qiQXY1, qiQYY1, qiQYZ1);\n"
"real3 qzI = make_real3(qiQXZ1, qiQYZ1, qiQZZ1);\n"
"real3 qi = r*make_real3(qiQXZ1, qiQYZ1, qiQZZ1);\n"
"real qir = qi.z*r;\n"
"real dkr = qiDipole2.z*r;\n"
"real3 qxK = make_real3(qiQXX2, qiQXY2, qiQXZ2);\n"
"real3 qyK = make_real3(qiQXY2, qiQYY2, qiQYZ2);\n"
"real3 qzK = make_real3(qiQXZ2, qiQYZ2, qiQZZ2);\n"
"real3 qk = r*make_real3(qiQXZ2, qiQYZ2, qiQZZ2);\n"
"real qkr = qk.z*r;\n"
"real dik = dot(qiDipole1, qiDipole2);\n"
"real qik = dot(qi, qk);\n"
"real diqk = dot(qiDipole1, qk);\n"
"real dkqi = dot(qiDipole2, qi);\n"
"real qiqk = 2*(qxI.y*qxK.y+qxI.z*qxK.z+qyI.z*qyK.z) + qxI.x*qxK.x + qyI.y*qyK.y + qzI.z*qzK.z;\n"
"real3 dirCross = make_real3(qiDipole1.y*r, -qiDipole1.x*r, 0);\n"
"real3 dkrCross = make_real3(qiDipole2.y*r, -qiDipole2.x*r, 0);\n"
"real3 dikCross = cross(qiDipole1, qiDipole2);\n"
"real3 qirCross = make_real3(qi.y*r, -qi.x*r, 0);\n"
"real3 qkrCross = make_real3(qk.y*r, -qk.x*r, 0);\n"
"real3 qikCross = cross(qk, qi);\n"
"real3 qikTemp = make_real3(dot(qxI, qk), dot(qyI, qk), dot(qzI, qk));\n"
"real3 qkiTemp = make_real3(dot(qxK, qi), dot(qyK, qi), dot(qzK, qi));\n"
"real3 qikrCross = make_real3(-r*qikTemp.y, r*qikTemp.x, 0);\n"
"real3 qkirCross = make_real3(-r*qkiTemp.y, r*qkiTemp.x, 0);\n"
"real3 diqkTemp = make_real3(dot(qiDipole1, qxK), dot(qiDipole1, qyK), dot(qiDipole1, qzK));\n"
"real3 dkqiTemp = make_real3(dot(qiDipole2, qxI), dot(qiDipole2, qyI), dot(qiDipole2, qzI));\n"
"real3 diqkrCross = make_real3(-r*diqkTemp.y, r*diqkTemp.x, 0);\n"
"real3 dkqirCross = make_real3(-r*dkqiTemp.y, r*dkqiTemp.x, 0);\n"
"real3 dqik = cross(qiDipole1, qk) + cross(qiDipole2, qi) - 2*(cross(qxI, qxK) + cross(qyI, qyK) + cross(qzI, qzK));\n"
"\n"
"// Get reciprocal distance terms for this interaction.\n"
"\n"
"real rInv2 = rInv*rInv;\n"
"real rr1 = rInv;\n"
"real rr3 = rr1*rInv2;\n"
"real rr5 = 3*rr3*rInv2;\n"
"real rr7 = 5*rr5*rInv2;\n"
"real rr9 = 7*rr7*rInv2;\n"
"real rr11 = 9*rr9*rInv2;\n"
"\n"
"// Compute damping factors for multipole interactions.\n"
"\n"
"real fdampI1, fdampI3, fdampI5, fdampI7, fdampI9;\n"
"real fdampK1, fdampK3, fdampK5, fdampK7, fdampK9;\n"
"real fdampIK1, fdampIK3, fdampIK5, fdampIK7, fdampIK9, fdampIK11;\n"
"computeOverlapDampingFactors(alpha1, alpha2, r, &fdampI1, &fdampI3, &fdampI5, &fdampI7, &fdampI9, &fdampK1, &fdampK3, &fdampK5, &fdampK7, &fdampK9,\n"
"                             &fdampIK1, &fdampIK3, &fdampIK5, &fdampIK7, &fdampIK9, &fdampIK11);\n"
"\n"
"#if USE_EWALD\n"
"// Calculate the error function damping terms.\n"
"\n"
"real ralpha = PME_ALPHA*r;\n"
"real bn0 = erfc(ralpha)*rInv;\n"
"real alsq2 = 2*PME_ALPHA*PME_ALPHA;\n"
"real alsq2n = 1/(SQRT_PI*PME_ALPHA);\n"
"real exp2a = EXP(-(ralpha*ralpha));\n"
"alsq2n *= alsq2;\n"
"real bn1 = (bn0+alsq2n*exp2a)*rInv2;\n"
"alsq2n *= alsq2;\n"
"real bn2 = (3*bn1+alsq2n*exp2a)*rInv2;\n"
"alsq2n *= alsq2;\n"
"real bn3 = (5*bn2+alsq2n*exp2a)*rInv2;\n"
"alsq2n *= alsq2;\n"
"real bn4 = (7*bn3+alsq2n*exp2a)*rInv2;\n"
"alsq2n *= alsq2;\n"
"real bn5 = (9*bn4+alsq2n*exp2a)*rInv2;\n"
"#endif\n"
"\n"
"// Compute the fixed multipole interaction.\n"
"\n"
"{\n"
"    // Find damped multipole intermediates and energy value.\n"
"\n"
"    real term1 = coreCharge1*coreCharge2;\n"
"    real term1i = coreCharge2*valenceCharge1;\n"
"    real term2i = coreCharge2*dir;\n"
"    real term3i = coreCharge2*qir;\n"
"    real term1k = coreCharge1*valenceCharge2;\n"
"    real term2k = -coreCharge1*dkr;\n"
"    real term3k = coreCharge1*qkr;\n"
"    real term1ik = valenceCharge1*valenceCharge2;\n"
"    real term2ik = valenceCharge2*dir - valenceCharge1*dkr + dik;\n"
"    real term3ik = valenceCharge1*qkr + valenceCharge2*qir - dir*dkr + 2*(dkqi-diqk+qiqk);\n"
"    real term4ik = dir*qkr - dkr*qir - 4*qik;\n"
"    real term5ik = qir*qkr;\n"
"#ifndef COMPUTING_EXCEPTIONS\n"
"    real multipoleMultipoleScale = 1;\n"
"#endif\n"
"#if USE_EWALD\n"
"    real rr1i = bn0 - (1-multipoleMultipoleScale*fdampI1)*rr1;\n"
"    real rr3i = bn1 - (1-multipoleMultipoleScale*fdampI3)*rr3;\n"
"    real rr5i = bn2 - (1-multipoleMultipoleScale*fdampI5)*rr5;\n"
"    real rr7i = bn3 - (1-multipoleMultipoleScale*fdampI7)*rr7;\n"
"    real rr1k = bn0 - (1-multipoleMultipoleScale*fdampK1)*rr1;\n"
"    real rr3k = bn1 - (1-multipoleMultipoleScale*fdampK3)*rr3;\n"
"    real rr5k = bn2 - (1-multipoleMultipoleScale*fdampK5)*rr5;\n"
"    real rr7k = bn3 - (1-multipoleMultipoleScale*fdampK7)*rr7;\n"
"    real rr1ik = bn0 - (1-multipoleMultipoleScale*fdampIK1)*rr1;\n"
"    real rr3ik = bn1 - (1-multipoleMultipoleScale*fdampIK3)*rr3;\n"
"    real rr5ik = bn2 - (1-multipoleMultipoleScale*fdampIK5)*rr5;\n"
"    real rr7ik = bn3 - (1-multipoleMultipoleScale*fdampIK7)*rr7;\n"
"    real rr9ik = bn4 - (1-multipoleMultipoleScale*fdampIK9)*rr9;\n"
"    real rr11ik = bn5 - (1-multipoleMultipoleScale*fdampIK11)*rr11;\n"
"    real rr1s = bn0 - (1-multipoleMultipoleScale)*rr1;\n"
"    real rr3s = bn1 - (1-multipoleMultipoleScale)*rr3;\n"
"    real scale = ENERGY_SCALE_FACTOR;\n"
"#else\n"
"    real rr1i = fdampI1*rr1;\n"
"    real rr3i = fdampI3*rr3;\n"
"    real rr5i = fdampI5*rr5;\n"
"    real rr7i = fdampI7*rr7;\n"
"    real rr1k = fdampK1*rr1;\n"
"    real rr3k = fdampK3*rr3;\n"
"    real rr5k = fdampK5*rr5;\n"
"    real rr7k = fdampK7*rr7;\n"
"    real rr1ik = fdampIK1*rr1;\n"
"    real rr3ik = fdampIK3*rr3;\n"
"    real rr5ik = fdampIK5*rr5;\n"
"    real rr7ik = fdampIK7*rr7;\n"
"    real rr9ik = fdampIK9*rr9;\n"
"    real rr11ik = fdampIK11*rr11;\n"
"    real rr1s = rr1;\n"
"    real rr3s = rr3;\n"
"    real scale = ENERGY_SCALE_FACTOR*multipoleMultipoleScale;\n"
"#endif\n"
"    real elecEnergy = scale*(term1*rr1s + term4ik*rr7ik + term5ik*rr9ik +\n"
"                             term1i*rr1i + term1k*rr1k + term1ik*rr1ik +\n"
"                             term2i*rr3i + term2k*rr3k + term2ik*rr3ik +\n"
"                             term3i*rr5i + term3k*rr5k + term3ik*rr5ik);\n"
"\n"
"    // Find damped multipole intermediates for force and torque.\n"
"\n"
"    real de = term1*rr3s + term4ik*rr9ik + term5ik*rr11ik +\n"
"              term1i*rr3i + term1k*rr3k + term1ik*rr3ik +\n"
"              term2i*rr5i + term2k*rr5k + term2ik*rr5ik +\n"
"              term3i*rr7i + term3k*rr7k + term3ik*rr7ik;\n"
"    term1 = -coreCharge2*rr3i - valenceCharge2*rr3ik + dkr*rr5ik - qkr*rr7ik;\n"
"    real term2 = coreCharge1*rr3k + valenceCharge1*rr3ik + dir*rr5ik + qir*rr7ik;\n"
"    real term3 = 2*rr5ik;\n"
"    real term4 = -2*(coreCharge2*rr5i+valenceCharge2*rr5ik-dkr*rr7ik+qkr*rr9ik);\n"
"    real term5 = -2*(coreCharge1*rr5k+valenceCharge1*rr5ik+dir*rr7ik+qir*rr9ik);\n"
"    real term6 = 4*rr7ik;\n"
"\n"
"    // Compute the force and torque.\n"
"\n"
"    real3 elecForce = -scale*(make_real3(0, 0, de*r) + term1*qiDipole1 + term2*qiDipole2 +\n"
"            term3*(diqkTemp-dkqiTemp) + term4*qi + term5*qk + term6*(qikTemp+qkiTemp));\n"
"    real3 tI = scale*(-rr3ik*dikCross + term1*dirCross + term3*(dqik+dkqirCross) + term4*qirCross - term6*(qikrCross+qikCross));\n"
"    real3 tK = scale*(rr3ik*dikCross + term2*dkrCross - term3*(dqik+diqkrCross) + term5*qkrCross - term6*(qkirCross-qikCross));\n"
"    tempEnergy += elecEnergy;\n"
"    tempForce += elecForce;\n"
"    tempTorque1 += tI;\n"
"    tempTorque2 += tK;\n"
"}\n"
"\n"
"// Compute the induced dipole interactions.\n"
"\n"
"{\n"
"    real uir = qiInducedDipole1.z*r;\n"
"    real ukr = qiInducedDipole2.z*r;\n"
"\n"
"    // Apply charge penetration damping to scale factors.\n"
"\n"
"#ifndef COMPUTING_EXCEPTIONS\n"
"    real dipoleMultipoleScale = 1;\n"
"    real dipoleDipoleScale = 1;\n"
"#endif\n"
"#if USE_EWALD\n"
"    real rr3core = ENERGY_SCALE_FACTOR*(bn1 - (1-dipoleMultipoleScale)*rr3);\n"
"    real rr5core = ENERGY_SCALE_FACTOR*(bn2 - (1-dipoleMultipoleScale)*rr5);\n"
"    real rr3i = ENERGY_SCALE_FACTOR*(bn1 - (1-dipoleMultipoleScale*fdampI3)*rr3);\n"
"    real rr5i = ENERGY_SCALE_FACTOR*(bn2 - (1-dipoleMultipoleScale*fdampI5)*rr5);\n"
"    real rr7i = ENERGY_SCALE_FACTOR*(bn3 - (1-dipoleMultipoleScale*fdampI7)*rr7);\n"
"    real rr9i = ENERGY_SCALE_FACTOR*(bn4 - (1-dipoleMultipoleScale*fdampI9)*rr9);\n"
"    real rr3k = ENERGY_SCALE_FACTOR*(bn1 - (1-dipoleMultipoleScale*fdampK3)*rr3);\n"
"    real rr5k = ENERGY_SCALE_FACTOR*(bn2 - (1-dipoleMultipoleScale*fdampK5)*rr5);\n"
"    real rr7k = ENERGY_SCALE_FACTOR*(bn3 - (1-dipoleMultipoleScale*fdampK7)*rr7);\n"
"    real rr9k = ENERGY_SCALE_FACTOR*(bn4 - (1-dipoleMultipoleScale*fdampK9)*rr9);\n"
"    real rr5ik = ENERGY_SCALE_FACTOR*(bn2 - (1-dipoleDipoleScale*fdampIK5)*rr5);\n"
"    real rr7ik = ENERGY_SCALE_FACTOR*(bn3 - (1-dipoleDipoleScale*fdampIK7)*rr7);\n"
"#else\n"
"    real dmScale = ENERGY_SCALE_FACTOR*dipoleMultipoleScale;\n"
"    real ddScale = ENERGY_SCALE_FACTOR*dipoleDipoleScale;\n"
"    real rr3core = rr3*dmScale;\n"
"    real rr5core = rr5*dmScale;\n"
"    real rr3i = rr3*fdampI3*dmScale;\n"
"    real rr5i = rr5*fdampI5*dmScale;\n"
"    real rr7i = rr7*fdampI7*dmScale;\n"
"    real rr9i = rr9*fdampI9*dmScale;\n"
"    real rr3k = rr3*fdampK3*dmScale;\n"
"    real rr5k = rr5*fdampK5*dmScale;\n"
"    real rr7k = rr7*fdampK7*dmScale;\n"
"    real rr9k = rr9*fdampK9*dmScale;\n"
"    real rr5ik = rr5*fdampIK5*ddScale;\n"
"    real rr7ik = rr7*fdampIK7*ddScale;\n"
"#endif\n"
"\n"
"    // Get the induced dipole field used for dipole torques.\n"
"\n"
"    real3 torqueField1 = rr3i*qiInducedDipole2;\n"
"    torqueField1.z -= rr5i*ukr*r;\n"
"    real3 torqueField2 = rr3k*qiInducedDipole1;\n"
"    torqueField2.z -= rr5k*uir*r;\n"
"\n"
"    // Get induced dipole field gradient used for quadrupole torques.\n"
"\n"
"    real3 dtorqueField1 = 2*r*rr5i*qiInducedDipole2;\n"
"    dtorqueField1.z -= r2*rr7i*ukr;\n"
"    real3 dtorqueField2 = -2*r*rr5k*qiInducedDipole1;\n"
"    dtorqueField2.z += r2*rr7k*uir;\n"
"\n"
"    // Get the field gradient for direct polarization force\n"
"\n"
"    real t1XX = valenceCharge1*rr3i + coreCharge1*rr3core + dir*rr5i - qxI.x*2*rr5i + qi.z*r*rr7i;\n"
"    real t2XX = valenceCharge2*rr3k + coreCharge2*rr3core - dkr*rr5k - qxK.x*2*rr5k + qk.z*r*rr7k;\n"
"    real t1YY = valenceCharge1*rr3i + coreCharge1*rr3core + dir*rr5i - qyI.y*2*rr5i + qi.z*r*rr7i;\n"
"    real t2YY = valenceCharge2*rr3k + coreCharge2*rr3core - dkr*rr5k - qyK.y*2*rr5k + qk.z*r*rr7k;\n"
"    real t1ZZ = valenceCharge1*(rr3i-rr5i*r2) + coreCharge1*(rr3core-rr5core*r2) + qiDipole1.z*2*rr5i*r -\n"
"              dir*(rr7i*r2-rr5i) - qzI.z*2*rr5i + qi.z*5*rr7i*r - qir*rr9i*r2;\n"
"    real t2ZZ = valenceCharge2*(rr3k-rr5k*r2) + coreCharge2*(rr3core-rr5core*r2) - qiDipole2.z*2*rr5k*r +\n"
"              dkr*(rr7k*r2-rr5k) - qzK.z*2*rr5k + qk.z*5*rr7k*r - qkr*rr9k*r2;\n"
"    real t1XY = -qxI.y*2*rr5i;\n"
"    real t2XY = -qxK.y*2*rr5k;\n"
"    real t1XZ = qiDipole1.x*rr5i*r - qxI.z*2*rr5i + qi.x*2*rr7i*r;\n"
"    real t2XZ = -qiDipole2.x*rr5k*r - qxK.z*2*rr5k + qk.x*2*rr7k*r;\n"
"    real t1YZ = qiDipole1.y*rr5i*r - qyI.z*2*rr5i + qi.y*2*rr7i*r;\n"
"    real t2YZ = -qiDipole2.y*rr5k*r - qyK.z*2*rr5k + qk.y*2*rr7k*r;\n"
"\n"
"    // Get the dEp/dR terms for chgpen direct polarization force.\n"
"\n"
"    real depx = t1XX*qiInducedDipole2.x + t1XY*qiInducedDipole2.y + t1XZ*qiInducedDipole2.z - t2XX*qiInducedDipole1.x - t2XY*qiInducedDipole1.y - t2XZ*qiInducedDipole1.z;\n"
"    real depy = t1XY*qiInducedDipole2.x + t1YY*qiInducedDipole2.y + t1YZ*qiInducedDipole2.z - t2XY*qiInducedDipole1.x - t2YY*qiInducedDipole1.y - t2YZ*qiInducedDipole1.z;\n"
"    real depz = t1XZ*qiInducedDipole2.x + t1YZ*qiInducedDipole2.y + t1ZZ*qiInducedDipole2.z - t2XZ*qiInducedDipole1.x - t2YZ*qiInducedDipole1.y - t2ZZ*qiInducedDipole1.z;\n"
"    real3 indForce = make_real3(depx, depy, depz);\n"
"\n"
"    // Torque is induced field and gradient cross permanent moments.\n"
"\n"
"    real3 tI = cross(torqueField1, qiDipole1);\n"
"    tI.x += -qxI.y*dtorqueField1.x - 2*qyI.z*dtorqueField1.z + (qzI.z-qyI.y)*dtorqueField1.y;\n"
"    tI.y += qxI.y*dtorqueField1.y + 2*qxI.z*dtorqueField1.z + (qxI.x-qzI.z)*dtorqueField1.x;\n"
"    tI.z += qyI.z*dtorqueField1.x - qxI.z*dtorqueField1.y;\n"
"    real3 tK = cross(torqueField2, qiDipole2);\n"
"    tK.x += -qxK.y*dtorqueField2.x - 2*qyK.z*dtorqueField2.z + (qzK.z-qyK.y)*dtorqueField2.y;\n"
"    tK.y += qxK.y*dtorqueField2.y + 2*qxK.z*dtorqueField2.z + (qxK.x-qzK.z)*dtorqueField2.x;\n"
"    tK.z += qyK.z*dtorqueField2.x - qxK.z*dtorqueField2.y;\n"
"    tempForce -= indForce;\n"
"    tempTorque1 += tI;\n"
"    tempTorque2 += tK;\n"
"\n"
"    // Get the dtau/dr terms used for OPT polarization force.\n"
"\n"
"    real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"    for (int j = 0; j < MAX_EXTRAPOLATION_ORDER-1; j++) {\n"
"        int ij = 3*(j*NUM_ATOMS+atom1);\n"
"        real3 extDipole1 = (atom1 < NUM_ATOMS ? make_real3(extrapolatedDipole[ij], extrapolatedDipole[ij+1], extrapolatedDipole[ij+2]) : make_real3(0));\n"
"        real uirm = dot(extDipole1, delta);\n"
"        for (int m = 0; m < MAX_EXTRAPOLATION_ORDER-1-j; m++) {\n"
"            int im = 3*(m*NUM_ATOMS+atom2);\n"
"            real3 extDipole2 = (atom2 < NUM_ATOMS ? make_real3(extrapolatedDipole[im], extrapolatedDipole[im+1], extrapolatedDipole[im+2]) : make_real3(0));\n"
"            real ukrm = dot(extDipole2, delta);\n"
"            real term1 = 2*rr5ik;\n"
"            real term2 = term1*delta.x;\n"
"            real term3 = rr5ik - rr7ik*delta.x*delta.x;\n"
"            real tixx = extDipole1.x*term2 + uirm*term3;\n"
"            real tkxx = extDipole2.x*term2 + ukrm*term3;\n"
"            term2 = term1*delta.y;\n"
"            term3 = rr5ik - rr7ik*delta.y*delta.y;\n"
"            real tiyy = extDipole1.y*term2 + uirm*term3;\n"
"            real tkyy = extDipole2.y*term2 + ukrm*term3;\n"
"            term2 = term1*delta.z;\n"
"            term3 = rr5ik - rr7ik*delta.z*delta.z;\n"
"            real tizz = extDipole1.z*term2 + uirm*term3;\n"
"            real tkzz = extDipole2.z*term2 + ukrm*term3;\n"
"            term1 = rr5ik*delta.y;\n"
"            term2 = rr5ik*delta.x;\n"
"            term3 = delta.y * (rr7ik*delta.x);\n"
"            real tixy = extDipole1.x*term1 + extDipole1.y*term2 - uirm*term3;\n"
"            real tkxy = extDipole2.x*term1 + extDipole2.y*term2 - ukrm*term3;\n"
"            term1 = rr5ik*delta.z;\n"
"            term3 = delta.z * (rr7ik*delta.x);\n"
"            real tixz = extDipole1.x*term1 + extDipole1.z*term2 - uirm*term3;\n"
"            real tkxz = extDipole2.x*term1 + extDipole2.z*term2 - ukrm*term3;\n"
"            term2 = rr5ik*delta.y;\n"
"            term3 = delta.z * (rr7ik*delta.y);\n"
"            real tiyz = extDipole1.y*term1 + extDipole1.z*term2 - uirm*term3;\n"
"            real tkyz = extDipole2.y*term1 + extDipole2.z*term2 - ukrm*term3;\n"
"            real depx = tixx*extDipole2.x + tkxx*extDipole1.x + tixy*extDipole2.y + tkxy*extDipole1.y + tixz*extDipole2.z + tkxz*extDipole1.z;\n"
"            real depy = tixy*extDipole2.x + tkxy*extDipole1.x + tiyy*extDipole2.y + tkyy*extDipole1.y + tiyz*extDipole2.z + tkyz*extDipole1.z;\n"
"            real depz = tixz*extDipole2.x + tkxz*extDipole1.x + tiyz*extDipole2.y + tkyz*extDipole1.y + tizz*extDipole2.z + tkzz*extDipole1.z;\n"
"            labForce += (coeff[j+m+1]/2)*make_real3(depx, depy, depz);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Compute the repulsion interaction.\n"
"\n"
"{\n"
"    // Compute damping coefficients.\n"
"\n"
"    real fdamp1, fdamp3, fdamp5, fdamp7, fdamp9, fdamp11;\n"
"    computeRepulsionDampingFactors(pauliAlpha1, pauliAlpha2, r, &fdamp1, &fdamp3, &fdamp5, &fdamp7, &fdamp9, &fdamp11);\n"
"\n"
"    // Calculate intermediate terms needed for the energy\n"
"\n"
"    real eterm1 = pauliQ1*pauliQ2;\n"
"    real eterm2 = pauliQ2*dir - pauliQ1*dkr + dik;\n"
"    real eterm3 = pauliQ1*qkr + pauliQ2*qir - dir*dkr + 2*(dkqi-diqk+qiqk);\n"
"    real eterm4 = dir*qkr - dkr*qir - 4*qik;\n"
"    real eterm5 = qir*qkr;\n"
"    real eterm = eterm1*fdamp1 + eterm2*fdamp3 + eterm3*fdamp5 + eterm4*fdamp7 + eterm5*fdamp9;\n"
"\n"
"    // Compute the energy.\n"
"\n"
"    real sizik = pauliK1*pauliK2;\n"
"#ifdef COMPUTING_EXCEPTIONS\n"
"    sizik *= repulsionScale;\n"
"#endif\n"
"    real repEnergy = sizik*eterm*rr1;\n"
"\n"
"    // Calculate intermediate terms for force and torque\n"
"\n"
"    real de = eterm1*fdamp3 + eterm2*fdamp5 + eterm3*fdamp7 + eterm4*fdamp9 + eterm5*fdamp11;\n"
"    real term1 = -pauliQ2*fdamp3 + dkr*fdamp5 - qkr*fdamp7;\n"
"    real term2 = pauliQ1*fdamp3 + dir*fdamp5 + qir*fdamp7;\n"
"    real term3 = 2*fdamp5;\n"
"    real term4 = 2*(-pauliQ2*fdamp5 + dkr*fdamp7 - qkr*fdamp9);\n"
"    real term5 = 2*(-pauliQ1*fdamp5 - dir*fdamp7 - qir*fdamp9);\n"
"    real term6 = 4*fdamp7;\n"
"\n"
"    // Compute the force and torque.\n"
"\n"
"    real3 repForce = make_real3(0, 0, de*r) + term1*qiDipole1 + term2*qiDipole2 + term3*(diqkTemp-dkqiTemp)\n"
"            + term4*qi + term5*qk + term6*(qikTemp+qkiTemp);\n"
"    repForce = -sizik*(repForce*rr1 + make_real3(0, 0, eterm*rr3*r));\n"
"    real3 tI = -fdamp3*dikCross + term1*dirCross + term3*(dqik+dkqirCross) + term4*qirCross - term6*(qikrCross+qikCross);\n"
"    real3 tK = fdamp3*dikCross + term2*dkrCross - term3*(dqik+diqkrCross) + term5*qkrCross - term6*(qkirCross-qikCross);\n"
"    tI *= sizik*rr1;\n"
"    tK *= sizik*rr1;\n"
"#ifdef USE_CUTOFF\n"
"    if (r > SWITCH_CUTOFF) {\n"
"        real x = r-SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(SWITCH_C3+x*(SWITCH_C4+x*SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*SWITCH_C3+x*(4*SWITCH_C4+x*5*SWITCH_C5));\n"
"        repForce *= switchValue;\n"
"        repForce.z += repEnergy*switchDeriv;\n"
"        repEnergy *= switchValue;\n"
"        tI *= switchValue;\n"
"        tK *= switchValue;\n"
"    }\n"
"#endif\n"
"    tempEnergy += repEnergy;\n"
"    tempForce += repForce;\n"
"    tempTorque1 += tI;\n"
"    tempTorque2 += tK;\n"
"}\n"
"\n"
"// Compute the dispersion force and energy.\n"
"\n"
"{\n"
"    real rInv6 = rInv2*rInv2*rInv2;\n"
"#ifndef COMPUTING_EXCEPTIONS\n"
"    real dispersionScale = 1;\n"
"#endif\n"
"    real fdamp, ddamp;\n"
"    computeDispersionDampingFactors(alpha1, alpha2, r, &fdamp, &ddamp);\n"
"#if USE_EWALD\n"
"    real ralpha2 = r2*DPME_ALPHA*DPME_ALPHA;\n"
"    real ralpha4 = ralpha2*ralpha2;\n"
"    real expterm = EXP(-ralpha2);\n"
"    real expa = expterm * (1 + ralpha2 + ralpha4/2);\n"
"    real scale = dispersionScale*fdamp*fdamp - 1;\n"
"    real cick = c61*c62;\n"
"    real dispEnergy = -cick*(expa+scale)*rInv6;\n"
"    real rterm = -ralpha2*ralpha4*expterm*rInv;\n"
"    real dispForce = -6*dispEnergy*rInv - cick*rInv6*(rterm + 2*dispersionScale*fdamp*ddamp);\n"
"#else\n"
"    real dispEnergy = -dispersionScale*c61*c62*rInv6;\n"
"    real dispForce = -6*dispEnergy*rInv;\n"
"    dispForce = dispForce*fdamp*fdamp + 2*dispEnergy*fdamp*ddamp;\n"
"    dispEnergy *= fdamp*fdamp;\n"
"#endif\n"
"    tempEnergy += dispEnergy;\n"
"    tempForce.z += dispForce;\n"
"}\n"
"\n"
"// Compute the charge transfer force and energy.\n"
"\n"
"{\n"
"    real term1 = epsilon1*EXP(-damping2*r);\n"
"    real term2 = epsilon2*EXP(-damping1*r);\n"
"    real ctEnergy = -(term1+term2);\n"
"    real ctForce = (term1*damping2 + term2*damping1)*rInv;\n"
"#ifdef USE_CUTOFF\n"
"    if (r > SWITCH_CUTOFF) {\n"
"        real x = r-SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(SWITCH_C3+x*(SWITCH_C4+x*SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*SWITCH_C3+x*(4*SWITCH_C4+x*5*SWITCH_C5));\n"
"        ctForce = ctForce*switchValue - ctEnergy*switchDeriv*r;\n"
"        ctEnergy *= switchValue;\n"
"    }\n"
"#endif\n"
"#ifdef COMPUTING_EXCEPTIONS\n"
"    ctForce *= chargeTransferScale;\n"
"    ctEnergy *= chargeTransferScale;\n"
"#endif\n"
"    tempEnergy += ctEnergy;\n"
"    tempForce.z += ctForce*r;\n"
"}\n"
"\n"
"// Rotate back to the lab frame.\n"
"\n"
"if (includeInteraction) {\n"
"    tempForce = rotateVectorFromQI(tempForce, mat) - labForce;\n"
"    tempTorque1 = rotateVectorFromQI(tempTorque1, mat);\n"
"    tempTorque2 = rotateVectorFromQI(tempTorque2, mat);\n"
"}\n"
"else {\n"
"    tempEnergy = 0;\n"
"    tempForce = make_real3(0);\n"
"    tempTorque1 = make_real3(0);\n"
"    tempTorque2 = make_real3(0);\n"
"}\n"
"";
const string CommonAmoebaKernelSources::hippoInteractionHeader = "// Functions that are called from hippoInteraction.cu.\n"
"\n"
"DEVICE void formQIRotationMatrix(real3 deltaR, real rInv, real rotationMatrix[3][3]) {\n"
"    real3 vectorZ = deltaR*rInv;\n"
"    real3 vectorX = make_real3(0);\n"
"    if (fabs(vectorZ.y) > fabs(vectorZ.x))\n"
"        vectorX.x = 1;\n"
"    else\n"
"        vectorX.y = 1;\n"
"\n"
"    vectorX -= vectorZ*dot(vectorZ, vectorX);\n"
"    vectorX = normalize(vectorX);\n"
"    real3 vectorY = cross(vectorZ, vectorX);\n"
"\n"
"    rotationMatrix[0][0] = vectorX.x;\n"
"    rotationMatrix[0][1] = vectorX.y;\n"
"    rotationMatrix[0][2] = vectorX.z;\n"
"    rotationMatrix[1][0] = vectorY.x;\n"
"    rotationMatrix[1][1] = vectorY.y;\n"
"    rotationMatrix[1][2] = vectorY.z;\n"
"    rotationMatrix[2][0] = vectorZ.x;\n"
"    rotationMatrix[2][1] = vectorZ.y;\n"
"    rotationMatrix[2][2] = vectorZ.z;\n"
"}\n"
"\n"
"DEVICE real3 rotateVectorToQI(real3 v, const real mat[3][3]) {\n"
"    return make_real3(mat[0][0]*v.x + mat[0][1]*v.y + mat[0][2]*v.z,\n"
"                      mat[1][0]*v.x + mat[1][1]*v.y + mat[1][2]*v.z,\n"
"                      mat[2][0]*v.x + mat[2][1]*v.y + mat[2][2]*v.z);\n"
"}\n"
"\n"
"DEVICE real3 rotateVectorFromQI(real3 v, const real mat[3][3]) {\n"
"    return make_real3(mat[0][0]*v.x + mat[1][0]*v.y + mat[2][0]*v.z,\n"
"                      mat[0][1]*v.x + mat[1][1]*v.y + mat[2][1]*v.z,\n"
"                      mat[0][2]*v.x + mat[1][2]*v.y + mat[2][2]*v.z);\n"
"}\n"
"\n"
"DEVICE void rotateQuadrupoleToQI(real qXX, real qXY, real qXZ, real qYY, real qYZ, \n"
"            real* qiQXX, real* qiQXY, real* qiQXZ, real* qiQYY, real* qiQYZ, real* qiQZZ, const real mat[3][3]) {\n"
"    real qZZ = -qXX-qYY;\n"
"    *qiQXX = mat[0][0]*(mat[0][0]*qXX + 2*(mat[0][1]*qXY + mat[0][2]*qXZ)) + mat[0][1]*(mat[0][1]*qYY + 2*mat[0][2]*qYZ) + mat[0][2]*mat[0][2]*qZZ;\n"
"    *qiQYY = mat[1][0]*(mat[1][0]*qXX + 2*(mat[1][1]*qXY + mat[1][2]*qXZ)) + mat[1][1]*(mat[1][1]*qYY + 2*mat[1][2]*qYZ) + mat[1][2]*mat[1][2]*qZZ;\n"
"    *qiQXY = mat[0][0]*mat[1][0]*qXX + mat[0][1]*mat[1][1]*qYY + mat[0][2]*mat[1][2]*qZZ + (mat[0][0]*mat[1][1] + mat[0][1]*mat[1][0])*qXY + (mat[0][0]*mat[1][2] + mat[0][2]*mat[1][0])*qXZ + (mat[0][1]*mat[1][2] + mat[0][2]*mat[1][1])*qYZ;\n"
"    *qiQXZ = mat[0][0]*mat[2][0]*qXX + mat[0][1]*mat[2][1]*qYY + mat[0][2]*mat[2][2]*qZZ + (mat[0][0]*mat[2][1] + mat[0][1]*mat[2][0])*qXY + (mat[0][0]*mat[2][2] + mat[0][2]*mat[2][0])*qXZ + (mat[0][1]*mat[2][2] + mat[0][2]*mat[2][1])*qYZ;\n"
"    *qiQYZ = mat[1][0]*mat[2][0]*qXX + mat[1][1]*mat[2][1]*qYY + mat[1][2]*mat[2][2]*qZZ + (mat[1][0]*mat[2][1] + mat[1][1]*mat[2][0])*qXY + (mat[1][0]*mat[2][2] + mat[1][2]*mat[2][0])*qXZ + (mat[1][1]*mat[2][2] + mat[1][2]*mat[2][1])*qYZ;\n"
"    *qiQZZ = -*qiQXX-*qiQYY;\n"
"}\n"
"\n"
"DEVICE void computeOverlapDampingFactors(real alphaI, real alphaJ, real r,\n"
"                                  real* fdampI1, real* fdampI3, real* fdampI5, real* fdampI7, real* fdampI9,\n"
"                                  real* fdampJ1, real* fdampJ3, real* fdampJ5, real* fdampJ7, real* fdampJ9,\n"
"                                  real* fdampIJ1, real* fdampIJ3, real* fdampIJ5, real* fdampIJ7, real* fdampIJ9, real* fdampIJ11) {\n"
"    real arI = alphaI*r;\n"
"    real arI2 = arI*arI;\n"
"    real arI3 = arI2*arI;\n"
"    real arI4 = arI2*arI2;\n"
"    real arI5 = arI3*arI2;\n"
"    real arI6 = arI3*arI3;\n"
"    real expARI = EXP(-arI);\n"
"    real one = 1;\n"
"    real two = 2;\n"
"    real three = 3;\n"
"    real four = 4;\n"
"    real five = 5;\n"
"    real seven = 7;\n"
"    real eleven = 11;\n"
"    *fdampI1 = 1 - (1 + arI*(one/2))*expARI;\n"
"    *fdampI3 = 1 - (1 + arI + arI2*(one/2))*expARI;\n"
"    *fdampI5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6))*expARI;\n"
"    *fdampI7 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/30))*expARI;\n"
"    *fdampI9 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(four/105) + arI5*(one/210))*expARI;\n"
"    if (alphaI == alphaJ) {\n"
"        *fdampJ1 = *fdampI1;\n"
"        *fdampJ3 = *fdampI3;\n"
"        *fdampJ5 = *fdampI5;\n"
"        *fdampJ7 = *fdampI7;\n"
"        *fdampJ9 = *fdampI9;\n"
"        real arI7 = arI4*arI3;\n"
"        real arI8 = arI4*arI4;\n"
"        *fdampIJ1 = 1 - (1 + arI*(eleven/16) + arI2*(three/16) + arI3*(one/48))*expARI;\n"
"        *fdampIJ3 = 1 - (1 + arI + arI2*(one/2) + arI3*(seven/48) + arI4*(one/48))*expARI;\n"
"        *fdampIJ5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/144))*expARI;\n"
"        *fdampIJ7 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/120) + arI6*(one/720))*expARI;\n"
"        *fdampIJ9 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/120) + arI6*(one/720) + arI7*(one/5040))*expARI;\n"
"        *fdampIJ11 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/120) + arI6*(one/720) + arI7*(one/5040) + arI8*(one/45360))*expARI;\n"
"    }\n"
"    else {\n"
"        real arJ = alphaJ*r;\n"
"        real arJ2 = arJ*arJ;\n"
"        real arJ3 = arJ2*arJ;\n"
"        real arJ4 = arJ2*arJ2;\n"
"        real arJ5 = arJ3*arJ2;\n"
"        real arJ6 = arJ3*arJ3;\n"
"        real expARJ = EXP(-arJ);\n"
"        real aI2 = alphaI*alphaI;\n"
"        real aJ2 = alphaJ*alphaJ;\n"
"        real A = aJ2/(aJ2-aI2);\n"
"        real B = aI2/(aI2-aJ2);\n"
"        real A2expARI = A*A*expARI;\n"
"        real B2expARJ = B*B*expARJ;\n"
"        *fdampJ1 = 1 - (1 + arJ*(one/2))*expARJ;\n"
"        *fdampJ3 = 1 - (1 + arJ + arJ2*(one/2))*expARJ;\n"
"        *fdampJ5 = 1 - (1 + arJ + arJ2*(one/2) + arJ3*(one/6))*expARJ;\n"
"        *fdampJ7 = 1 - (1 + arJ + arJ2*(one/2) + arJ3*(one/6) + arJ4*(one/30))*expARJ;\n"
"        *fdampJ9 = 1 - (1 + arJ + arJ2*(one/2) + arJ3*(one/6) + 4*arJ4*(one/105) + arJ5*(one/210))*expARJ;\n"
"        *fdampIJ1 = 1 - (1 + 2*B + arI*(one/2))*A2expARI -\n"
"                        (1 + 2*A + arJ*(one/2))*B2expARJ;\n"
"        *fdampIJ3 = 1 - (1 + arI + arI2*(one/2))*A2expARI -\n"
"                        (1 + arJ + arJ2*(one/2))*B2expARJ -\n"
"                        (1 + arI)*2*B*A2expARI -\n"
"                        (1 + arJ)*2*A*B2expARJ;\n"
"        *fdampIJ5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6))*A2expARI -\n"
"                        (1 + arJ + arJ2*(one/2) + arJ3*(one/6))*B2expARJ -\n"
"                        (1 + arI + arI2*(one/3))*2*B*A2expARI -\n"
"                        (1 + arJ + arJ2*(one/3))*2*A*B2expARJ;\n"
"        *fdampIJ7 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/30))*A2expARI -\n"
"                        (1 + arJ + arJ2*(one/2) + arJ3*(one/6) + arJ4*(one/30))*B2expARJ -\n"
"                        (1 + arI + arI2*(two/5) + arI3*(one/15))*2*B*A2expARI -\n"
"                        (1 + arJ + arJ2*(two/5) + arJ3*(one/15))*2*A*B2expARJ;\n"
"        *fdampIJ9 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*4*(one/105) + arI5*(one/210))*A2expARI -\n"
"                        (1 + arJ + arJ2*(one/2) + arJ3*(one/6) + arJ4*4*(one/105) + arJ5*(one/210))*B2expARJ -\n"
"                        (1 + arI + arI2*(three/7) + arI3*(two/21) + arI4*(one/105))*2*B*A2expARI -\n"
"                        (1 + arJ + arJ2*(three/7) + arJ3*(two/21) + arJ4*(one/105))*2*A*B2expARJ;\n"
"        *fdampIJ11 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(five/126) + arI5*(two/315) + arI6*(one/1890))*A2expARI -\n"
"                         (1 + arJ + arJ2*(one/2) + arJ3*(one/6) + arJ4*(five/126) + arJ5*(two/315) + arJ6*(one/1890))*B2expARJ -\n"
"                         (1 + arI + arI2*(four/9) + arI3*(one/9) + arI4*(one/63) + arI5*(one/945))*2*B*A2expARI -\n"
"                         (1 + arJ + arJ2*(four/9) + arJ3*(one/9) + arJ4*(one/63) + arJ5*(one/945))*2*A*B2expARJ;\n"
"    }\n"
"}\n"
"\n"
"DEVICE void computeDispersionDampingFactors(real alphaI, real alphaJ, real r, real* fdamp, real* ddamp) {\n"
"    real arI = alphaI*r;\n"
"    real arI2 = arI*arI;\n"
"    real arI3 = arI2*arI;\n"
"    real expARI = EXP(-arI);\n"
"    real fdamp3, fdamp5;\n"
"    real one = 1;\n"
"    real seven = 7;\n"
"    if (alphaI == alphaJ) {\n"
"        real arI4 = arI3*arI;\n"
"        real arI5 = arI4*arI;\n"
"        fdamp3 = 1 - (1 + arI + arI2*(one/2) + arI3*(seven/48) + arI4*(one/48))*expARI;\n"
"        fdamp5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6) + arI4*(one/24) + arI5*(one/144))*expARI;\n"
"        *ddamp = alphaI*(arI5 - 3*arI3 - 3*arI2)*expARI*(one/96);\n"
"    }\n"
"    else {\n"
"        real arJ = alphaJ*r;\n"
"        real arJ2 = arJ*arJ;\n"
"        real arJ3 = arJ2*arJ;\n"
"        real expARJ = EXP(-arJ);\n"
"        real aI2 = alphaI*alphaI;\n"
"        real aJ2 = alphaJ*alphaJ;\n"
"        real A = aJ2/(aJ2-aI2);\n"
"        real B = aI2/(aI2-aJ2);\n"
"        real A2expARI = A*A*expARI;\n"
"        real B2expARJ = B*B*expARJ;\n"
"        fdamp3 = 1 - (1 + arI + arI2*(one/2))*A2expARI -\n"
"                     (1 + arJ + arJ2*(one/2))*B2expARJ -\n"
"                     (1 + arI)*2*B*A2expARI -\n"
"                     (1 + arJ)*2*A*B2expARJ;\n"
"        fdamp5 = 1 - (1 + arI + arI2*(one/2) + arI3*(one/6))*A2expARI -\n"
"                     (1 + arJ + arJ2*(one/2) + arJ3*(one/6))*B2expARJ -\n"
"                     (1 + arI + arI2*(one/3))*2*B*A2expARI -\n"
"                     (1 + arJ + arJ2*(one/3))*2*A*B2expARJ;\n"
"        *ddamp = (arI2*alphaI*A2expARI*(r*alphaI + 4*B - 1) +\n"
"                 (arJ2*alphaJ*B2expARJ*(r*alphaJ + 4*A - 1)))*(one/4);\n"
"    }\n"
"    *fdamp = 1.5f*fdamp5 - 0.5f*fdamp3;\n"
"}\n"
"\n"
"DEVICE void computeRepulsionDampingFactors(real pauliAlphaI, real pauliAlphaJ, real r,\n"
"            real* fdamp1, real* fdamp3, real* fdamp5, real* fdamp7, real* fdamp9, real* fdamp11) {\n"
"    real r2 = r*r;\n"
"    real r3 = r2*r;\n"
"    real r4 = r2*r2;\n"
"    real r5 = r3*r2;\n"
"    real r6 = r3*r3;\n"
"    real aI2 = 0.5f*pauliAlphaI;\n"
"    real arI2 = aI2*r;\n"
"    real expI = EXP(-arI2);\n"
"    real aI2_2 = aI2*aI2;\n"
"    real aI2_3 = aI2_2*aI2;\n"
"    real aI2_4 = aI2_2*aI2_2;\n"
"    real aI2_5 = aI2_3*aI2_2;\n"
"    real aI2_6 = aI2_3*aI2_3;\n"
"    real fexp, fexp1, fexp2, fexp3, fexp4, fexp5, pre;\n"
"    real one = 1;\n"
"    real two = 2;\n"
"    real four = 4;\n"
"    real eight = 8;\n"
"    real twelve = 12;\n"
"    real sixteen = 16;\n"
"    if (pauliAlphaI == pauliAlphaJ) {\n"
"        real r7 = r4*r3;\n"
"        real r8 = r4*r4;\n"
"        real aI2_7 = aI2_4*aI2_3;\n"
"        pre = 128;\n"
"        fexp = (r + aI2*r2 + aI2_2*r3*(one/3))*expI;\n"
"        fexp1 = (aI2_2*r3 + aI2_3*r4)*expI*(one/3);\n"
"        fexp2 = aI2_4*expI*r5*(one/9);\n"
"        fexp3 = aI2_5*expI*r6*(one/45);\n"
"        fexp4 = (aI2_5*r6 + aI2_6*r7)*expI*(one/315);\n"
"        fexp5 = (aI2_5*r6 + aI2_6*r7 + aI2_7*r8*(one/3))*expI*(one/945);\n"
"    }\n"
"    else {\n"
"        real aJ2 = 0.5f*pauliAlphaJ;\n"
"        real arJ2 = aJ2*r;\n"
"        real expJ = EXP(-arJ2);\n"
"        real aJ2_2 = aJ2*aJ2;\n"
"        real aJ2_3 = aJ2_2*aJ2;\n"
"        real aJ2_4 = aJ2_2*aJ2_2;\n"
"        real aJ2_5 = aJ2_3*aJ2_2;\n"
"        real scale = 1/(aI2_2-aJ2_2);\n"
"        real aI2aJ2expI = aI2*aJ2*expI;\n"
"        real aI2aJ2expJ = aI2*aJ2*expJ;\n"
"        pre = 8192*aI2_3*aJ2_3*(scale*scale*scale*scale);\n"
"        real tmp = 4*aI2*aJ2*scale;\n"
"        fexp = (arI2-tmp)*expJ + (arJ2+tmp)*expI;\n"
"        fexp1 = (r2 - (4*aJ2*r + 4)*scale)*aI2aJ2expJ +\n"
"                (r2 + (4*aI2*r + 4)*scale)*aI2aJ2expI;\n"
"        fexp2 = (r2*(one/3) + aJ2*r3*(one/3) - ((four/3)*aJ2_2*r2 + 4*aJ2*r + 4)*scale)*aI2aJ2expJ +\n"
"                (r2*(one/3) + aI2*r3*(one/3) + ((four/3)*aI2_2*r2 + 4*aI2*r + 4)*scale)*aI2aJ2expI;\n"
"        fexp3 = (aJ2_2*r4*(one/15) + aJ2*r3*(one/5) + r2*(one/5) - ((four/15)*aJ2_3*r3 + (eight/5)*aJ2_2*r2 + 4*aJ2*r + 4)*scale)*aI2aJ2expJ +\n"
"                (aI2_2*r4*(one/15) + aI2*r3*(one/5) + r2*(one/5) + ((four/15)*aI2_3*r3 + (eight/5)*aI2_2*r2 + 4*aI2*r + 4)*scale)*aI2aJ2expI;\n"
"        fexp4 = (aJ2_3*r5*(one/105) + (two/35)*aJ2_2*r4 + aJ2*r3*(one/7) + r2*(one/7) - ((four/105)*aJ2_4*r4 + (eight/21)*aJ2_3*r3 + (twelve/7)*aJ2_2*r2 + 4*aJ2*r + 4)*scale)*aI2aJ2expJ +\n"
"                (aI2_3*r5*(one/105) + (two/35)*aI2_2*r4 + aI2*r3*(one/7) + r2*(one/7) + ((four/105)*aI2_4*r4 + (eight/21)*aI2_3*r3 + (twelve/7)*aI2_2*r2 + 4*aI2*r + 4)*scale)*aI2aJ2expI;\n"
"        fexp5 = (aJ2_4*r6*(one/945) + (two/189)*aJ2_3*r5 + aJ2_2*r4*(one/21) + aJ2*r3*(one/9) + r2*(one/9) - ((four/945)*aJ2_5*r5 + (four/63)*aJ2_4*r4 + (four/9)*aJ2_3*r3 + (sixteen/9)*aJ2_2*r2 + 4*aJ2*r + 4)*scale)*aI2aJ2expJ +\n"
"                (aI2_4*r6*(one/945) + (two/189)*aI2_3*r5 + aI2_2*r4*(one/21) + aI2*r3*(one/9) + r2*(one/9) + ((four/945)*aI2_5*r5 + (four/63)*aI2_4*r4 + (four/9)*aI2_3*r3 + (sixteen/9)*aI2_2*r2 + 4*aI2*r + 4)*scale)*aI2aJ2expI;\n"
"    }\n"
"    fexp = fexp/r;\n"
"    fexp1 = fexp1/r3;\n"
"    fexp2 = 3*fexp2/r5;\n"
"    fexp3 = 15*fexp3/(r5*r2);\n"
"    fexp4 = 105*fexp4/(r5*r4);\n"
"    fexp5 = 945*fexp5/(r5*r6);\n"
"    *fdamp1 = 0.5f*pre*fexp*fexp;\n"
"    *fdamp3 = pre*fexp*fexp1;\n"
"    *fdamp5 = pre*(fexp*fexp2 + fexp1*fexp1);\n"
"    *fdamp7 = pre*(fexp*fexp3 + 3*fexp1*fexp2);\n"
"    *fdamp9 = pre*(fexp*fexp4 + 4*fexp1*fexp3 + 3*fexp2*fexp2);\n"
"    *fdamp11 = pre*(fexp*fexp5 + 5*fexp1*fexp4 + 10*fexp2*fexp3);\n"
"}\n"
"\n"
"";
const string CommonAmoebaKernelSources::hippoMultipoles = "KERNEL void computeLabFrameMoments(GLOBAL real4* RESTRICT posq, GLOBAL int4* RESTRICT multipoleParticles, GLOBAL real* RESTRICT localDipoles,\n"
"        GLOBAL real* RESTRICT localQuadrupoles, GLOBAL real* RESTRICT labDipoles, GLOBAL real* RESTRICT labQXX, GLOBAL real* RESTRICT labQXY, GLOBAL real* RESTRICT labQXZ,\n"
"        GLOBAL real* RESTRICT labQYY, GLOBAL real* RESTRICT labQYZ) {\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        int4 particles = multipoleParticles[atom];\n"
"        if (particles.z >= 0) {\n"
"            real4 thisParticlePos = posq[atom];\n"
"            real4 posZ = posq[particles.z];\n"
"            real3 vectorZ = normalize(make_real3(posZ.x-thisParticlePos.x, posZ.y-thisParticlePos.y, posZ.z-thisParticlePos.z));\n"
"            int axisType = particles.w; \n"
"            real4 posX;\n"
"            real3 vectorX;\n"
"            if (axisType >= 4) {\n"
"                if (fabs(vectorZ.x) < 0.866)\n"
"                    vectorX = make_real3(1, 0, 0);\n"
"                else\n"
"                    vectorX = make_real3(0, 1, 0);\n"
"            }\n"
"            else {\n"
"                posX = posq[particles.x];\n"
"                vectorX = make_real3(posX.x-thisParticlePos.x, posX.y-thisParticlePos.y, posX.z-thisParticlePos.z);\n"
"            }\n"
"        \n"
"            // branch based on axis type\n"
"                    \n"
"            if (axisType == 1) {\n"
"        \n"
"                // bisector\n"
"                \n"
"                vectorX = normalize(vectorX);\n"
"                vectorZ += vectorX;\n"
"                vectorZ = normalize(vectorZ);\n"
"            }\n"
"            else if (axisType == 2 || axisType == 3) { \n"
"         \n"
"                // z-bisect\n"
"        \n"
"                if (particles.y >= 0 && particles.y < NUM_ATOMS) {\n"
"                    real4 posY = posq[particles.y];\n"
"                    real3 vectorY = make_real3(posY.x-thisParticlePos.x, posY.y-thisParticlePos.y, posY.z-thisParticlePos.z);\n"
"                    vectorY = normalize(vectorY);\n"
"                    vectorX = normalize(vectorX);\n"
"                    if (axisType == 2) {\n"
"                        vectorX += vectorY;\n"
"                        vectorX = normalize(vectorX);\n"
"                    }\n"
"                    else { \n"
"             \n"
"                        // 3-fold\n"
"                \n"
"                        vectorZ += vectorX + vectorY;\n"
"                        vectorZ = normalize(vectorZ);\n"
"                    }\n"
"                }\n"
"         \n"
"            }\n"
"            \n"
"            // x = x - (x.z)z\n"
"        \n"
"            vectorX -= dot(vectorZ, vectorX)*vectorZ;\n"
"            vectorX = normalize(vectorX);\n"
"            real3 vectorY = cross(vectorZ, vectorX);\n"
"         \n"
"            // use identity rotation matrix for unrecognized axis types\n"
"        \n"
"            if (axisType < 0 || axisType > 4) {\n"
"        \n"
"                vectorX.x = 1;\n"
"                vectorX.y = 0;\n"
"                vectorX.z = 0;\n"
"        \n"
"                vectorY.x = 0;\n"
"                vectorY.y = 1;\n"
"                vectorY.z = 0;\n"
"        \n"
"                vectorZ.x = 0;\n"
"                vectorZ.y = 0;\n"
"                vectorZ.z = 1;\n"
"            }\n"
"            \n"
"            // Check the chirality and see whether it needs to be reversed\n"
"            \n"
"            bool reverse = false;\n"
"            if (axisType == 0 && particles.x >= 0 && particles.y >=0 && particles.z >= 0) {\n"
"                real4 posY = posq[particles.y];\n"
"                real delta[4][3];\n"
"\n"
"                delta[0][0] = thisParticlePos.x - posY.x;\n"
"                delta[0][1] = thisParticlePos.y - posY.y;\n"
"                delta[0][2] = thisParticlePos.z - posY.z;\n"
"\n"
"                delta[1][0] = posZ.x - posY.x;\n"
"                delta[1][1] = posZ.y - posY.y;\n"
"                delta[1][2] = posZ.z - posY.z;\n"
"\n"
"                delta[2][0] = posX.x - posY.x;\n"
"                delta[2][1] = posX.y - posY.y;\n"
"                delta[2][2] = posX.z - posY.z;\n"
"\n"
"                delta[3][0] = delta[1][1]*delta[2][2] - delta[1][2]*delta[2][1];\n"
"                delta[3][1] = delta[2][1]*delta[0][2] - delta[2][2]*delta[0][1];\n"
"                delta[3][2] = delta[0][1]*delta[1][2] - delta[0][2]*delta[1][1];\n"
"\n"
"                real volume = delta[3][0]*delta[0][0] + delta[3][1]*delta[1][0] + delta[3][2]*delta[2][0];\n"
"                reverse = (volume < 0);\n"
"            }\n"
"        \n"
"            // Transform the dipole\n"
"            \n"
"            real3 dipole = make_real3(localDipoles[3*atom], localDipoles[3*atom+1], localDipoles[3*atom+2]);\n"
"            if (reverse)\n"
"                dipole.y *= -1;\n"
"            labDipoles[3*atom] = dipole.x*vectorX.x + dipole.y*vectorY.x + dipole.z*vectorZ.x;\n"
"            labDipoles[3*atom+1] = dipole.x*vectorX.y + dipole.y*vectorY.y + dipole.z*vectorZ.y;\n"
"            labDipoles[3*atom+2] = dipole.x*vectorX.z + dipole.y*vectorY.z + dipole.z*vectorZ.z;\n"
"            \n"
"            // Transform the quadrupole\n"
"            \n"
"            real mPoleXX = localQuadrupoles[5*atom];\n"
"            real mPoleXY = localQuadrupoles[5*atom+1];\n"
"            real mPoleXZ = localQuadrupoles[5*atom+2];\n"
"            real mPoleYY = localQuadrupoles[5*atom+3];\n"
"            real mPoleYZ = localQuadrupoles[5*atom+4];\n"
"            real mPoleZZ = -(mPoleXX+mPoleYY);\n"
"        \n"
"            if (reverse) {\n"
"                mPoleXY *= -1;\n"
"                mPoleYZ *= -1;\n"
"            }\n"
"            \n"
"            labQXX[atom] = vectorX.x*(vectorX.x*mPoleXX + vectorY.x*mPoleXY + vectorZ.x*mPoleXZ)\n"
"                         + vectorY.x*(vectorX.x*mPoleXY + vectorY.x*mPoleYY + vectorZ.x*mPoleYZ)\n"
"                         + vectorZ.x*(vectorX.x*mPoleXZ + vectorY.x*mPoleYZ + vectorZ.x*mPoleZZ);\n"
"            labQXY[atom] = vectorX.x*(vectorX.y*mPoleXX + vectorY.y*mPoleXY + vectorZ.y*mPoleXZ)\n"
"                         + vectorY.x*(vectorX.y*mPoleXY + vectorY.y*mPoleYY + vectorZ.y*mPoleYZ)\n"
"                         + vectorZ.x*(vectorX.y*mPoleXZ + vectorY.y*mPoleYZ + vectorZ.y*mPoleZZ);\n"
"            labQXZ[atom] = vectorX.x*(vectorX.z*mPoleXX + vectorY.z*mPoleXY + vectorZ.z*mPoleXZ)\n"
"                         + vectorY.x*(vectorX.z*mPoleXY + vectorY.z*mPoleYY + vectorZ.z*mPoleYZ)\n"
"                         + vectorZ.x*(vectorX.z*mPoleXZ + vectorY.z*mPoleYZ + vectorZ.z*mPoleZZ);\n"
"            labQYY[atom] = vectorX.y*(vectorX.y*mPoleXX + vectorY.y*mPoleXY + vectorZ.y*mPoleXZ)\n"
"                         + vectorY.y*(vectorX.y*mPoleXY + vectorY.y*mPoleYY + vectorZ.y*mPoleYZ)\n"
"                         + vectorZ.y*(vectorX.y*mPoleXZ + vectorY.y*mPoleYZ + vectorZ.y*mPoleZZ);\n"
"            labQYZ[atom] = vectorX.y*(vectorX.z*mPoleXX + vectorY.z*mPoleXY + vectorZ.z*mPoleXZ)\n"
"                         + vectorY.y*(vectorX.z*mPoleXY + vectorY.z*mPoleYY + vectorZ.z*mPoleYZ)\n"
"                         + vectorZ.y*(vectorX.z*mPoleXZ + vectorY.z*mPoleYZ + vectorZ.z*mPoleZZ);\n"
"        }\n"
"        else {\n"
"            labDipoles[3*atom] = localDipoles[3*atom];\n"
"            labDipoles[3*atom+1] = localDipoles[3*atom+1];\n"
"            labDipoles[3*atom+2] = localDipoles[3*atom+2];\n"
"            labQXX[atom] = localQuadrupoles[5*atom];\n"
"            labQXY[atom] = localQuadrupoles[5*atom+1];\n"
"            labQXZ[atom] = localQuadrupoles[5*atom+2];\n"
"            labQYY[atom] = localQuadrupoles[5*atom+3];\n"
"            labQYZ[atom] = localQuadrupoles[5*atom+4];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void recordInducedDipoles(GLOBAL const mm_long* RESTRICT fieldBuffers, GLOBAL real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT polarizability) {\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real scale = polarizability[atom]/(real) 0x100000000;\n"
"        inducedDipole[3*atom] = scale*fieldBuffers[atom];\n"
"        inducedDipole[3*atom+1] = scale*fieldBuffers[atom+PADDED_NUM_ATOMS];\n"
"        inducedDipole[3*atom+2] = scale*fieldBuffers[atom+PADDED_NUM_ATOMS*2];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Normalize a vector and return what its magnitude was.\n"
" */\n"
"inline DEVICE real normVector(real3* v) {\n"
"    real n = SQRT(dot(*v, *v));\n"
"    *v *= (n > 0 ? RECIP(n) : 0);\n"
"    return n;\n"
"}\n"
"\n"
"/**\n"
" * Compute the force on each particle due to the torque.\n"
" */\n"
"KERNEL void mapTorqueToForce(GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL const mm_long* RESTRICT torqueBuffers,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT multipoleParticles) {\n"
"    const int U = 0;\n"
"    const int V = 1;\n"
"    const int W = 2;\n"
"    const int R = 3;\n"
"    const int S = 4;\n"
"    const int UV = 5;\n"
"    const int UW = 6;\n"
"    const int VW = 7;\n"
"    const int UR = 8;\n"
"    const int US = 9;\n"
"    const int VS = 10;\n"
"    const int WS = 11;\n"
"    \n"
"    const int X = 0;\n"
"    const int Y = 1;\n"
"    const int Z = 2;\n"
"    const int I = 3;\n"
"    \n"
"    const real torqueScale = RECIP((double) 0x100000000);\n"
"    \n"
"    real3 forces[4];\n"
"    real norms[12];\n"
"    real3 vector[12];\n"
"    real angles[12][2];\n"
"  \n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        int4 particles = multipoleParticles[atom];\n"
"        int axisAtom = particles.z;\n"
"        int axisType = particles.w;\n"
"    \n"
"        // NoAxisType\n"
"    \n"
"        if (axisType < 5 && particles.z >= 0) {\n"
"            real3 atomPos = trimTo3(posq[atom]);\n"
"            vector[U] = atomPos - trimTo3(posq[axisAtom]);\n"
"            norms[U] = normVector(&vector[U]);\n"
"            if (axisType != 4 && particles.x >= 0)\n"
"                vector[V] = atomPos - trimTo3(posq[particles.x]);\n"
"            else {\n"
"                if (fabs(vector[U].x/norms[U]) < 0.866)\n"
"                    vector[V] = make_real3(1, 0, 0);\n"
"                else\n"
"                    vector[V] = make_real3(0, 1, 0);\n"
"            }\n"
"            norms[V] = normVector(&vector[V]);\n"
"        \n"
"            // W = UxV\n"
"        \n"
"            if (axisType < 2 || axisType > 3)\n"
"                vector[W] = cross(vector[U], vector[V]);\n"
"            else\n"
"                vector[W] = trimTo3(posq[particles.y]) - atomPos;\n"
"            norms[W] = normVector(&vector[W]);\n"
"        \n"
"            vector[UV] = cross(vector[V], vector[U]);\n"
"            vector[UW] = cross(vector[W], vector[U]);\n"
"            vector[VW] = cross(vector[W], vector[V]);\n"
"        \n"
"            norms[UV] = normVector(&vector[UV]);\n"
"            norms[UW] = normVector(&vector[UW]);\n"
"            norms[VW] = normVector(&vector[VW]);\n"
"        \n"
"            angles[UV][0] = dot(vector[U], vector[V]);\n"
"            angles[UV][1] = SQRT(1 - angles[UV][0]*angles[UV][0]);\n"
"        \n"
"            angles[UW][0] = dot(vector[U], vector[W]);\n"
"            angles[UW][1] = SQRT(1 - angles[UW][0]*angles[UW][0]);\n"
"        \n"
"            angles[VW][0] = dot(vector[V], vector[W]);\n"
"            angles[VW][1] = SQRT(1 - angles[VW][0]*angles[VW][0]);\n"
"        \n"
"            real dphi[3];\n"
"            real3 torque = make_real3(torqueScale*torqueBuffers[atom], torqueScale*torqueBuffers[atom+PADDED_NUM_ATOMS], torqueScale*torqueBuffers[atom+PADDED_NUM_ATOMS*2]);\n"
"            dphi[U] = -dot(vector[U], torque);\n"
"            dphi[V] = -dot(vector[V], torque);\n"
"            dphi[W] = -dot(vector[W], torque);\n"
"        \n"
"            // z-then-x and bisector\n"
"        \n"
"            if (axisType == 0 || axisType == 1) {\n"
"                real factor1 = dphi[V]/(norms[U]*angles[UV][1]);\n"
"                real factor2 = dphi[W]/(norms[U]);\n"
"                real factor3 = -dphi[U]/(norms[V]*angles[UV][1]);\n"
"                real factor4 = 0;\n"
"                if (axisType == 1) {\n"
"                    factor2 *= 0.5f;\n"
"                    factor4 = 0.5f*dphi[W]/(norms[V]);\n"
"                }\n"
"                forces[Z] = vector[UV]*factor1 + factor2*vector[UW];\n"
"                forces[X] = vector[UV]*factor3 + factor4*vector[VW];\n"
"                forces[I] = -(forces[X]+forces[Z]);\n"
"                forces[Y] = make_real3(0);\n"
"            }\n"
"            else if (axisType == 2) {\n"
"                // z-bisect\n"
"        \n"
"                vector[R] = vector[V] + vector[W]; \n"
"        \n"
"                vector[S] = cross(vector[U], vector[R]);\n"
"        \n"
"                norms[R] = normVector(&vector[R]);\n"
"                norms[S] = normVector(&vector[S]);\n"
"        \n"
"                vector[UR] = cross(vector[R], vector[U]);\n"
"                vector[US] = cross(vector[S], vector[U]);\n"
"                vector[VS] = cross(vector[S], vector[V]);\n"
"                vector[WS] = cross(vector[S], vector[W]);\n"
"        \n"
"                norms[UR] = normVector(&vector[UR]);\n"
"                norms[US] = normVector(&vector[US]);\n"
"                norms[VS] = normVector(&vector[VS]);\n"
"                norms[WS] = normVector(&vector[WS]);\n"
"        \n"
"                angles[UR][0] = dot(vector[U], vector[R]);\n"
"                angles[UR][1] = SQRT(1 - angles[UR][0]*angles[UR][0]);\n"
"        \n"
"                angles[US][0] = dot(vector[U], vector[S]);\n"
"                angles[US][1] = SQRT(1 - angles[US][0]*angles[US][0]);\n"
"        \n"
"                angles[VS][0] = dot(vector[V], vector[S]);\n"
"                angles[VS][1] = SQRT(1 - angles[VS][0]*angles[VS][0]);\n"
"        \n"
"                angles[WS][0] = dot(vector[W], vector[S]);\n"
"                angles[WS][1] = SQRT(1 - angles[WS][0]*angles[WS][0]);\n"
"         \n"
"                real3 t1 = vector[V] - vector[S]*angles[VS][0];\n"
"                real3 t2 = vector[W] - vector[S]*angles[WS][0];\n"
"                normVector(&t1);\n"
"                normVector(&t2);\n"
"                real ut1cos = dot(vector[U], t1);\n"
"                real ut1sin = SQRT(1 - ut1cos*ut1cos);\n"
"                real ut2cos = dot(vector[U], t2);\n"
"                real ut2sin = SQRT(1 - ut2cos*ut2cos);\n"
"        \n"
"                real dphiR = -dot(vector[R], torque);\n"
"                real dphiS = -dot(vector[S], torque);\n"
"        \n"
"                real factor1 = dphiR/(norms[U]*angles[UR][1]);\n"
"                real factor2 = dphiS/(norms[U]);\n"
"                real factor3 = dphi[U]/(norms[V]*(ut1sin+ut2sin));\n"
"                real factor4 = dphi[U]/(norms[W]*(ut1sin+ut2sin));\n"
"                forces[Z] = vector[UR]*factor1 + factor2*vector[US];\n"
"                forces[X] = (angles[VS][1]*vector[S] - angles[VS][0]*t1)*factor3;\n"
"                forces[Y] = (angles[WS][1]*vector[S] - angles[WS][0]*t2)*factor4;\n"
"                forces[I] = -(forces[X] + forces[Y] + forces[Z]);\n"
"            }\n"
"            else if (axisType == 3) {\n"
"                // 3-fold\n"
"        \n"
"                forces[Z] = (vector[UW]*dphi[W]/(norms[U]*angles[UW][1]) +\n"
"                            vector[UV]*dphi[V]/(norms[U]*angles[UV][1]) -\n"
"                            vector[UW]*dphi[U]/(norms[U]*angles[UW][1]) -\n"
"                            vector[UV]*dphi[U]/(norms[U]*angles[UV][1]))/3;\n"
"\n"
"                forces[X] = (vector[VW]*dphi[W]/(norms[V]*angles[VW][1]) -\n"
"                            vector[UV]*dphi[U]/(norms[V]*angles[UV][1]) -\n"
"                            vector[VW]*dphi[V]/(norms[V]*angles[VW][1]) +\n"
"                            vector[UV]*dphi[V]/(norms[V]*angles[UV][1]))/3;\n"
"\n"
"                forces[Y] = (-vector[UW]*dphi[U]/(norms[W]*angles[UW][1]) -\n"
"                            vector[VW]*dphi[V]/(norms[W]*angles[VW][1]) +\n"
"                            vector[UW]*dphi[W]/(norms[W]*angles[UW][1]) +\n"
"                            vector[VW]*dphi[W]/(norms[W]*angles[VW][1]))/3;\n"
"                forces[I] = -(forces[X] + forces[Y] + forces[Z]);\n"
"            }\n"
"            else if (axisType == 4) {\n"
"                // z-only\n"
"        \n"
"                forces[Z] = vector[UV]*dphi[V]/(norms[U]*angles[UV][1]) + vector[UW]*dphi[W]/norms[U];\n"
"                forces[X] = make_real3(0);\n"
"                forces[Y] = make_real3(0);\n"
"                forces[I] = -forces[Z];\n"
"            }\n"
"            else {\n"
"                forces[Z] = make_real3(0);\n"
"                forces[X] = make_real3(0);\n"
"                forces[Y] = make_real3(0);\n"
"                forces[I] = make_real3(0);\n"
"            }\n"
"\n"
"            // Store results\n"
"\n"
"            ATOMIC_ADD(&forceBuffers[particles.z], (mm_ulong) ((mm_long) (forces[Z].x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[particles.z+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Z].y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[particles.z+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Z].z*0x100000000)));\n"
"            if (axisType != 4) {\n"
"                ATOMIC_ADD(&forceBuffers[particles.x], (mm_ulong) ((mm_long) (forces[X].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.x+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[X].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.x+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[X].z*0x100000000)));\n"
"            }\n"
"            if ((axisType == 2 || axisType == 3) && particles.y > -1) {\n"
"                ATOMIC_ADD(&forceBuffers[particles.y], (mm_ulong) ((mm_long) (forces[Y].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.y+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Y].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.y+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Y].z*0x100000000)));\n"
"            }\n"
"            ATOMIC_ADD(&forceBuffers[atom], (mm_ulong) ((mm_long) (forces[I].x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[I].y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[I].z*0x100000000)));\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonAmoebaKernelSources::hippoMutualField = "real fdamp3, fdamp5;\n"
"computeMutualFieldDampingFactors(alpha1, alpha2, r, &fdamp3, &fdamp5);\n"
"#ifdef COMPUTING_EXCEPTIONS\n"
"fdamp3 *= scale;\n"
"fdamp5 *= scale;\n"
"#endif\n"
"real invR2 = invR*invR;\n"
"real invR3 = invR*invR2;\n"
"#if USE_EWALD\n"
"real ralpha = PME_ALPHA*r;\n"
"real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    const real erfcAlphaR = erfc(ralpha);\n"
"#else\n"
"    // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"    // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"    // error of 1.5e-7.\n"
"\n"
"    const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"    const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"real bn0 = erfcAlphaR*invR;\n"
"real alsq2 = 2*PME_ALPHA*PME_ALPHA;\n"
"real alsq2n = 1/(SQRT_PI*PME_ALPHA);\n"
"alsq2n *= alsq2;\n"
"real bn1 = (bn0+alsq2n*exp2a)*invR2;\n"
"alsq2n *= alsq2;\n"
"real bn2 = (3*bn1+alsq2n*exp2a)*invR2;\n"
"real scale3 = -bn1 + (1-fdamp3)*invR3;\n"
"real scale5 = bn2 - 3*(1-fdamp5)*invR3*invR2;\n"
"#else\n"
"real scale3 = -fdamp3*invR3;\n"
"real scale5 = 3*fdamp5*invR3*invR2;\n"
"#endif\n"
"tempField1 = inducedDipole2*scale3 + delta*scale5*dot(inducedDipole2, delta);\n"
"tempField2 = inducedDipole1*scale3 + delta*scale5*dot(inducedDipole1, delta);\n"
"";
const string CommonAmoebaKernelSources::hippoNonbonded = "// This is a modified version of the standard nonbonded kernel for computing HippoNonbondedForce.\n"
"// This is needed because of two ways in which it differs from most nonbonded interactions:\n"
"// the force between two atoms doesn't always point along the line between them, and we need\n"
"// to accumulate torques as well as forces.\n"
"\n"
"#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"#ifndef ENABLE_SHUFFLE\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    real tx, ty, tz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    real padding;\n"
"#endif\n"
"} AtomData;\n"
"#endif\n"
"\n"
"#ifdef ENABLE_SHUFFLE\n"
"//support for 64 bit shuffles\n"
"static __inline__ __device__ float real_shfl(float var, int srcLane) {\n"
"    return SHFL(var, srcLane);\n"
"}\n"
"\n"
"static __inline__ __device__ double real_shfl(double var, int srcLane) {\n"
"    int hi, lo;\n"
"    asm volatile(\"mov.b64 { %0, %1 }, %2;\" : \"=r\"(lo), \"=r\"(hi) : \"d\"(var));\n"
"    hi = SHFL(hi, srcLane);\n"
"    lo = SHFL(lo, srcLane);\n"
"    return __hiloint2double( hi, lo );\n"
"}\n"
"\n"
"static __inline__ __device__ mm_long real_shfl(mm_long var, int srcLane) {\n"
"    int hi, lo;\n"
"    asm volatile(\"mov.b64 { %0, %1 }, %2;\" : \"=r\"(lo), \"=r\"(hi) : \"l\"(var));\n"
"    hi = SHFL(hi, srcLane);\n"
"    lo = SHFL(lo, srcLane);\n"
"    // unforunately there isn't an __nv_hiloint2long(hi,lo) intrinsic cast\n"
"    int2 fuse; fuse.x = lo; fuse.y = hi;\n"
"    return *reinterpret_cast<mm_long*>(&fuse);\n"
"}\n"
"#endif\n"
"\n"
"KERNEL void computeNonbonded(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* RESTRICT exclusionTiles, unsigned int startTileIndex, mm_ulong numTileIndices\n"
"#ifdef USE_CUTOFF\n"
"        , GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize, \n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const unsigned int* RESTRICT interactingAtoms\n"
"#ifdef __CUDA_ARCH__\n"
"        , unsigned int maxSinglePairs, GLOBAL const int2* RESTRICT singlePairs\n"
"#endif\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE; // global warpIndex\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1); // index within the warp\n"
"    const unsigned int tbx = LOCAL_ID - tgx;           // block warpIndex\n"
"    const unsigned int localAtomIndex = LOCAL_ID;\n"
"    mixed energy = 0;\n"
"    // used shared memory if the device cannot shuffle\n"
"#ifndef ENABLE_SHUFFLE\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"#endif\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"\n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real3 force = make_real3(0);\n"
"        real3 torque = make_real3(0);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"        unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"        const bool hasExclusions = true;\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"#ifdef ENABLE_SHUFFLE\n"
"            real4 shflPosq = posq1;\n"
"#else\n"
"            localData[LOCAL_ID].x = posq1.x;\n"
"            localData[LOCAL_ID].y = posq1.y;\n"
"            localData[LOCAL_ID].z = posq1.z;\n"
"            localData[LOCAL_ID].q = posq1.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"#endif\n"
"\n"
"            // we do not need to fetch parameters from global since this is a symmetric tile\n"
"            // instead we can broadcast the values using shuffle\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real4 posq2;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                BROADCAST_WARP_DATA\n"
"#else   \n"
"                posq2 = make_real4(localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"#endif\n"
"                real3 delta = make_real3(posq2.x-posq1.x, posq2.y-posq1.y, posq2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                real rInv = RSQRT(r2);\n"
"                real r = r2*rInv;\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+j;\n"
"                real3 tempForce = make_real3(0);\n"
"                real3 tempTorque1 = make_real3(0);\n"
"                real3 tempTorque2 = make_real3(0);\n"
"                bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                real tempEnergy = 0.0f;\n"
"                const real interactionScale = 0.5f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += 0.5f*tempEnergy;\n"
"                force += tempForce;\n"
"                torque += tempTorque1;\n"
"                excl >>= 1;\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 shflPosq = posq[j];\n"
"#ifdef ENABLE_SHUFFLE\n"
"            real3 shflForce = make_real3(0);\n"
"            real3 shflTorque = make_real3(0);\n"
"#else\n"
"            localData[LOCAL_ID].x = shflPosq.x;\n"
"            localData[LOCAL_ID].y = shflPosq.y;\n"
"            localData[LOCAL_ID].z = shflPosq.z;\n"
"            localData[LOCAL_ID].q = shflPosq.w;\n"
"            localData[LOCAL_ID].fx = 0.0f;\n"
"            localData[LOCAL_ID].fy = 0.0f;\n"
"            localData[LOCAL_ID].fz = 0.0f;\n"
"            localData[LOCAL_ID].tx = 0.0f;\n"
"            localData[LOCAL_ID].ty = 0.0f;\n"
"            localData[LOCAL_ID].tz = 0.0f;\n"
"#endif\n"
"            DECLARE_LOCAL_PARAMETERS\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            SYNC_WARPS;\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                real4 posq2 = shflPosq;\n"
"#else\n"
"                real4 posq2 = make_real4(localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"#endif\n"
"                real3 delta = make_real3(posq2.x-posq1.x, posq2.y-posq1.y, posq2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                real rInv = RSQRT(r2);\n"
"                real r = r2*rInv;\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+tj;\n"
"                real3 tempForce = make_real3(0);\n"
"                real3 tempTorque1 = make_real3(0);\n"
"                real3 tempTorque2 = make_real3(0);\n"
"                bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                real tempEnergy = 0.0f;\n"
"                const real interactionScale = 1.0f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += tempEnergy;\n"
"                force += tempForce;\n"
"                torque += tempTorque1;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                shflForce -= tempForce;\n"
"                shflTorque += tempTorque2;\n"
"                SHUFFLE_WARP_DATA\n"
"                shflTorque.x = real_shfl(shflTorque.x, tgx+1);\n"
"                shflTorque.y = real_shfl(shflTorque.y, tgx+1);\n"
"                shflTorque.z = real_shfl(shflTorque.z, tgx+1);\n"
"#else\n"
"                localData[tbx+tj].fx -= tempForce.x;\n"
"                localData[tbx+tj].fy -= tempForce.y;\n"
"                localData[tbx+tj].fz -= tempForce.z;\n"
"                localData[tbx+tj].tx += tempTorque2.x;\n"
"                localData[tbx+tj].ty += tempTorque2.y;\n"
"                localData[tbx+tj].tz += tempTorque2.z;\n"
"#endif\n"
"                excl >>= 1;\n"
"                // cycles the indices\n"
"                // 0 1 2 3 4 5 6 7 -> 1 2 3 4 5 6 7 0\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            // write results for off diagonal tiles\n"
"#ifdef ENABLE_SHUFFLE\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (shflForce.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflForce.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflForce.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (shflTorque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflTorque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflTorque.z*0x100000000)));\n"
"#else\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].tx*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].ty*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].tz*0x100000000)));\n"
"#endif\n"
"        }\n"
"        // Write results for on and off diagonal tiles\n"
"\n"
"        const unsigned int offset = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (torque.x*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque.y*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque.z*0x100000000)));\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(mm_long)numTileIndices/totalWarps : warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(mm_long)numTileIndices/totalWarps : (warp+1)*(mm_long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    // atomIndices can probably be shuffled as well\n"
"    // but it probably wouldn't make things any faster\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"    \n"
"    while (pos < end) {\n"
"        const bool hasExclusions = false;\n"
"        real3 force = make_real3(0);\n"
"        real3 torque = make_real3(0);\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= MAX_CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            // Load atom data for this tile.\n"
"            real4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"#ifdef ENABLE_SHUFFLE\n"
"            DECLARE_LOCAL_PARAMETERS\n"
"            real4 shflPosq;\n"
"            real3 shflForce = make_real3(0);\n"
"            real3 shflTorque = make_real3(0);\n"
"#endif\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                // Load position of atom j from from global memory\n"
"#ifdef ENABLE_SHUFFLE\n"
"                shflPosq = posq[j];\n"
"#else\n"
"                localData[LOCAL_ID].x = posq[j].x;\n"
"                localData[LOCAL_ID].y = posq[j].y;\n"
"                localData[LOCAL_ID].z = posq[j].z;\n"
"                localData[LOCAL_ID].q = posq[j].w;\n"
"                localData[LOCAL_ID].fx = 0.0f;\n"
"                localData[LOCAL_ID].fy = 0.0f;\n"
"                localData[LOCAL_ID].fz = 0.0f;\n"
"                localData[LOCAL_ID].tx = 0.0f;\n"
"                localData[LOCAL_ID].ty = 0.0f;\n"
"                localData[LOCAL_ID].tz = 0.0f;\n"
"#endif                \n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"            else {\n"
"#ifdef ENABLE_SHUFFLE\n"
"                shflPosq = make_real4(0, 0, 0, 0);\n"
"#else\n"
"                localData[LOCAL_ID].x = 0;\n"
"                localData[LOCAL_ID].y = 0;\n"
"                localData[LOCAL_ID].z = 0;\n"
"#endif\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"#ifdef ENABLE_SHUFFLE\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(shflPosq, blockCenterX)\n"
"#else\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[LOCAL_ID], blockCenterX)\n"
"#endif\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                    real4 posq2 = shflPosq; \n"
"#else\n"
"                    real4 posq2 = make_real4(localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"#endif\n"
"                    real3 delta = make_real3(posq2.x-posq1.x, posq2.y-posq1.y, posq2.z-posq1.z);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    real rInv = RSQRT(r2);\n"
"                    real r = r2*rInv;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = atomIndices[tbx+tj];\n"
"                    real3 tempForce = make_real3(0);\n"
"                    real3 tempTorque1 = make_real3(0);\n"
"                    real3 tempTorque2 = make_real3(0);\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"                    real tempEnergy = 0.0f;\n"
"                    const real interactionScale = 1.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += tempEnergy;\n"
"                    force += tempForce;\n"
"                    torque += tempTorque1;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                    shflForce -= tempForce;\n"
"                    shflTorque += tempTorque2;\n"
"                    SHUFFLE_WARP_DATA\n"
"                    shflTorque.x = real_shfl(shflTorque.x, tgx+1);\n"
"                    shflTorque.y = real_shfl(shflTorque.y, tgx+1);\n"
"                    shflTorque.z = real_shfl(shflTorque.z, tgx+1);\n"
"#else\n"
"                    localData[tbx+tj].fx -= tempForce.x;\n"
"                    localData[tbx+tj].fy -= tempForce.y;\n"
"                    localData[tbx+tj].fz -= tempForce.z;\n"
"                    localData[tbx+tj].tx += tempTorque2.x;\n"
"                    localData[tbx+tj].ty += tempTorque2.y;\n"
"                    localData[tbx+tj].tz += tempTorque2.z;\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                    real4 posq2 = shflPosq;\n"
"#else\n"
"                    real4 posq2 = make_real4(localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"#endif\n"
"                    real3 delta = make_real3(posq2.x-posq1.x, posq2.y-posq1.y, posq2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    real rInv = RSQRT(r2);\n"
"                    real r = r2*rInv;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = atomIndices[tbx+tj];\n"
"                    real3 tempForce = make_real3(0);\n"
"                    real3 tempTorque1 = make_real3(0);\n"
"                    real3 tempTorque2 = make_real3(0);\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"                    real tempEnergy = 0.0f;\n"
"                    const real interactionScale = 1.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += tempEnergy;\n"
"                    force += tempForce;\n"
"                    torque += tempTorque1;\n"
"#ifdef ENABLE_SHUFFLE\n"
"                    shflForce -= tempForce;\n"
"                    shflTorque += tempTorque2;\n"
"                    SHUFFLE_WARP_DATA\n"
"                    shflTorque.x = real_shfl(shflTorque.x, tgx+1);\n"
"                    shflTorque.y = real_shfl(shflTorque.y, tgx+1);\n"
"                    shflTorque.z = real_shfl(shflTorque.z, tgx+1);\n"
"#else\n"
"                    localData[tbx+tj].fx -= tempForce.x;\n"
"                    localData[tbx+tj].fy -= tempForce.y;\n"
"                    localData[tbx+tj].fz -= tempForce.z;\n"
"                    localData[tbx+tj].tx += tempTorque2.x;\n"
"                    localData[tbx+tj].ty += tempTorque2.y;\n"
"                    localData[tbx+tj].tz += tempTorque2.z;\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef ENABLE_SHUFFLE\n"
"                ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (shflForce.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflForce.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflForce.z*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2], (mm_ulong) ((mm_long) (shflTorque.x*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflTorque.y*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (shflTorque.z*0x100000000)));\n"
"#else\n"
"                ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].tx*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].ty*0x100000000)));\n"
"                ATOMIC_ADD(&torqueBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].tz*0x100000000)));\n"
"#endif\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"#ifdef INCLUDE_ENERGY\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"#endif\n"
"}";
const string CommonAmoebaKernelSources::hippoNonbondedExceptions = "#define COMPUTING_EXCEPTIONS\n"
"\n"
"/**\n"
" * Compute exceptions for HIPPO.\n"
" */\n"
"KERNEL void computeNonbondedExceptions(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL mm_ulong* RESTRICT torqueBuffers,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const int2* RESTRICT exceptionAtoms, GLOBAL const real* RESTRICT mmScale,\n"
"        GLOBAL const real* RESTRICT dmScale, GLOBAL const real* RESTRICT ddScale, GLOBAL const real* RESTRICT dispScale, GLOBAL const real* RESTRICT repScale, GLOBAL const real* RESTRICT ctScale,\n"
"        GLOBAL const real* RESTRICT coreCharge, GLOBAL const real* RESTRICT valenceCharge, GLOBAL const real* RESTRICT alpha, GLOBAL const real* RESTRICT epsilon,\n"
"        GLOBAL const real* RESTRICT damping, GLOBAL const real* RESTRICT c6, GLOBAL const real* RESTRICT pauliK, GLOBAL const real* RESTRICT pauliQ,\n"
"        GLOBAL const real* RESTRICT pauliAlpha, GLOBAL const real* RESTRICT dipole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT qXX,\n"
"        GLOBAL const real* RESTRICT qXY, GLOBAL const real* RESTRICT qXZ, GLOBAL const real* RESTRICT qYY, GLOBAL const real* RESTRICT qYZ,\n"
"        GLOBAL const real* RESTRICT extrapolatedDipole\n"
"#ifdef USE_CUTOFF\n"
"        , real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVec\n"
"#endif\n"
"        ) {\n"
"    mixed energy = 0;\n"
"    const bool isExcluded = false;\n"
"    const real interactionScale = 1.0f;\n"
"    for (int index = GLOBAL_ID; index < NUM_EXCEPTIONS; index += GLOBAL_SIZE) {\n"
"        int2 atoms = exceptionAtoms[index];\n"
"        int atom1 = atoms.x;\n"
"        int atom2 = atoms.y;\n"
"        real4 pos1 = posq[atom1];\n"
"        real4 pos2 = posq[atom2];\n"
"        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"            real coreCharge1 = coreCharge[atom1];\n"
"            real valenceCharge1 = valenceCharge[atom1];\n"
"            real alpha1 = alpha[atom1];\n"
"            real epsilon1 = epsilon[atom1];\n"
"            real damping1 = damping[atom1];\n"
"            real c61 = c6[atom1];\n"
"            real pauliK1 = pauliK[atom1];\n"
"            real pauliQ1 = pauliQ[atom1];\n"
"            real pauliAlpha1 = pauliAlpha[atom1];\n"
"            real3 dipole1 = make_real3(dipole[3*atom1], dipole[3*atom1+1], dipole[3*atom1+2]);\n"
"            real3 inducedDipole1 = make_real3(inducedDipole[3*atom1], inducedDipole[3*atom1+1], inducedDipole[3*atom1+2]);\n"
"            real qXX1 = qXX[atom1];\n"
"            real qXY1 = qXY[atom1];\n"
"            real qXZ1 = qXZ[atom1];\n"
"            real qYY1 = qYY[atom1];\n"
"            real qYZ1 = qYZ[atom1];\n"
"            real coreCharge2 = coreCharge[atom2];\n"
"            real valenceCharge2 = valenceCharge[atom2];\n"
"            real alpha2 = alpha[atom2];\n"
"            real epsilon2 = epsilon[atom2];\n"
"            real damping2 = damping[atom2];\n"
"            real c62 = c6[atom2];\n"
"            real pauliK2 = pauliK[atom2];\n"
"            real pauliQ2 = pauliQ[atom2];\n"
"            real pauliAlpha2 = pauliAlpha[atom2];\n"
"            real3 dipole2 = make_real3(dipole[3*atom2], dipole[3*atom2+1], dipole[3*atom2+2]);\n"
"            real3 inducedDipole2 = make_real3(inducedDipole[3*atom2], inducedDipole[3*atom2+1], inducedDipole[3*atom2+2]);\n"
"            real qXX2 = qXX[atom2];\n"
"            real qXY2 = qXY[atom2];\n"
"            real qXZ2 = qXZ[atom2];\n"
"            real qYY2 = qYY[atom2];\n"
"            real qYZ2 = qYZ[atom2];\n"
"            real multipoleMultipoleScale = mmScale[index];\n"
"            real dipoleMultipoleScale = dmScale[index];\n"
"            real dipoleDipoleScale = ddScale[index];\n"
"            real repulsionScale = repScale[index];\n"
"            real dispersionScale = dispScale[index];\n"
"            real chargeTransferScale = ctScale[index];\n"
"            real rInv = RSQRT(r2);\n"
"            real r = r2*rInv;\n"
"            real3 tempForce = make_real3(0);\n"
"            real3 tempTorque1 = make_real3(0);\n"
"            real3 tempTorque2 = make_real3(0);\n"
"            real tempEnergy = 0.0f;\n"
"            COMPUTE_INTERACTION\n"
"            energy += tempEnergy;\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (tempForce.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempForce.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempForce.z*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (-tempForce.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (-tempForce.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (-tempForce.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (tempTorque1.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempTorque1.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempTorque1.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom2], (mm_ulong) ((mm_long) (tempTorque2.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempTorque2.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (tempTorque2.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"        }\n"
"#endif\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"";
const string CommonAmoebaKernelSources::multipoleElectrostatics = "#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real3 pos, force, torque, inducedDipole, inducedDipolePolar, sphericalDipole;\n"
"    real q;\n"
"    float thole, damp;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real sphericalQuadrupole[5];\n"
"#endif\n"
"} AtomData;\n"
"\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT sphericalDipole,\n"
"        GLOBAL const real* RESTRICT sphericalQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"        GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    AtomData data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    data.q = atomPosq.w;\n"
"    data.sphericalDipole.x = sphericalDipole[atom*3];\n"
"    data.sphericalDipole.y = sphericalDipole[atom*3+1];\n"
"    data.sphericalDipole.z = sphericalDipole[atom*3+2];\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    data.sphericalQuadrupole[0] = sphericalQuadrupole[atom*5];\n"
"    data.sphericalQuadrupole[1] = sphericalQuadrupole[atom*5+1];\n"
"    data.sphericalQuadrupole[2] = sphericalQuadrupole[atom*5+2];\n"
"    data.sphericalQuadrupole[3] = sphericalQuadrupole[atom*5+3];\n"
"    data.sphericalQuadrupole[4] = sphericalQuadrupole[atom*5+4];\n"
"#endif\n"
"    data.inducedDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"    data.inducedDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"    return data;\n"
"}\n"
"\n"
"DEVICE real computeDScaleFactor(unsigned int polarizationGroup, int index) {\n"
"    return (polarizationGroup & 1<<index ? 0 : 1);\n"
"}\n"
"\n"
"DEVICE float computeMScaleFactor(uint2 covalent, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    return (x ? (y ? 0.0f : 0.4f) : (y ? 0.8f : 1.0f));\n"
"}\n"
"\n"
"DEVICE float computePScaleFactor(uint2 covalent, unsigned int polarizationGroup, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    bool p = (polarizationGroup & mask);\n"
"    return (x && y ? 0.0f : (x && p ? 0.5f : 1.0f));\n"
"}\n"
"\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, bool hasExclusions, float dScale, float pScale, float mScale, float forceFactor, mixed* energy) {\n"
"    // Compute the displacement.\n"
"    \n"
"    real3 delta;\n"
"    delta.x = atom2->pos.x - atom1->pos.x;\n"
"    delta.y = atom2->pos.y - atom1->pos.y;\n"
"    delta.z = atom2->pos.z - atom1->pos.z;\n"
"    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"    real rInv = RSQRT(r2);\n"
"    real r = r2*rInv;\n"
"\n"
"    // Rotate the various dipoles and quadrupoles.\n"
"\n"
"    real qiRotationMatrix[3][3];\n"
"    buildQIRotationMatrix(delta, rInv, qiRotationMatrix);\n"
"\n"
"    \n"
"    real3 qiUindI = 0.5f*make_real3(qiRotationMatrix[0][1]*atom1->inducedDipole.x + qiRotationMatrix[0][2]*atom1->inducedDipole.y + qiRotationMatrix[0][0]*atom1->inducedDipole.z,\n"
"                                    qiRotationMatrix[1][1]*atom1->inducedDipole.x + qiRotationMatrix[1][2]*atom1->inducedDipole.y + qiRotationMatrix[1][0]*atom1->inducedDipole.z,\n"
"                                    qiRotationMatrix[2][1]*atom1->inducedDipole.x + qiRotationMatrix[2][2]*atom1->inducedDipole.y + qiRotationMatrix[2][0]*atom1->inducedDipole.z);\n"
"    real3 qiUindJ = 0.5f*make_real3(qiRotationMatrix[0][1]*atom2->inducedDipole.x + qiRotationMatrix[0][2]*atom2->inducedDipole.y + qiRotationMatrix[0][0]*atom2->inducedDipole.z,\n"
"                                    qiRotationMatrix[1][1]*atom2->inducedDipole.x + qiRotationMatrix[1][2]*atom2->inducedDipole.y + qiRotationMatrix[1][0]*atom2->inducedDipole.z,\n"
"                                    qiRotationMatrix[2][1]*atom2->inducedDipole.x + qiRotationMatrix[2][2]*atom2->inducedDipole.y + qiRotationMatrix[2][0]*atom2->inducedDipole.z);\n"
"    real3 qiUinpI = 0.5f*make_real3(qiRotationMatrix[0][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[0][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[0][0]*atom1->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[1][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[1][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[1][0]*atom1->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[2][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[2][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[2][0]*atom1->inducedDipolePolar.z);\n"
"    real3 qiUinpJ = 0.5f*make_real3(qiRotationMatrix[0][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[0][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[0][0]*atom2->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[1][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[1][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[1][0]*atom2->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[2][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[2][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[2][0]*atom2->inducedDipolePolar.z);\n"
"    \n"
"    real3 rotatedDipole1 = rotateDipole(atom1->sphericalDipole, qiRotationMatrix);\n"
"    real3 rotatedDipole2 = rotateDipole(atom2->sphericalDipole, qiRotationMatrix);\n"
"    real rotatedQuadrupole1[] = {0, 0, 0, 0, 0};\n"
"    real rotatedQuadrupole2[] = {0, 0, 0, 0, 0};\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    rotateQuadrupoles(qiRotationMatrix, atom1->sphericalQuadrupole, atom2->sphericalQuadrupole, rotatedQuadrupole1, rotatedQuadrupole2);\n"
"#endif    \n"
"    \n"
"    // The field derivatives at I due to permanent and induced moments on J, and vice-versa.\n"
"    // Also, their derivatives w.r.t. R, which are needed for force calculations\n"
"    real Vij[9], Vji[9], VjiR[9], VijR[9];\n"
"    // The field derivatives at I due to only permanent moments on J, and vice-versa.\n"
"    real Vijp[3], Vijd[3], Vjip[3], Vjid[3];\n"
"    real rInvVec[7];\n"
"\n"
"    // The rInvVec array is defined such that the ith element is R^-i, with the\n"
"    // dieleectric constant folded in, to avoid conversions later.\n"
"    rInvVec[1] = rInv;\n"
"    for (int i = 2; i < 7; ++i)\n"
"        rInvVec[i] = rInvVec[i-1] * rInv;\n"
"\n"
"    real dmp = atom1->damp*atom2->damp;\n"
"    real a = min(atom1->thole, atom2->thole);\n"
"    real u = r/dmp;\n"
"    real au3 = fabs(dmp) > 1.0e-5f ? a*u*u*u : 0;\n"
"    real expau3 = fabs(dmp) > 1.0e-5f ? EXP(-au3) : 0;\n"
"    real a2u6 = au3*au3;\n"
"    real a3u9 = a2u6*au3;\n"
"    // Thole damping factors for energies\n"
"    real thole_c  = 1 - expau3;\n"
"    real thole_d0 = 1 - expau3*(1 + 1.5f*au3);\n"
"    real thole_d1 = 1 - expau3;\n"
"    real thole_q0 = 1 - expau3*(1 + au3 + a2u6);\n"
"    real thole_q1 = 1 - expau3*(1 + au3);\n"
"    // Thole damping factors for derivatives\n"
"    real dthole_c  = 1 - expau3*(1 + 1.5f*au3);\n"
"    real dthole_d0 = 1 - expau3*(1 + au3 + 1.5f*a2u6);\n"
"    real dthole_d1 = 1 - expau3*(1 + au3);\n"
"    real dthole_q0 = 1 - expau3*(1 + au3 + 0.25f*a2u6 + 0.75f*a3u9);\n"
"    real dthole_q1 = 1 - expau3*(1 + au3 + 0.75f*a2u6);\n"
"\n"
"    // Now we compute the (attenuated) Coulomb operator and its derivatives, contracted with\n"
"    // permanent moments and induced dipoles.  Note that the coefficient of the permanent force\n"
"    // terms is half of the expected value; this is because we compute the interaction of I with\n"
"    // the sum of induced and permanent moments on J, as well as the interaction of J with I's\n"
"    // permanent and induced moments; doing so double counts the permanent-permanent interaction.\n"
"    real ePermCoef, dPermCoef, eUIndCoef, dUIndCoef, eUInpCoef, dUInpCoef;\n"
"\n"
"    // C-C terms (m=0)\n"
"    ePermCoef = rInvVec[1]*mScale;\n"
"    dPermCoef = -0.5f*mScale*rInvVec[2];\n"
"    Vij[0]  = ePermCoef*atom2->q;\n"
"    Vji[0]  = ePermCoef*atom1->q;\n"
"    VijR[0] = dPermCoef*atom2->q;\n"
"    VjiR[0] = dPermCoef*atom1->q;\n"
"\n"
"    // C-D and C-Uind terms (m=0)\n"
"    ePermCoef = rInvVec[2]*mScale;\n"
"    eUIndCoef = rInvVec[2]*pScale*thole_c;\n"
"    eUInpCoef = rInvVec[2]*dScale*thole_c;\n"
"    dPermCoef = -rInvVec[3]*mScale;\n"
"    dUIndCoef = -2*rInvVec[3]*pScale*dthole_c;\n"
"    dUInpCoef = -2*rInvVec[3]*dScale*dthole_c;\n"
"    Vij[0]  += -(ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x);\n"
"    Vji[1]   = -(ePermCoef*atom1->q);\n"
"    VijR[0] += -(dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x);\n"
"    VjiR[1]  = -(dPermCoef*atom1->q);\n"
"    Vjip[0]  = -(eUInpCoef*atom1->q);\n"
"    Vjid[0]  = -(eUIndCoef*atom1->q);\n"
"    // D-C and Uind-C terms (m=0)\n"
"    Vij[1]   = ePermCoef*atom2->q;\n"
"    Vji[0]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1]  = dPermCoef*atom2->q;\n"
"    VjiR[0] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0]  = eUInpCoef*atom2->q;\n"
"    Vijd[0]  = eUIndCoef*atom2->q;\n"
"\n"
"    // D-D and D-Uind terms (m=0)\n"
"    ePermCoef = -2*rInvVec[3]*mScale;\n"
"    eUIndCoef = -2*rInvVec[3]*pScale*thole_d0;\n"
"    eUInpCoef = -2*rInvVec[3]*dScale*thole_d0;\n"
"    dPermCoef = 3*rInvVec[4]*mScale;\n"
"    dUIndCoef = 6*rInvVec[4]*pScale*dthole_d0;\n"
"    dUInpCoef = 6*rInvVec[4]*dScale*dthole_d0;\n"
"    Vij[1]  += ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x;\n"
"    Vji[1]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1] += dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x;\n"
"    VjiR[1] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0] += eUInpCoef*rotatedDipole2.x;\n"
"    Vijd[0] += eUIndCoef*rotatedDipole2.x;\n"
"    Vjip[0] += eUInpCoef*rotatedDipole1.x;\n"
"    Vjid[0] += eUIndCoef*rotatedDipole1.x;\n"
"    // D-D and D-Uind terms (m=1)\n"
"    ePermCoef = rInvVec[3]*mScale;\n"
"    eUIndCoef = rInvVec[3]*pScale*thole_d1;\n"
"    eUInpCoef = rInvVec[3]*dScale*thole_d1;\n"
"    dPermCoef = -1.5f*rInvVec[4]*mScale;\n"
"    dUIndCoef = -3*rInvVec[4]*pScale*dthole_d1;\n"
"    dUInpCoef = -3*rInvVec[4]*dScale*dthole_d1;\n"
"    Vij[2]  = ePermCoef*rotatedDipole2.y + eUIndCoef*qiUindJ.y + eUInpCoef*qiUinpJ.y;\n"
"    Vji[2]  = ePermCoef*rotatedDipole1.y + eUIndCoef*qiUindI.y + eUInpCoef*qiUinpI.y;\n"
"    VijR[2] = dPermCoef*rotatedDipole2.y + dUIndCoef*qiUindJ.y + dUInpCoef*qiUinpJ.y;\n"
"    VjiR[2] = dPermCoef*rotatedDipole1.y + dUIndCoef*qiUindI.y + dUInpCoef*qiUinpI.y;\n"
"    Vij[3]  = ePermCoef*rotatedDipole2.z + eUIndCoef*qiUindJ.z + eUInpCoef*qiUinpJ.z;\n"
"    Vji[3]  = ePermCoef*rotatedDipole1.z + eUIndCoef*qiUindI.z + eUInpCoef*qiUinpI.z;\n"
"    VijR[3] = dPermCoef*rotatedDipole2.z + dUIndCoef*qiUindJ.z + dUInpCoef*qiUinpJ.z;\n"
"    VjiR[3] = dPermCoef*rotatedDipole1.z + dUIndCoef*qiUindI.z + dUInpCoef*qiUinpI.z;\n"
"    Vijp[1] = eUInpCoef*rotatedDipole2.y;\n"
"    Vijd[1] = eUIndCoef*rotatedDipole2.y;\n"
"    Vjip[1] = eUInpCoef*rotatedDipole1.y;\n"
"    Vjid[1] = eUIndCoef*rotatedDipole1.y;\n"
"    Vijp[2] = eUInpCoef*rotatedDipole2.z;\n"
"    Vijd[2] = eUIndCoef*rotatedDipole2.z;\n"
"    Vjip[2] = eUInpCoef*rotatedDipole1.z;\n"
"    Vjid[2] = eUIndCoef*rotatedDipole1.z;\n"
"\n"
"    // C-Q terms (m=0)\n"
"    ePermCoef = mScale*rInvVec[3];\n"
"    dPermCoef = -1.5f*rInvVec[4]*mScale;\n"
"    Vij[0]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]   = ePermCoef*atom1->q;\n"
"    VijR[0] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4]  = dPermCoef*atom1->q;\n"
"    // Q-C terms (m=0)\n"
"    Vij[4]   = ePermCoef*atom2->q;\n"
"    Vji[0]  += ePermCoef*rotatedQuadrupole1[0];\n"
"    VijR[4]  = dPermCoef*atom2->q;\n"
"    VjiR[0] += dPermCoef*rotatedQuadrupole1[0];\n"
"\n"
"    // D-Q and Uind-Q terms (m=0)\n"
"    ePermCoef = rInvVec[4]*3.0*mScale;\n"
"    eUIndCoef = rInvVec[4]*3.0*pScale*thole_q0;\n"
"    eUInpCoef = rInvVec[4]*3.0*dScale*thole_q0;\n"
"    dPermCoef = -6*rInvVec[5]*mScale;\n"
"    dUIndCoef = -12*rInvVec[5]*pScale*dthole_q0;\n"
"    dUInpCoef = -12*rInvVec[5]*dScale*dthole_q0;\n"
"    Vij[1]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0] += eUInpCoef*rotatedQuadrupole2[0];\n"
"    Vijd[0] += eUIndCoef*rotatedQuadrupole2[0];\n"
"    // Q-D and Q-Uind terms (m=0)\n"
"    Vij[4]  += -(ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x);\n"
"    Vji[1]  += -(ePermCoef*rotatedQuadrupole1[0]);\n"
"    VijR[4] += -(dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x);\n"
"    VjiR[1] += -(dPermCoef*rotatedQuadrupole1[0]);\n"
"    Vjip[0] += -(eUInpCoef*rotatedQuadrupole1[0]);\n"
"    Vjid[0] += -(eUIndCoef*rotatedQuadrupole1[0]);\n"
"\n"
"    // D-Q and Uind-Q terms (m=1)\n"
"    const real sqrtThree = SQRT((real) 3);\n"
"    ePermCoef = -sqrtThree*rInvVec[4]*mScale;\n"
"    eUIndCoef = -sqrtThree*rInvVec[4]*pScale*thole_q1;\n"
"    eUInpCoef = -sqrtThree*rInvVec[4]*dScale*thole_q1;\n"
"    dPermCoef = 2*sqrtThree*rInvVec[5]*mScale;\n"
"    dUIndCoef = 4*sqrtThree*rInvVec[5]*pScale*dthole_q1;\n"
"    dUInpCoef = 4*sqrtThree*rInvVec[5]*dScale*dthole_q1;\n"
"    Vij[2]  += ePermCoef*rotatedQuadrupole2[1];\n"
"    Vji[5]   = ePermCoef*rotatedDipole1.y + eUIndCoef*qiUindI.y + eUInpCoef*qiUinpI.y;\n"
"    VijR[2] += dPermCoef*rotatedQuadrupole2[1];\n"
"    VjiR[5]  = dPermCoef*rotatedDipole1.y + dUIndCoef*qiUindI.y + dUInpCoef*qiUinpI.y;\n"
"    Vij[3]  += ePermCoef*rotatedQuadrupole2[2];\n"
"    Vji[6]   = ePermCoef*rotatedDipole1.z + eUIndCoef*qiUindI.z + eUInpCoef*qiUinpI.z;\n"
"    VijR[3] += dPermCoef*rotatedQuadrupole2[2];\n"
"    VjiR[6]  = dPermCoef*rotatedDipole1.z + dUIndCoef*qiUindI.z + dUInpCoef*qiUinpI.z;\n"
"    Vijp[1] += eUInpCoef*rotatedQuadrupole2[1];\n"
"    Vijd[1] += eUIndCoef*rotatedQuadrupole2[1];\n"
"    Vijp[2] += eUInpCoef*rotatedQuadrupole2[2];\n"
"    Vijd[2] += eUIndCoef*rotatedQuadrupole2[2];\n"
"    // D-Q and Uind-Q terms (m=1)\n"
"    Vij[5]   = -(ePermCoef*rotatedDipole2.y + eUIndCoef*qiUindJ.y + eUInpCoef*qiUinpJ.y);\n"
"    Vji[2]  += -(ePermCoef*rotatedQuadrupole1[1]);\n"
"    VijR[5]  = -(dPermCoef*rotatedDipole2.y + dUIndCoef*qiUindJ.y + dUInpCoef*qiUinpJ.y);\n"
"    VjiR[2] += -(dPermCoef*rotatedQuadrupole1[1]);\n"
"    Vij[6]   = -(ePermCoef*rotatedDipole2.z + eUIndCoef*qiUindJ.z + eUInpCoef*qiUinpJ.z);\n"
"    Vji[3]  += -(ePermCoef*rotatedQuadrupole1[2]);\n"
"    VijR[6]  = -(dPermCoef*rotatedDipole2.z + dUIndCoef*qiUindJ.z + dUInpCoef*qiUinpJ.z);\n"
"    VjiR[3] += -(dPermCoef*rotatedQuadrupole1[2]);\n"
"    Vjip[1] += -(eUInpCoef*rotatedQuadrupole1[1]);\n"
"    Vjid[1] += -(eUIndCoef*rotatedQuadrupole1[1]);\n"
"    Vjip[2] += -(eUInpCoef*rotatedQuadrupole1[2]);\n"
"    Vjid[2] += -(eUIndCoef*rotatedQuadrupole1[2]);\n"
"\n"
"    // Q-Q terms (m=0)\n"
"    ePermCoef = 6*rInvVec[5]*mScale;\n"
"    dPermCoef = -15*rInvVec[6]*mScale;\n"
"    Vij[4]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]  += ePermCoef*rotatedQuadrupole1[0];\n"
"    VijR[4] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4] += dPermCoef*rotatedQuadrupole1[0];\n"
"    // Q-Q terms (m=1)\n"
"    ePermCoef = -4*rInvVec[5]*mScale;\n"
"    dPermCoef = 10*rInvVec[6]*mScale;\n"
"    Vij[5]  += ePermCoef*rotatedQuadrupole2[1];\n"
"    Vji[5]  += ePermCoef*rotatedQuadrupole1[1];\n"
"    VijR[5] += dPermCoef*rotatedQuadrupole2[1];\n"
"    VjiR[5] += dPermCoef*rotatedQuadrupole1[1];\n"
"    Vij[6]  += ePermCoef*rotatedQuadrupole2[2];\n"
"    Vji[6]  += ePermCoef*rotatedQuadrupole1[2];\n"
"    VijR[6] += dPermCoef*rotatedQuadrupole2[2];\n"
"    VjiR[6] += dPermCoef*rotatedQuadrupole1[2];\n"
"    // Q-Q terms (m=2)\n"
"    ePermCoef = rInvVec[5]*mScale;\n"
"    dPermCoef = -2.5f*rInvVec[6]*mScale;\n"
"    Vij[7]  = ePermCoef*rotatedQuadrupole2[3];\n"
"    Vji[7]  = ePermCoef*rotatedQuadrupole1[3];\n"
"    VijR[7] = dPermCoef*rotatedQuadrupole2[3];\n"
"    VjiR[7] = dPermCoef*rotatedQuadrupole1[3];\n"
"    Vij[8]  = ePermCoef*rotatedQuadrupole2[4];\n"
"    Vji[8]  = ePermCoef*rotatedQuadrupole1[4];\n"
"    VijR[8] = dPermCoef*rotatedQuadrupole2[4];\n"
"    VjiR[8] = dPermCoef*rotatedQuadrupole1[4];\n"
"\n"
"    // Evaluate the energies, forces and torques due to permanent+induced moments\n"
"    // interacting with just the permanent moments.\n"
"    *energy += forceFactor*0.5f*(\n"
"        atom1->q*Vij[0] + rotatedDipole1.x*Vij[1] + rotatedDipole1.y*Vij[2] + rotatedDipole1.z*Vij[3] + rotatedQuadrupole1[0]*Vij[4] + rotatedQuadrupole1[1]*Vij[5] + rotatedQuadrupole1[2]*Vij[6] + rotatedQuadrupole1[3]*Vij[7] + rotatedQuadrupole1[4]*Vij[8] +\n"
"        atom2->q*Vji[0] + rotatedDipole2.x*Vji[1] + rotatedDipole2.y*Vji[2] + rotatedDipole2.z*Vji[3] + rotatedQuadrupole2[0]*Vji[4] + rotatedQuadrupole2[1]*Vji[5] + rotatedQuadrupole2[2]*Vji[6] + rotatedQuadrupole2[3]*Vji[7] + rotatedQuadrupole2[4]*Vji[8]);\n"
"    real fIZ = atom1->q*VijR[0] + rotatedDipole1.x*VijR[1] + rotatedDipole1.y*VijR[2] + rotatedDipole1.z*VijR[3] + rotatedQuadrupole1[0]*VijR[4] + rotatedQuadrupole1[1]*VijR[5] + rotatedQuadrupole1[2]*VijR[6] + rotatedQuadrupole1[3]*VijR[7] + rotatedQuadrupole1[4]*VijR[8];\n"
"    real fJZ = atom2->q*VjiR[0] + rotatedDipole2.x*VjiR[1] + rotatedDipole2.y*VjiR[2] + rotatedDipole2.z*VjiR[3] + rotatedQuadrupole2[0]*VjiR[4] + rotatedQuadrupole2[1]*VjiR[5] + rotatedQuadrupole2[2]*VjiR[6] + rotatedQuadrupole2[3]*VjiR[7] + rotatedQuadrupole2[4]*VjiR[8];\n"
"    real EIX = rotatedDipole1.z*Vij[1] - rotatedDipole1.x*Vij[3] + sqrtThree*rotatedQuadrupole1[2]*Vij[4] + rotatedQuadrupole1[4]*Vij[5] - (sqrtThree*rotatedQuadrupole1[0]+rotatedQuadrupole1[3])*Vij[6] + rotatedQuadrupole1[2]*Vij[7] - rotatedQuadrupole1[1]*Vij[8];\n"
"    real EIY = -rotatedDipole1.y*Vij[1] + rotatedDipole1.x*Vij[2] - sqrtThree*rotatedQuadrupole1[1]*Vij[4] + (sqrtThree*rotatedQuadrupole1[0]-rotatedQuadrupole1[3])*Vij[5] - rotatedQuadrupole1[4]*Vij[6] + rotatedQuadrupole1[1]*Vij[7] + rotatedQuadrupole1[2]*Vij[8];\n"
"    real EIZ = -rotatedDipole1.z*Vij[2] + rotatedDipole1.y*Vij[3] - rotatedQuadrupole1[2]*Vij[5] + rotatedQuadrupole1[1]*Vij[6] - 2*rotatedQuadrupole1[4]*Vij[7] + 2*rotatedQuadrupole1[3]*Vij[8];\n"
"    real EJX = rotatedDipole2.z*Vji[1] - rotatedDipole2.x*Vji[3] + sqrtThree*rotatedQuadrupole2[2]*Vji[4] + rotatedQuadrupole2[4]*Vji[5] - (sqrtThree*rotatedQuadrupole2[0]+rotatedQuadrupole2[3])*Vji[6] + rotatedQuadrupole2[2]*Vji[7] - rotatedQuadrupole2[1]*Vji[8];\n"
"    real EJY = -rotatedDipole2.y*Vji[1] + rotatedDipole2.x*Vji[2] - sqrtThree*rotatedQuadrupole2[1]*Vji[4] + (sqrtThree*rotatedQuadrupole2[0]-rotatedQuadrupole2[3])*Vji[5] - rotatedQuadrupole2[4]*Vji[6] + rotatedQuadrupole2[1]*Vji[7] + rotatedQuadrupole2[2]*Vji[8];\n"
"    real EJZ = -rotatedDipole2.z*Vji[2] + rotatedDipole2.y*Vji[3] - rotatedQuadrupole2[2]*Vji[5] + rotatedQuadrupole2[1]*Vji[6] - 2*rotatedQuadrupole2[4]*Vji[7] + 2*rotatedQuadrupole2[3]*Vji[8];\n"
"\n"
"    // Define the torque intermediates for the induced dipoles. These are simply the induced dipole torque\n"
"    // intermediates dotted with the field due to permanent moments only, at each center. We inline the\n"
"    // induced dipole torque intermediates here, for simplicity. N.B. There are no torques on the dipoles\n"
"    // themselves, so we accumulate the torque intermediates into separate variables to allow them to be\n"
"    // used only in the force calculation.\n"
"    //\n"
"    // The torque about the x axis (needed to obtain the y force on the induced dipoles, below)\n"
"    //    qiUindIx[0] = qiQUindI[2];    qiUindIx[1] = 0;    qiUindIx[2] = -qiQUindI[0]\n"
"    real iEIX = qiUinpI.z*Vijp[0] + qiUindI.z*Vijd[0] - qiUinpI.x*Vijp[2] - qiUindI.x*Vijd[2];\n"
"    real iEJX = qiUinpJ.z*Vjip[0] + qiUindJ.z*Vjid[0] - qiUinpJ.x*Vjip[2] - qiUindJ.x*Vjid[2];\n"
"    // The torque about the y axis (needed to obtain the x force on the induced dipoles, below)\n"
"    //    qiUindIy[0] = -qiQUindI[1];   qiUindIy[1] = qiQUindI[0];    qiUindIy[2] = 0\n"
"    real iEIY = qiUinpI.x*Vijp[1] + qiUindI.x*Vijd[1] - qiUinpI.y*Vijp[0] - qiUindI.y*Vijd[0];\n"
"    real iEJY = qiUinpJ.x*Vjip[1] + qiUindJ.x*Vjid[1] - qiUinpJ.y*Vjip[0] - qiUindJ.y*Vjid[0];\n"
"\n"
"#ifdef MUTUAL_POLARIZATION\n"
"    // Uind-Uind terms (m=0)\n"
"    real eCoef = -4*rInvVec[3]*thole_d0;\n"
"    real dCoef = 6*rInvVec[4]*dthole_d0;\n"
"    iEIX += eCoef*(qiUinpI.z*qiUindJ.x + qiUindI.z*qiUinpJ.x);\n"
"    iEJX += eCoef*(qiUinpJ.z*qiUindI.x + qiUindJ.z*qiUinpI.x);\n"
"    iEIY -= eCoef*(qiUinpI.y*qiUindJ.x + qiUindI.y*qiUinpJ.x);\n"
"    iEJY -= eCoef*(qiUinpJ.y*qiUindI.x + qiUindJ.y*qiUinpI.x);\n"
"    fIZ += dCoef*(qiUinpI.x*qiUindJ.x + qiUindI.x*qiUinpJ.x);\n"
"    fJZ += dCoef*(qiUinpJ.x*qiUindI.x + qiUindJ.x*qiUinpI.x);\n"
"    // Uind-Uind terms (m=1)\n"
"    eCoef = 2*rInvVec[3]*thole_d1;\n"
"    dCoef = -3*rInvVec[4]*dthole_d1;\n"
"    iEIX -= eCoef*(qiUinpI.x*qiUindJ.z + qiUindI.x*qiUinpJ.z);\n"
"    iEJX -= eCoef*(qiUinpJ.x*qiUindI.z + qiUindJ.x*qiUinpI.z);\n"
"    iEIY += eCoef*(qiUinpI.x*qiUindJ.y + qiUindI.x*qiUinpJ.y);\n"
"    iEJY += eCoef*(qiUinpJ.x*qiUindI.y + qiUindJ.x*qiUinpI.y);\n"
"    fIZ += dCoef*(qiUinpI.y*qiUindJ.y + qiUindI.y*qiUinpJ.y + qiUinpI.z*qiUindJ.z + qiUindI.z*qiUinpJ.z);\n"
"    fJZ += dCoef*(qiUinpJ.y*qiUindI.y + qiUindJ.y*qiUinpI.y + qiUinpJ.z*qiUindI.z + qiUindJ.z*qiUinpI.z);\n"
"#endif\n"
"\n"
"    // The quasi-internal frame forces and torques.  Note that the induced torque intermediates are\n"
"    // used in the force expression, but not in the torques; the induced dipoles are isotropic.\n"
"    real qiForce[3] = {rInv*(EIY+EJY+iEIY+iEJY), -rInv*(EIX+EJX+iEIX+iEJX), -(fJZ+fIZ)};\n"
"    real qiTorqueI[3] = {-EIX, -EIY, -EIZ};\n"
"    real qiTorqueJ[3] = {-EJX, -EJY, -EJZ};\n"
"\n"
"\n"
"    real3 force = make_real3(qiRotationMatrix[1][1]*qiForce[0] + qiRotationMatrix[2][1]*qiForce[1] + qiRotationMatrix[0][1]*qiForce[2],\n"
"                             qiRotationMatrix[1][2]*qiForce[0] + qiRotationMatrix[2][2]*qiForce[1] + qiRotationMatrix[0][2]*qiForce[2],\n"
"                             qiRotationMatrix[1][0]*qiForce[0] + qiRotationMatrix[2][0]*qiForce[1] + qiRotationMatrix[0][0]*qiForce[2]);\n"
"    atom1->force += force;\n"
"    atom1->torque += make_real3(qiRotationMatrix[1][1]*qiTorqueI[0] + qiRotationMatrix[2][1]*qiTorqueI[1] + qiRotationMatrix[0][1]*qiTorqueI[2],\n"
"                               qiRotationMatrix[1][2]*qiTorqueI[0] + qiRotationMatrix[2][2]*qiTorqueI[1] + qiRotationMatrix[0][2]*qiTorqueI[2],\n"
"                               qiRotationMatrix[1][0]*qiTorqueI[0] + qiRotationMatrix[2][0]*qiTorqueI[1] + qiRotationMatrix[0][0]*qiTorqueI[2]);\n"
"    if (forceFactor == 1) {\n"
"        atom2->force -= force;\n"
"        atom2->torque += make_real3(qiRotationMatrix[1][1]*qiTorqueJ[0] + qiRotationMatrix[2][1]*qiTorqueJ[1] + qiRotationMatrix[0][1]*qiTorqueJ[2],\n"
"                                   qiRotationMatrix[1][2]*qiTorqueJ[0] + qiRotationMatrix[2][2]*qiTorqueJ[1] + qiRotationMatrix[0][2]*qiTorqueJ[2],\n"
"                                   qiRotationMatrix[1][0]*qiTorqueJ[0] + qiRotationMatrix[2][0]*qiTorqueJ[1] + qiRotationMatrix[0][0]*qiTorqueJ[2]);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute electrostatic interactions.\n"
" */\n"
"KERNEL void computeElectrostatics(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const uint2* RESTRICT covalentFlags, GLOBAL const unsigned int* RESTRICT polarizationGroupFlags,\n"
"        GLOBAL const int2* RESTRICT exclusionTiles, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const unsigned int* RESTRICT interactingAtoms,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT sphericalDipole, GLOBAL const real* RESTRICT sphericalQuadrupole, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        AtomData data = loadAtomData(atom1, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"        data.force = make_real3(0);\n"
"        data.torque = make_real3(0);\n"
"        uint2 covalent = covalentFlags[pos*TILE_SIZE+tgx];\n"
"        unsigned int polarizationGroup = polarizationGroupFlags[pos*TILE_SIZE+tgx];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].pos = data.pos;\n"
"            localData[LOCAL_ID].q = data.q;\n"
"            localData[LOCAL_ID].sphericalDipole = data.sphericalDipole;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"            localData[LOCAL_ID].sphericalQuadrupole[0] = data.sphericalQuadrupole[0];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[1] = data.sphericalQuadrupole[1];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[2] = data.sphericalQuadrupole[2];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[3] = data.sphericalQuadrupole[3];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[4] = data.sphericalQuadrupole[4];\n"
"#endif\n"
"            localData[LOCAL_ID].inducedDipole = data.inducedDipole;\n"
"            localData[LOCAL_ID].inducedDipolePolar = data.inducedDipolePolar;\n"
"            localData[LOCAL_ID].thole = data.thole;\n"
"            localData[LOCAL_ID].damp = data.damp;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    float d = computeDScaleFactor(polarizationGroup, j);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, j);\n"
"                    float m = computeMScaleFactor(covalent, j);\n"
"                    computeOneInteraction(&data, &localData[tbx+j], true, d, p, m, 0.5f, &energy);\n"
"                }\n"
"            }\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            localData[LOCAL_ID].torque = make_real3(0);\n"
"            unsigned int tj = tgx;\n"
"            SYNC_WARPS;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    float d = computeDScaleFactor(polarizationGroup, tj);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, tj);\n"
"                    float m = computeMScaleFactor(covalent, tj);\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], true, d, p, m, 1, &energy);\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= -ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].torque *= ENERGY_SCALE_FACTOR;\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(mm_long)numTileIndices/totalWarps : warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(mm_long)numTileIndices/totalWarps : (warp+1)*(mm_long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"    \n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            AtomData data = loadAtomData(atom1, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            data.force = make_real3(0);\n"
"            data.torque = make_real3(0);\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            localData[LOCAL_ID].torque = make_real3(0);\n"
"            SYNC_THREADS;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = atomIndices[tbx+tj];\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], false, 1, 1, 1, 1, &energy);\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_THREADS;\n"
"            }\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= -ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].torque *= ENERGY_SCALE_FACTOR;\n"
"\n"
"            // Write results.\n"
"\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"            offset = atomIndices[LOCAL_ID];\n"
"#else\n"
"            offset = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.z*0x100000000)));\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy*ENERGY_SCALE_FACTOR;\n"
"}";
const string CommonAmoebaKernelSources::multipoleFixedField = "#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real4 posq;\n"
"    real3 field, fieldPolar, dipole;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real quadrupoleXX, quadrupoleXY, quadrupoleXZ;\n"
"    real quadrupoleYY, quadrupoleYZ, quadrupoleZZ;\n"
"#endif\n"
"    float thole, damp;\n"
"#ifdef USE_GK\n"
"    real3 gkField;\n"
"    real bornRadius;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT labFrameDipole,\n"
"        GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    AtomData data;\n"
"    data.posq = posq[atom];\n"
"    data.dipole = make_real3(labFrameDipole[3*atom], labFrameDipole[3*atom+1], labFrameDipole[3*atom+2]);\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    data.quadrupoleXX = labFrameQuadrupole[atom*5];\n"
"    data.quadrupoleXY = labFrameQuadrupole[atom*5+1];\n"
"    data.quadrupoleXZ = labFrameQuadrupole[atom*5+2];\n"
"    data.quadrupoleYY = labFrameQuadrupole[atom*5+3];\n"
"    data.quadrupoleYZ = labFrameQuadrupole[atom*5+4];\n"
"    data.quadrupoleZZ = -(data.quadrupoleXX+data.quadrupoleYY);\n"
"#endif\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"    return data;\n"
"}\n"
"\n"
"#ifdef USE_EWALD\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 deltaR, float dScale, float pScale, real3* fields) {\n"
"    real r2 = dot(deltaR, deltaR);\n"
"    if (r2 <= CUTOFF_SQUARED) {\n"
"        // calculate the error function damping terms\n"
"\n"
"        real r = SQRT(r2);\n"
"        real ralpha = EWALD_ALPHA*r;\n"
"        real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"        const real erfcAlphaR = erfc(ralpha);\n"
"#else\n"
"        // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"        // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"        // error of 1.5e-7.\n"
"\n"
"        const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"        const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"        real bn0 = erfcAlphaR/r;\n"
"        real alsq2 = 2*EWALD_ALPHA*EWALD_ALPHA;\n"
"        real alsq2n = RECIP(SQRT_PI*EWALD_ALPHA);\n"
"        alsq2n *= alsq2;\n"
"        real bn1 = (bn0+alsq2n*exp2a)/r2;\n"
"        alsq2n *= alsq2;\n"
"        real bn2 = (3*bn1+alsq2n*exp2a)/r2;\n"
"        alsq2n *= alsq2;\n"
"        real bn3 = (5*bn2+alsq2n*exp2a)/r2;\n"
"\n"
"        // compute the error function scaled and unscaled terms\n"
"\n"
"        real scale3 = 1;\n"
"        real scale5 = 1;\n"
"        real scale7 = 1;\n"
"        real damp = atom1->damp*atom2->damp;\n"
"        if (damp != 0) {\n"
"            real ratio = (r/damp);\n"
"            ratio = ratio*ratio*ratio;\n"
"            real pgamma = (atom1->thole < atom2->thole ? atom1->thole : atom2->thole);\n"
"            damp = -pgamma*ratio;\n"
"            if (damp > -50) {\n"
"                real expdamp = EXP(damp);\n"
"                scale3 = 1 - expdamp;\n"
"                scale5 = 1 - expdamp*(1-damp);\n"
"                scale7 = 1 - expdamp*(1-damp+(0.6f*damp*damp));\n"
"            }\n"
"        }\n"
"        real dsc3 = dScale*scale3;\n"
"        real dsc5 = dScale*scale5;\n"
"        real dsc7 = dScale*scale7;\n"
"\n"
"        real psc3 = pScale*scale3;\n"
"        real psc5 = pScale*scale5;\n"
"        real psc7 = pScale*scale7;\n"
"\n"
"        real r3 = r*r2;\n"
"        real r5 = r3*r2;\n"
"        real r7 = r5*r2;\n"
"        real drr3 = (1-dsc3)/r3;\n"
"        real drr5 = 3*(1-dsc5)/r5;\n"
"        real drr7 = 15*(1-dsc7)/r7;\n"
"\n"
"        real prr3 = (1-psc3)/r3;\n"
"        real prr5 = 3*(1-psc5)/r5;\n"
"        real prr7 = 15*(1-psc7)/r7;\n"
"\n"
"        real dir = dot(atom1->dipole, deltaR);\n"
"        real dkr = dot(atom2->dipole, deltaR);\n"
"\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"        real3 qi;\n"
"        qi.x = atom1->quadrupoleXX*deltaR.x + atom1->quadrupoleXY*deltaR.y + atom1->quadrupoleXZ*deltaR.z;\n"
"        qi.y = atom1->quadrupoleXY*deltaR.x + atom1->quadrupoleYY*deltaR.y + atom1->quadrupoleYZ*deltaR.z;\n"
"        qi.z = atom1->quadrupoleXZ*deltaR.x + atom1->quadrupoleYZ*deltaR.y + atom1->quadrupoleZZ*deltaR.z;\n"
"        real qir = dot(qi, deltaR);\n"
"\n"
"        real3 qk;\n"
"        qk.x = atom2->quadrupoleXX*deltaR.x + atom2->quadrupoleXY*deltaR.y + atom2->quadrupoleXZ*deltaR.z;\n"
"        qk.y = atom2->quadrupoleXY*deltaR.x + atom2->quadrupoleYY*deltaR.y + atom2->quadrupoleYZ*deltaR.z;\n"
"        qk.z = atom2->quadrupoleXZ*deltaR.x + atom2->quadrupoleYZ*deltaR.y + atom2->quadrupoleZZ*deltaR.z;\n"
"        real qkr = dot(qk, deltaR);\n"
"\n"
"        real3 fim = -deltaR*(bn1*atom2->posq.w-bn2*dkr+bn3*qkr) - bn1*atom2->dipole + 2*bn2*qk;\n"
"        real3 fkm = deltaR*(bn1*atom1->posq.w+bn2*dir+bn3*qir) - bn1*atom1->dipole - 2*bn2*qi;\n"
"        real3 fid = -deltaR*(drr3*atom2->posq.w-drr5*dkr+drr7*qkr) - drr3*atom2->dipole + 2*drr5*qk;\n"
"        real3 fkd = deltaR*(drr3*atom1->posq.w+drr5*dir+drr7*qir) - drr3*atom1->dipole - 2*drr5*qi;\n"
"        real3 fip = -deltaR*(prr3*atom2->posq.w-prr5*dkr+prr7*qkr) - prr3*atom2->dipole + 2*prr5*qk;\n"
"        real3 fkp = deltaR*(prr3*atom1->posq.w+prr5*dir+prr7*qir) - prr3*atom1->dipole - 2*prr5*qi;\n"
"#else\n"
"        real3 fim = -deltaR*(bn1*atom2->posq.w-bn2*dkr) - bn1*atom2->dipole;\n"
"        real3 fkm = deltaR*(bn1*atom1->posq.w+bn2*dir) - bn1*atom1->dipole;\n"
"        real3 fid = -deltaR*(drr3*atom2->posq.w-drr5*dkr) - drr3*atom2->dipole;\n"
"        real3 fkd = deltaR*(drr3*atom1->posq.w+drr5*dir) - drr3*atom1->dipole;\n"
"        real3 fip = -deltaR*(prr3*atom2->posq.w-prr5*dkr) - prr3*atom2->dipole;\n"
"        real3 fkp = deltaR*(prr3*atom1->posq.w+prr5*dir) - prr3*atom1->dipole;\n"
"#endif\n"
"        // increment the field at each site due to this interaction\n"
"\n"
"        fields[0] = fim-fid;\n"
"        fields[1] = fim-fip;\n"
"        fields[2] = fkm-fkd;\n"
"        fields[3] = fkm-fkp;\n"
"    }\n"
"    else {\n"
"        fields[0] = make_real3(0);\n"
"        fields[1] = make_real3(0);\n"
"        fields[2] = make_real3(0);\n"
"        fields[3] = make_real3(0);\n"
"    }\n"
"}\n"
"#else\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 deltaR, float dScale, float pScale, real3* fields) {\n"
"    real rI = RSQRT(dot(deltaR, deltaR));\n"
"    real r = RECIP(rI);\n"
"    real r2I = rI*rI;\n"
"\n"
"    real rr3 = rI*r2I;\n"
"    real rr5 = 3*rr3*r2I;\n"
"    real rr7 = 5*rr5*r2I;\n"
" \n"
"    // get scaling factors, if needed\n"
"    \n"
"    float damp = atom1->damp*atom2->damp;\n"
"    real dampExp;\n"
"    if (damp != 0) {\n"
"\n"
"        // get scaling factors\n"
"      \n"
"        real ratio = r/damp;\n"
"        float pGamma = atom2->thole > atom1->thole ? atom1->thole : atom2->thole; \n"
"        damp = ratio*ratio*ratio*pGamma;\n"
"        dampExp = EXP(-damp);\n"
"    }\n"
"    else\n"
"        dampExp = 0;\n"
"      \n"
"    rr3 *= 1 - dampExp;\n"
"    rr5 *= 1 - (1+damp)*dampExp;\n"
"    rr7 *= 1 - (1+damp+(0.6f*damp*damp))*dampExp;\n"
"      \n"
"    real rr5_2 = 2*rr5;\n"
" \n"
"    real dir = dot(atom1->dipole, deltaR);\n"
"    real dkr = dot(atom2->dipole, deltaR);\n"
"\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real3 qi;\n"
"    qi.x = atom1->quadrupoleXX*deltaR.x + atom1->quadrupoleXY*deltaR.y + atom1->quadrupoleXZ*deltaR.z;\n"
"    qi.y = atom1->quadrupoleXY*deltaR.x + atom1->quadrupoleYY*deltaR.y + atom1->quadrupoleYZ*deltaR.z;\n"
"    qi.z = atom1->quadrupoleXZ*deltaR.x + atom1->quadrupoleYZ*deltaR.y + atom1->quadrupoleZZ*deltaR.z;\n"
"    real qir = dot(qi, deltaR);\n"
"\n"
"    real3 qk;\n"
"    qk.x = atom2->quadrupoleXX*deltaR.x + atom2->quadrupoleXY*deltaR.y + atom2->quadrupoleXZ*deltaR.z;\n"
"    qk.y = atom2->quadrupoleXY*deltaR.x + atom2->quadrupoleYY*deltaR.y + atom2->quadrupoleYZ*deltaR.z;\n"
"    qk.z = atom2->quadrupoleXZ*deltaR.x + atom2->quadrupoleYZ*deltaR.y + atom2->quadrupoleZZ*deltaR.z;\n"
"    real qkr = dot(qk, deltaR);\n"
"\n"
"    real factor = -rr3*atom2->posq.w + rr5*dkr - rr7*qkr;\n"
"    real3 field1 = deltaR*factor - rr3*atom2->dipole + rr5_2*qk;\n"
"    factor = rr3*atom1->posq.w + rr5*dir + rr7*qir;\n"
"    real3 field2 = deltaR*factor - rr3*atom1->dipole - rr5_2*qi;\n"
"#else\n"
"    real factor = -rr3*atom2->posq.w + rr5*dkr;\n"
"    real3 field1 = deltaR*factor - rr3*atom2->dipole;\n"
"    factor = rr3*atom1->posq.w + rr5*dir;\n"
"    real3 field2 = deltaR*factor - rr3*atom1->dipole;\n"
"#endif\n"
"    fields[0] = dScale*field1;\n"
"    fields[1] = pScale*field1;\n"
"    fields[2] = dScale*field2;\n"
"    fields[3] = pScale*field2;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef USE_GK\n"
"DEVICE void computeOneGkInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 delta, real3* fields) {\n"
"    real a[4][4];\n"
"    real gc[5];\n"
"    real gux[11],guy[11],guz[11];\n"
"    real gqxx[5],gqxy[5];\n"
"    real gqxz[5],gqyy[5];\n"
"    real gqyz[5],gqzz[5];\n"
"\n"
"    real ci = atom1->posq.w;\n"
"    real ck = atom2->posq.w;\n"
"\n"
"    real uxi = atom1->dipole.x;\n"
"    real uyi = atom1->dipole.y;\n"
"    real uzi = atom1->dipole.z;\n"
"    real uxk = atom2->dipole.x;\n"
"    real uyk = atom2->dipole.y;\n"
"    real uzk = atom2->dipole.z;\n"
"\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real qxxi = atom1->quadrupoleXX;\n"
"    real qxyi = atom1->quadrupoleXY;\n"
"    real qxzi = atom1->quadrupoleXZ;\n"
"    real qyyi = atom1->quadrupoleYY;\n"
"    real qyzi = atom1->quadrupoleYZ;\n"
"    real qzzi = atom1->quadrupoleZZ;\n"
"    real qxxk = atom2->quadrupoleXX;\n"
"    real qxyk = atom2->quadrupoleXY;\n"
"    real qxzk = atom2->quadrupoleXZ;\n"
"    real qyyk = atom2->quadrupoleYY;\n"
"    real qyzk = atom2->quadrupoleYZ;\n"
"    real qzzk = atom2->quadrupoleZZ;\n"
"#else\n"
"    real qxxi = 0;\n"
"    real qxyi = 0;\n"
"    real qxzi = 0;\n"
"    real qyyi = 0;\n"
"    real qyzi = 0;\n"
"    real qzzi = 0;\n"
"    real qxxk = 0;\n"
"    real qxyk = 0;\n"
"    real qxzk = 0;\n"
"    real qyyk = 0;\n"
"    real qyzk = 0;\n"
"    real qzzk = 0;\n"
"#endif\n"
"    real xr2 = delta.x*delta.x;\n"
"    real yr2 = delta.y*delta.y;\n"
"    real zr2 = delta.z*delta.z;\n"
"    real r2 = xr2 + yr2 + zr2;\n"
"\n"
"    real rb2 = atom1->bornRadius*atom2->bornRadius;\n"
"    real expterm = EXP(-r2/(GK_C*rb2));\n"
"    real expc = expterm / GK_C;\n"
"    real dexpc = -2/(GK_C*rb2);\n"
"    real gf2 = RECIP(r2+rb2*expterm);\n"
"    real gf = SQRT(gf2);\n"
"    real gf3 = gf2*gf;\n"
"    real gf5 = gf3*gf2;\n"
"    real gf7 = gf5*gf2;\n"
"\n"
"    // reaction potential auxiliary terms\n"
"\n"
"    a[0][0] = gf;\n"
"    a[1][0] = -gf3;\n"
"    a[2][0] = 3*gf5;\n"
"    a[3][0] = -15*gf7;\n"
"\n"
"    // reaction potential gradient auxiliary terms\n"
"\n"
"    real expc1 = 1 - expc;\n"
"    a[0][1] = expc1*a[1][0];\n"
"    a[1][1] = expc1*a[2][0];\n"
"    a[2][1] = expc1*a[3][0];\n"
"\n"
"    // dipole second reaction potential gradient auxiliary term\n"
"\n"
"    real expcdexpc = -expc*dexpc;\n"
"    a[1][2] = expc1*a[2][1] + expcdexpc*a[2][0];\n"
"\n"
"    // multiply the auxillary terms by dielectric functions;\n"
"\n"
"    a[0][1] = GK_FC*a[0][1];\n"
"    a[1][0] = GK_FD*a[1][0];\n"
"    a[1][1] = GK_FD*a[1][1];\n"
"    a[1][2] = GK_FD*a[1][2];\n"
"    a[2][0] = GK_FQ*a[2][0];\n"
"    a[2][1] = GK_FQ*a[2][1];\n"
"\n"
"    // unweighted dipole reaction potential tensor\n"
"\n"
"    gux[1] = delta.x*a[1][0];\n"
"    guy[1] = delta.y*a[1][0];\n"
"    guz[1] = delta.z*a[1][0];\n"
"\n"
"    // unweighted reaction potential gradient tensor\n"
"\n"
"    gc[2] = delta.x*a[0][1];\n"
"    gc[3] = delta.y*a[0][1];\n"
"    gc[4] = delta.z*a[0][1];\n"
"    gux[2] = a[1][0] + xr2*a[1][1];\n"
"    gux[3] = delta.x*delta.y*a[1][1];\n"
"    gux[4] = delta.x*delta.z*a[1][1];\n"
"    guy[2] = gux[3];\n"
"    guy[3] = a[1][0] + yr2*a[1][1];\n"
"    guy[4] = delta.y*delta.z*a[1][1];\n"
"    guz[2] = gux[4];\n"
"    guz[3] = guy[4];\n"
"    guz[4] = a[1][0] + zr2*a[1][1];\n"
"    gqxx[2] = delta.x*(2*a[2][0]+xr2*a[2][1]);\n"
"    gqxx[3] = delta.y*xr2*a[2][1];\n"
"    gqxx[4] = delta.z*xr2*a[2][1];\n"
"    gqyy[2] = delta.x*yr2*a[2][1];\n"
"    gqyy[3] = delta.y*(2*a[2][0]+yr2*a[2][1]);\n"
"    gqyy[4] = delta.z*yr2*a[2][1];\n"
"    gqzz[2] = delta.x*zr2*a[2][1];\n"
"    gqzz[3] = delta.y*zr2*a[2][1];\n"
"    gqzz[4] = delta.z*(2*a[2][0]+zr2*a[2][1]);\n"
"    gqxy[2] = delta.y*(a[2][0]+xr2*a[2][1]);\n"
"    gqxy[3] = delta.x*(a[2][0]+yr2*a[2][1]);\n"
"    gqxy[4] = delta.z*delta.x*delta.y*a[2][1];\n"
"    gqxz[2] = delta.z*(a[2][0]+xr2*a[2][1]);\n"
"    gqxz[3] = gqxy[4];\n"
"    gqxz[4] = delta.x*(a[2][0]+zr2*a[2][1]);\n"
"    gqyz[2] = gqxy[4];\n"
"    gqyz[3] = delta.z*(a[2][0]+yr2*a[2][1]);\n"
"    gqyz[4] = delta.y*(a[2][0]+zr2*a[2][1]);\n"
"\n"
"    // unweighted dipole second reaction potential gradient tensor\n"
"\n"
"    gux[5] = delta.x*(3*a[1][1]+xr2*a[1][2]);\n"
"    gux[6] = delta.y*(a[1][1]+xr2*a[1][2]);\n"
"    gux[7] = delta.z*(a[1][1]+xr2*a[1][2]);\n"
"    gux[8] = delta.x*(a[1][1]+yr2*a[1][2]);\n"
"    gux[9] = delta.z*delta.x*delta.y*a[1][2];\n"
"    gux[10] = delta.x*(a[1][1]+zr2*a[1][2]);\n"
"    guy[5] = delta.y*(a[1][1]+xr2*a[1][2]);\n"
"    guy[6] = delta.x*(a[1][1]+yr2*a[1][2]);\n"
"    guy[7] = gux[9];\n"
"    guy[8] = delta.y*(3*a[1][1]+yr2*a[1][2]);\n"
"    guy[9] = delta.z*(a[1][1]+yr2*a[1][2]);\n"
"    guy[10] = delta.y*(a[1][1]+zr2*a[1][2]);\n"
"    guz[5] = delta.z*(a[1][1]+xr2*a[1][2]);\n"
"    guz[6] = gux[9];\n"
"    guz[7] = delta.x*(a[1][1]+zr2*a[1][2]);\n"
"    guz[8] = delta.z*(a[1][1]+yr2*a[1][2]);\n"
"    guz[9] = delta.y*(a[1][1]+zr2*a[1][2]);\n"
"    guz[10] = delta.z*(3*a[1][1]+zr2*a[1][2]);\n"
"\n"
"    // generalized Kirkwood permanent reaction field\n"
"\n"
"    fields[0].x = uxk*gux[2] + uyk*gux[3] + uzk*gux[4]\n"
"                                   + 0.5f*(ck*gux[1] + qxxk*gux[5]\n"
"                                   + qyyk*gux[8] + qzzk*gux[10]\n"
"                                   + 2*(qxyk*gux[6]+qxzk*gux[7]\n"
"                                   + qyzk*gux[9]))\n"
"                                   + 0.5f*(ck*gc[2] + qxxk*gqxx[2]\n"
"                                   + qyyk*gqyy[2] + qzzk*gqzz[2]\n"
"                                   + 2*(qxyk*gqxy[2]+qxzk*gqxz[2]\n"
"                                   + qyzk*gqyz[2]));\n"
"\n"
"    fields[0].y = uxk*guy[2] + uyk*guy[3] + uzk*guy[4]\n"
"                                   + 0.5f*(ck*guy[1] + qxxk*guy[5]\n"
"                                   + qyyk*guy[8] + qzzk*guy[10]\n"
"                                   + 2*(qxyk*guy[6]+qxzk*guy[7]\n"
"                                   + qyzk*guy[9]))\n"
"                                   + 0.5f*(ck*gc[3] + qxxk*gqxx[3]\n"
"                                   + qyyk*gqyy[3] + qzzk*gqzz[3]\n"
"                                   + 2*(qxyk*gqxy[3]+qxzk*gqxz[3]\n"
"                                   + qyzk*gqyz[3]));\n"
"\n"
"    fields[0].z = uxk*guz[2] + uyk*guz[3] + uzk*guz[4]\n"
"                                   + 0.5f*(ck*guz[1] + qxxk*guz[5]\n"
"                                   + qyyk*guz[8] + qzzk*guz[10]\n"
"                                   + 2*(qxyk*guz[6]+qxzk*guz[7]\n"
"                                   + qyzk*guz[9]))\n"
"                                   + 0.5f*(ck*gc[4] + qxxk*gqxx[4]\n"
"                                   + qyyk*gqyy[4] + qzzk*gqzz[4]\n"
"                                   + 2*(qxyk*gqxy[4]+qxzk*gqxz[4]\n"
"                                   + qyzk*gqyz[4]));\n"
"\n"
"    fields[1].x = uxi*gux[2] + uyi*gux[3] + uzi*gux[4]\n"
"                                   - 0.5f*(ci*gux[1] + qxxi*gux[5]\n"
"                                   + qyyi*gux[8] + qzzi*gux[10]\n"
"                                   + 2*(qxyi*gux[6]+qxzi*gux[7]\n"
"                                   + qyzi*gux[9]))\n"
"                                   - 0.5f*(ci*gc[2] + qxxi*gqxx[2]\n"
"                                   + qyyi*gqyy[2] + qzzi*gqzz[2]\n"
"                                   + 2*(qxyi*gqxy[2]+qxzi*gqxz[2]\n"
"                                   + qyzi*gqyz[2]));\n"
"\n"
"    fields[1].y = uxi*guy[2] + uyi*guy[3] + uzi*guy[4]\n"
"                                   - 0.5f*(ci*guy[1] + qxxi*guy[5]\n"
"                                   + qyyi*guy[8] + qzzi*guy[10]\n"
"                                   + 2*(qxyi*guy[6]+qxzi*guy[7]\n"
"                                   + qyzi*guy[9]))\n"
"                                   - 0.5f*(ci*gc[3]      + qxxi*gqxx[3]\n"
"                                   + qyyi*gqyy[3] + qzzi*gqzz[3]\n"
"                                   + 2*(qxyi*gqxy[3]+qxzi*gqxz[3]\n"
"                                   + qyzi*gqyz[3]));\n"
"\n"
"    fields[1].z = uxi*guz[2] + uyi*guz[3] + uzi*guz[4]\n"
"                                   - 0.5f*(ci*guz[1] + qxxi*guz[5]\n"
"                                   + qyyi*guz[8] + qzzi*guz[10]\n"
"                                   + 2*(qxyi*guz[6]+qxzi*guz[7]\n"
"                                   + qyzi*guz[9]))\n"
"                                   - 0.5f*(ci*gc[4] + qxxi*gqxx[4]\n"
"                                   + qyyi*gqyy[4] + qzzi*gqzz[4]\n"
"                                   + 2*(qxyi*gqxy[4]+qxzi*gqxz[4]\n"
"                                   + qyzi*gqyz[4]));\n"
"}\n"
"#endif\n"
"\n"
"DEVICE real computeDScaleFactor(unsigned int polarizationGroup, int index) {\n"
"    return (polarizationGroup & 1<<index ? 0 : 1);\n"
"}\n"
"\n"
"DEVICE float computePScaleFactor(uint2 covalent, unsigned int polarizationGroup, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    bool p = (polarizationGroup & mask);\n"
"    return (x && y ? 0.0f : (x && p ? 0.5f : 1.0f));\n"
"}\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"KERNEL void computeFixedField(\n"
"        GLOBAL mm_ulong* RESTRICT fieldBuffers, GLOBAL mm_ulong* RESTRICT fieldPolarBuffers, GLOBAL const real4* RESTRICT posq,\n"
"        GLOBAL const uint2* RESTRICT covalentFlags, GLOBAL const unsigned int* RESTRICT polarizationGroupFlags, GLOBAL const int2* RESTRICT exclusionTiles,\n"
"        unsigned int startTileIndex, unsigned int numTileIndices,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const unsigned int* RESTRICT interactingAtoms,\n"
"#elif defined USE_GK\n"
"        GLOBAL const real* RESTRICT bornRadii, GLOBAL mm_ulong* RESTRICT gkFieldBuffers,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT labFrameDipole, GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        AtomData data = loadAtomData(atom1, posq, labFrameDipole, labFrameQuadrupole, dampingAndThole);\n"
"        data.field = make_real3(0);\n"
"        data.fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"        data.gkField = make_real3(0);\n"
"#endif\n"
"#ifdef USE_GK\n"
"        data.bornRadius = bornRadii[atom1];\n"
"#endif\n"
"        uint2 covalent = covalentFlags[pos*TILE_SIZE+tgx];\n"
"        unsigned int polarizationGroup = polarizationGroupFlags[pos*TILE_SIZE+tgx];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            localData[localAtomIndex].posq = data.posq;\n"
"            localData[localAtomIndex].dipole = data.dipole;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"            localData[localAtomIndex].quadrupoleXX = data.quadrupoleXX;\n"
"            localData[localAtomIndex].quadrupoleXY = data.quadrupoleXY;\n"
"            localData[localAtomIndex].quadrupoleXZ = data.quadrupoleXZ;\n"
"            localData[localAtomIndex].quadrupoleYY = data.quadrupoleYY;\n"
"            localData[localAtomIndex].quadrupoleYZ = data.quadrupoleYZ;\n"
"            localData[localAtomIndex].quadrupoleZZ = data.quadrupoleZZ;\n"
"#endif\n"
"            localData[localAtomIndex].thole = data.thole;\n"
"            localData[localAtomIndex].damp = data.damp;\n"
"#ifdef USE_GK\n"
"            localData[localAtomIndex].bornRadius = data.bornRadius;\n"
"#endif\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = trimTo3(localData[tbx+j].posq-data.posq);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[4];\n"
"                    float d = computeDScaleFactor(polarizationGroup, j);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, j);\n"
"                    computeOneInteraction(&data, &localData[tbx+j], delta, d, p, fields);\n"
"                    data.field += fields[0];\n"
"                    data.fieldPolar += fields[1];\n"
"                }\n"
"#ifdef USE_GK\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[2];\n"
"                    computeOneGkInteraction(&data, &localData[tbx+j], delta, fields);\n"
"                    data.gkField += fields[0];\n"
"                }\n"
"#endif\n"
"            }\n"
"            SYNC_WARPS;\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            localData[localAtomIndex] = loadAtomData(j, posq, labFrameDipole, labFrameQuadrupole, dampingAndThole);\n"
"            localData[localAtomIndex].field = make_real3(0);\n"
"            localData[localAtomIndex].fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"            localData[localAtomIndex].bornRadius = bornRadii[j];\n"
"            localData[localAtomIndex].gkField = make_real3(0);\n"
"#endif\n"
"            unsigned int tj = tgx;\n"
"            SYNC_WARPS;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = trimTo3(localData[tbx+tj].posq-data.posq);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[4];\n"
"                    float d = computeDScaleFactor(polarizationGroup, tj);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, tj);\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], delta, d, p, fields);\n"
"                    data.field += fields[0];\n"
"                    data.fieldPolar += fields[1];\n"
"                    localData[tbx+tj].field += fields[2];\n"
"                    localData[tbx+tj].fieldPolar += fields[3];\n"
"#ifdef USE_GK\n"
"                }\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[2];\n"
"                    computeOneGkInteraction(&data, &localData[tbx+tj], delta, fields);\n"
"                    data.gkField += fields[0];\n"
"                    localData[tbx+tj].gkField += fields[1];\n"
"#endif\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"            SYNC_WARPS;\n"
"        }\n"
"        \n"
"        // Write results.\n"
"        \n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&fieldBuffers[offset], (mm_ulong) ((mm_long) (data.field.x*0x100000000)));\n"
"        ATOMIC_ADD(&fieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.y*0x100000000)));\n"
"        ATOMIC_ADD(&fieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.z*0x100000000)));\n"
"        ATOMIC_ADD(&fieldPolarBuffers[offset], (mm_ulong) ((mm_long) (data.fieldPolar.x*0x100000000)));\n"
"        ATOMIC_ADD(&fieldPolarBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.y*0x100000000)));\n"
"        ATOMIC_ADD(&fieldPolarBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"        ATOMIC_ADD(&gkFieldBuffers[offset], (mm_ulong) ((mm_long) (data.gkField.x*0x100000000)));\n"
"        ATOMIC_ADD(&gkFieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.gkField.y*0x100000000)));\n"
"        ATOMIC_ADD(&gkFieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.gkField.z*0x100000000)));\n"
"#endif\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&fieldBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.z*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.x*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.y*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.z*0x100000000)));\n"
"#endif\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(mm_long)numTileIndices/totalWarps : warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(mm_long)numTileIndices/totalWarps : (warp+1)*(mm_long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            AtomData data = loadAtomData(atom1, posq, labFrameDipole, labFrameQuadrupole, dampingAndThole);\n"
"            data.field = make_real3(0);\n"
"            data.fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"            data.gkField = make_real3(0);\n"
"            data.bornRadius = bornRadii[atom1];\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            localData[localAtomIndex] = loadAtomData(j, posq, labFrameDipole, labFrameQuadrupole, dampingAndThole);\n"
"            localData[localAtomIndex].field = make_real3(0);\n"
"            localData[localAtomIndex].fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"            localData[localAtomIndex].bornRadius = bornRadii[j];\n"
"            localData[localAtomIndex].gkField = make_real3(0);\n"
"#endif\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = trimTo3(localData[tbx+tj].posq-data.posq);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = atomIndices[tbx+tj];\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[4];\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], delta, 1, 1, fields);\n"
"                    data.field += fields[0];\n"
"                    data.fieldPolar += fields[1];\n"
"                    localData[tbx+tj].field += fields[2];\n"
"                    localData[tbx+tj].fieldPolar += fields[3];\n"
"#ifdef USE_GK\n"
"                }\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    real3 fields[2];\n"
"                    computeOneGkInteraction(&data, &localData[tbx+tj], delta, fields);\n"
"                    data.gkField += fields[0];\n"
"                    localData[tbx+tj].gkField += fields[1];\n"
"#endif\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&fieldBuffers[offset], (mm_ulong) ((mm_long) (data.field.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.z*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset], (mm_ulong) ((mm_long) (data.fieldPolar.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset], (mm_ulong) ((mm_long) (data.gkField.x*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.gkField.y*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.gkField.z*0x100000000)));\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"            offset = atomIndices[LOCAL_ID];\n"
"#else\n"
"            offset = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            ATOMIC_ADD(&fieldBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].field.z*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.x*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.y*0x100000000)));\n"
"            ATOMIC_ADD(&fieldPolarBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.x*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.y*0x100000000)));\n"
"            ATOMIC_ADD(&gkFieldBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].gkField.z*0x100000000)));\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}";
const string CommonAmoebaKernelSources::multipoleInducedField = "#ifndef HIPPO\n"
"#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real3 pos;\n"
"    real3 field, fieldPolar, inducedDipole, inducedDipolePolar;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    real fieldGradient[6], fieldGradientPolar[6];\n"
"#endif\n"
"#ifdef USE_GK\n"
"    real3 fieldS, fieldPolarS, inducedDipoleS, inducedDipolePolarS;\n"
"    real bornRadius;\n"
"    #ifdef EXTRAPOLATED_POLARIZATION\n"
"        real fieldGradientS[6], fieldGradientPolarS[6];\n"
"    #endif\n"
"#endif\n"
"    float thole, damp;\n"
"} AtomData;\n"
"\n"
"#ifdef USE_GK\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const float2* RESTRICT dampingAndThole, GLOBAL const real* RESTRICT inducedDipoleS,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolarS, GLOBAL const real* RESTRICT bornRadii) {\n"
"#else\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"#endif\n"
"    AtomData data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    data.inducedDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"    data.inducedDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"#ifdef USE_GK\n"
"    data.inducedDipoleS = make_real3(inducedDipoleS[3*atom], inducedDipoleS[3*atom+1], inducedDipoleS[3*atom+2]);\n"
"    data.inducedDipolePolarS = make_real3(inducedDipolePolarS[3*atom], inducedDipolePolarS[3*atom+1], inducedDipolePolarS[3*atom+2]);\n"
"    data.bornRadius = bornRadii[atom];\n"
"#endif\n"
"    return data;\n"
"}\n"
"\n"
"inline DEVICE void zeroAtomData(AtomData* data) {\n"
"    data->field = make_real3(0);\n"
"    data->fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"    data->fieldS = make_real3(0);\n"
"    data->fieldPolarS = make_real3(0);\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    for (int i = 0; i < 6; i++) {\n"
"        data->fieldGradient[i] = 0;\n"
"        data->fieldGradientPolar[i] = 0;\n"
"#ifdef USE_GK\n"
"        data->fieldGradientS[i] = 0;\n"
"        data->fieldGradientPolarS[i] = 0;\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"// OpenCL requires a second version of this function, since the signature depends\n"
"// on the address space of the argument.\n"
"\n"
"inline DEVICE void zeroAtomDataLocal(LOCAL_ARG AtomData* data) {\n"
"    data->field = make_real3(0);\n"
"    data->fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"    data->fieldS = make_real3(0);\n"
"    data->fieldPolarS = make_real3(0);\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    for (int i = 0; i < 6; i++) {\n"
"        data->fieldGradient[i] = 0;\n"
"        data->fieldGradientPolar[i] = 0;\n"
"#ifdef USE_GK\n"
"        data->fieldGradientS[i] = 0;\n"
"        data->fieldGradientPolarS[i] = 0;\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    #ifdef USE_GK\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldGradient, fieldGradientPolar, fieldS, fieldPolarS, fieldGradientS, fieldGradientPolarS);\n"
"    #else\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldGradient, fieldGradientPolar);\n"
"    #endif\n"
"#else\n"
"    #ifdef USE_GK\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldS, fieldPolarS);\n"
"    #else\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar);\n"
"    #endif\n"
"#endif\n"
"\n"
"inline DEVICE void saveAtomData(int index, AtomData data, GLOBAL mm_ulong* RESTRICT field, GLOBAL mm_ulong* RESTRICT fieldPolar\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        , GLOBAL mm_ulong* RESTRICT fieldGradient, GLOBAL mm_ulong* RESTRICT fieldGradientPolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , GLOBAL mm_ulong* RESTRICT fieldS, GLOBAL mm_ulong* RESTRICT fieldPolarS\n"
"    #ifdef EXTRAPOLATED_POLARIZATION\n"
"        , GLOBAL mm_ulong* RESTRICT fieldGradientS, GLOBAL mm_ulong* RESTRICT fieldGradientPolarS\n"
"    #endif\n"
"#endif\n"
"        ) {\n"
"    ATOMIC_ADD(&field[index], (mm_ulong) ((mm_long) (data.field.x*0x100000000)));\n"
"    ATOMIC_ADD(&field[index+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.y*0x100000000)));\n"
"    ATOMIC_ADD(&field[index+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.field.z*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolar[index], (mm_ulong) ((mm_long) (data.fieldPolar.x*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolar[index+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.y*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolar[index+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"    ATOMIC_ADD(&fieldS[index], (mm_ulong) ((mm_long) (data.fieldS.x*0x100000000)));\n"
"    ATOMIC_ADD(&fieldS[index+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldS.y*0x100000000)));\n"
"    ATOMIC_ADD(&fieldS[index+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldS.z*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolarS[index], (mm_ulong) ((mm_long) (data.fieldPolarS.x*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolarS[index+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolarS.y*0x100000000)));\n"
"    ATOMIC_ADD(&fieldPolarS[index+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.fieldPolarS.z*0x100000000)));\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    for (int i = 0; i < 6; i++) {\n"
"        ATOMIC_ADD(&fieldGradient[6*index+i], (mm_ulong) ((mm_long) (data.fieldGradient[i]*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*index+i], (mm_ulong) ((mm_long) (data.fieldGradientPolar[i]*0x100000000)));\n"
"#ifdef USE_GK\n"
"        ATOMIC_ADD(&fieldGradientS[6*index+i], (mm_ulong) ((mm_long) (data.fieldGradientS[i]*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolarS[6*index+i], (mm_ulong) ((mm_long) (data.fieldGradientPolarS[i]*0x100000000)));\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#ifdef USE_EWALD\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    if (isSelfInteraction)\n"
"        return;\n"
"    real scale1, scale2, scale3;\n"
"    real r2 = dot(deltaR, deltaR);\n"
"    if (r2 < CUTOFF_SQUARED) {\n"
"        real rI = RSQRT(r2);\n"
"        real r = RECIP(rI);\n"
"        real rI2 = rI*rI;\n"
"\n"
"        // calculate the error function damping terms\n"
"\n"
"        real ralpha = EWALD_ALPHA*r;\n"
"        real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"        const real erfcAlphaR = erfc(ralpha);\n"
"#else\n"
"        // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"        // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"        // error of 1.5e-7.\n"
"\n"
"        const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"        const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"        real bn0 = erfcAlphaR*rI;\n"
"        real alsq2 = 2*EWALD_ALPHA*EWALD_ALPHA;\n"
"        real alsq2n = RECIP(SQRT_PI*EWALD_ALPHA);\n"
"        alsq2n *= alsq2;\n"
"        real bn1 = (bn0+alsq2n*exp2a)*rI2;\n"
"\n"
"        alsq2n *= alsq2;\n"
"        real bn2 = (3*bn1+alsq2n*exp2a)*rI2;\n"
"\n"
"        alsq2n *= alsq2;\n"
"        real bn3 = (5*bn2+alsq2n*exp2a)*rI2;\n"
"\n"
"        // compute the error function scaled and unscaled terms\n"
"\n"
"        real damp = atom1->damp*atom2->damp;\n"
"        real ratio = (r/damp);\n"
"        ratio = ratio*ratio*ratio;\n"
"        float pgamma = atom1->thole < atom2->thole ? atom1->thole : atom2->thole;\n"
"        damp = damp == 0 ? 0 : -pgamma*ratio;\n"
"        real expdamp = EXP(damp);\n"
"        real dsc3 = 1 - expdamp;\n"
"        real dsc5 = 1 - expdamp*(1-damp);\n"
"        real dsc7 = 1 - (1-damp+(0.6f*damp*damp))*expdamp;\n"
"        real r3 = (r*r2);\n"
"        real r5 = (r3*r2);\n"
"        real r7 = (r5*r2);\n"
"        real rr3 = (1-dsc3)/r3;\n"
"        real rr5 = 3*(1-dsc5)/r5;\n"
"        real rr7 = 15*(1-dsc7)/r7;\n"
"\n"
"        scale1 = rr3 - bn1;\n"
"        scale2 = bn2 - rr5;\n"
"        scale3 = bn3 - rr7;\n"
"    }\n"
"    else {\n"
"        scale1 = 0;\n"
"        scale2 = 0;\n"
"        scale3 = 0;\n"
"    }\n"
"    real dDotDelta = scale2*dot(deltaR, atom2->inducedDipole);\n"
"    atom1->field += scale1*atom2->inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom2->inducedDipolePolar);\n"
"    atom1->fieldPolar += scale1*atom2->inducedDipolePolar + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom1->inducedDipole);\n"
"    atom2->field += scale1*atom1->inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom1->inducedDipolePolar);\n"
"    atom2->fieldPolar += scale1*atom1->inducedDipolePolar + dDotDelta*deltaR;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    // Compute and store the field gradients for later use.\n"
"    \n"
"    real3 dipole = atom1->inducedDipole;\n"
"    real muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2->fieldGradient[0] -= (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom2->fieldGradient[1] -= (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom2->fieldGradient[2] -= (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom2->fieldGradient[3] -= (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom2->fieldGradient[4] -= (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom2->fieldGradient[5] -= (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom1->inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2->fieldGradientPolar[0] -= (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom2->fieldGradientPolar[1] -= (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom2->fieldGradientPolar[2] -= (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom2->fieldGradientPolar[3] -= (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom2->fieldGradientPolar[4] -= (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom2->fieldGradientPolar[5] -= (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom2->inducedDipole;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1->fieldGradient[0] += (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom1->fieldGradient[1] += (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom1->fieldGradient[2] += (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom1->fieldGradient[3] += (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom1->fieldGradient[4] += (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom1->fieldGradient[5] += (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom2->inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1->fieldGradientPolar[0] += (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom1->fieldGradientPolar[1] += (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom1->fieldGradientPolar[2] += (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom1->fieldGradientPolar[3] += (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom1->fieldGradientPolar[4] += (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom1->fieldGradientPolar[5] += (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"#endif\n"
"}\n"
"#elif defined USE_GK\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    real r2 = dot(deltaR, deltaR);\n"
"    real r = SQRT(r2);\n"
"    if (!isSelfInteraction) {\n"
"        real rI = RECIP(r);\n"
"        real r2I = rI*rI;\n"
"        real rr3 = -rI*r2I;\n"
"        real rr5 = -3*rr3*r2I;\n"
"\n"
"        real dampProd = atom1->damp*atom2->damp;\n"
"        real ratio = (dampProd != 0 ? r/dampProd : 1);\n"
"        float pGamma = (atom1->thole > atom2->thole ? atom2->thole: atom1->thole);\n"
"        real damp = ratio*ratio*ratio*pGamma;\n"
"        real dampExp = (dampProd != 0 ? EXP(-damp) : 0); \n"
"\n"
"        rr3 *= 1-dampExp;\n"
"        rr5 *= 1-(1+damp)*dampExp;\n"
"\n"
"        real dDotDelta = rr5*dot(deltaR, atom2->inducedDipole);\n"
"        atom1->field += rr3*atom2->inducedDipole + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2->inducedDipolePolar);\n"
"        atom1->fieldPolar += rr3*atom2->inducedDipolePolar + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1->inducedDipole);\n"
"        atom2->field += rr3*atom1->inducedDipole + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1->inducedDipolePolar);\n"
"        atom2->fieldPolar += rr3*atom1->inducedDipolePolar + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2->inducedDipoleS);\n"
"        atom1->fieldS += rr3*atom2->inducedDipoleS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2->inducedDipolePolarS);\n"
"        atom1->fieldPolarS += rr3*atom2->inducedDipolePolarS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1->inducedDipoleS);\n"
"        atom2->fieldS += rr3*atom1->inducedDipoleS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1->inducedDipolePolarS);\n"
"        atom2->fieldPolarS += rr3*atom1->inducedDipolePolarS + dDotDelta*deltaR;\n"
"    }\n"
"\n"
"    real rb2 = atom1->bornRadius*atom2->bornRadius;\n"
"    real expterm = EXP(-r2/(GK_C*rb2));\n"
"    real expc = expterm/GK_C; \n"
"    real gf2 = RECIP(r2+rb2*expterm);\n"
"    real gf = SQRT(gf2);\n"
"    real gf3 = gf2*gf;\n"
"    real gf5 = gf3*gf2;\n"
"    real a10 = -gf3;\n"
"    real expc1 = 1 - expc;\n"
"    real a11 = expc1 * 3 * gf5;\n"
"    real3 gux = GK_FD*make_real3(a10+deltaR.x*deltaR.x*a11, deltaR.x*deltaR.y*a11, deltaR.x*deltaR.z*a11);\n"
"    real3 guy = make_real3(gux.y, GK_FD*(a10+deltaR.y*deltaR.y*a11), GK_FD*deltaR.y*deltaR.z*a11);\n"
"    real3 guz = make_real3(gux.z, guy.z, GK_FD*(a10+deltaR.z*deltaR.z*a11));\n"
" \n"
"    atom1->fieldS += atom2->inducedDipoleS.x*gux+atom2->inducedDipoleS.y*guy+atom2->inducedDipoleS.z*guz;\n"
"    atom2->fieldS += atom1->inducedDipoleS.x*gux+atom1->inducedDipoleS.y*guy+atom1->inducedDipoleS.z*guz;\n"
"    atom1->fieldPolarS += atom2->inducedDipolePolarS.x*gux+atom2->inducedDipolePolarS.y*guy+atom2->inducedDipolePolarS.z*guz;\n"
"    atom2->fieldPolarS += atom1->inducedDipolePolarS.x*gux+atom1->inducedDipolePolarS.y*guy+atom1->inducedDipolePolarS.z*guz;\n"
"}\n"
"#else\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    if (isSelfInteraction)\n"
"        return;\n"
"    real rI = RSQRT(dot(deltaR, deltaR));\n"
"    real r = RECIP(rI);\n"
"    real r2I = rI*rI;\n"
"    real rr3 = -rI*r2I;\n"
"    real rr5 = -3*rr3*r2I;\n"
"    real rr7 = 5*rr5*r2I;\n"
"    real dampProd = atom1->damp*atom2->damp;\n"
"    real ratio = (dampProd != 0 ? r/dampProd : 1);\n"
"    float pGamma = (atom2->thole > atom1->thole ? atom1->thole: atom2->thole);\n"
"    real damp = ratio*ratio*ratio*pGamma;\n"
"    real dampExp = (dampProd != 0 ? EXP(-damp) : 0); \n"
"    rr3 *= 1 - dampExp;\n"
"    rr5 *= 1 - (1+damp)*dampExp;\n"
"    rr7 *= 1 - (1+damp+(0.6f*damp*damp))*dampExp;\n"
"    real dDotDelta = rr5*dot(deltaR, atom2->inducedDipole);\n"
"    atom1->field += rr3*atom2->inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom2->inducedDipolePolar);\n"
"    atom1->fieldPolar += rr3*atom2->inducedDipolePolar + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom1->inducedDipole);\n"
"    atom2->field += rr3*atom1->inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom1->inducedDipolePolar);\n"
"    atom2->fieldPolar += rr3*atom1->inducedDipolePolar + dDotDelta*deltaR;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    // Compute and store the field gradients for later use.\n"
"    \n"
"    real3 dipole = atom1->inducedDipole;\n"
"    real muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2->fieldGradient[0] -= (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom2->fieldGradient[1] -= (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom2->fieldGradient[2] -= (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom2->fieldGradient[3] -= (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom2->fieldGradient[4] -= (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom2->fieldGradient[5] -= (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom1->inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2->fieldGradientPolar[0] -= (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom2->fieldGradientPolar[1] -= (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom2->fieldGradientPolar[2] -= (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom2->fieldGradientPolar[3] -= (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom2->fieldGradientPolar[4] -= (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom2->fieldGradientPolar[5] -= (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom2->inducedDipole;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1->fieldGradient[0] += (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom1->fieldGradient[1] += (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom1->fieldGradient[2] += (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom1->fieldGradient[3] += (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom1->fieldGradient[4] += (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom1->fieldGradient[5] += (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom2->inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1->fieldGradientPolar[0] += (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom1->fieldGradientPolar[1] += (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom1->fieldGradientPolar[2] += (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom1->fieldGradientPolar[3] += (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom1->fieldGradientPolar[4] += (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom1->fieldGradientPolar[5] += (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"/**\n"
" * Compute the mutual induced field.\n"
" */\n"
"KERNEL void computeInducedField(\n"
"        GLOBAL mm_ulong* RESTRICT field, GLOBAL mm_ulong* RESTRICT fieldPolar, GLOBAL const real4* RESTRICT posq, GLOBAL const int2* RESTRICT exclusionTiles, \n"
"        GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter, GLOBAL const unsigned int* RESTRICT interactingAtoms,\n"
"#elif defined USE_GK\n"
"        GLOBAL mm_ulong* RESTRICT fieldS, GLOBAL mm_ulong* RESTRICT fieldPolarS, GLOBAL const real* RESTRICT inducedDipoleS,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolarS, GLOBAL const real* RESTRICT bornRadii,\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        GLOBAL mm_ulong* RESTRICT fieldGradient, GLOBAL mm_ulong* RESTRICT fieldGradientPolar,\n"
"    #ifdef USE_GK\n"
"        GLOBAL mm_ulong* RESTRICT fieldGradientS, GLOBAL mm_ulong* RESTRICT fieldGradientPolarS,\n"
"    #endif\n"
"#endif\n"
"        GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"#ifdef USE_GK\n"
"        AtomData data = loadAtomData(atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"        AtomData data = loadAtomData(atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"        zeroAtomData(&data);\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].pos = data.pos;\n"
"            localData[LOCAL_ID].inducedDipole = data.inducedDipole;\n"
"            localData[LOCAL_ID].inducedDipolePolar = data.inducedDipolePolar;\n"
"            localData[LOCAL_ID].thole = data.thole;\n"
"            localData[LOCAL_ID].damp = data.damp;\n"
"#ifdef USE_GK\n"
"            localData[LOCAL_ID].inducedDipoleS = data.inducedDipoleS;\n"
"            localData[LOCAL_ID].inducedDipolePolarS = data.inducedDipolePolarS;\n"
"            localData[LOCAL_ID].bornRadius = data.bornRadius;\n"
"#endif\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+j].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(&data, &localData[tbx+j], delta, atom1 == atom2);\n"
"            }\n"
"            SYNC_WARPS;\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"#ifdef USE_GK\n"
"            localData[LOCAL_ID] = loadAtomData(y*TILE_SIZE+tgx, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            localData[LOCAL_ID] = loadAtomData(y*TILE_SIZE+tgx, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"            zeroAtomDataLocal(&localData[LOCAL_ID]);\n"
"            unsigned int tj = tgx;\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+tj].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], delta, false);\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"            SYNC_WARPS;\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        SAVE_ATOM_DATA(offset, data)\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            SAVE_ATOM_DATA(offset, localData[LOCAL_ID])\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(mm_long)numTileIndices/totalWarps : warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(mm_long)numTileIndices/totalWarps : (warp+1)*(mm_long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"    \n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"#ifdef USE_GK\n"
"            AtomData data = loadAtomData(atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            AtomData data = loadAtomData(atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"            zeroAtomData(&data);\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"#ifdef USE_GK\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"            zeroAtomDataLocal(&localData[LOCAL_ID]);\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+tj].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = atomIndices[tbx+tj];\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], delta, false);\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            SAVE_ATOM_DATA(offset, data)\n"
"#ifdef USE_CUTOFF\n"
"            offset = atomIndices[LOCAL_ID];\n"
"#else\n"
"            offset = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            SAVE_ATOM_DATA(offset, localData[LOCAL_ID])\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void recordInducedDipolesForDIIS(GLOBAL const mm_long* RESTRICT fixedField, GLOBAL const mm_long* RESTRICT fixedFieldPolar,\n"
"        GLOBAL const float* RESTRICT polarizability, GLOBAL float2* RESTRICT errors, GLOBAL real* RESTRICT prevErrors, GLOBAL real* RESTRICT matrix,\n"
"        GLOBAL const mm_long* RESTRICT fixedFieldS, GLOBAL const mm_long* RESTRICT inducedField, GLOBAL const mm_long* RESTRICT inducedFieldPolar,\n"
"        GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"        GLOBAL real* RESTRICT prevDipoles, GLOBAL real* RESTRICT prevDipolesPolar, int iteration, int isGK) {\n"
"    LOCAL real2 buffer[64];\n"
"    const real fieldScale = 1/(real) 0x100000000;\n"
"    real sumErrors = 0;\n"
"    real sumPolarErrors = 0;\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real scale = polarizability[atom];\n"
"        if (iteration >= MAX_PREV_DIIS_DIPOLES) {\n"
"            // We have filled up the buffer for previous dipoles, so shift them all over by one.\n"
"\n"
"            for (int i = 1; i < MAX_PREV_DIIS_DIPOLES; i++) {\n"
"                int index1 = atom+(i-1)*NUM_ATOMS;\n"
"                int index2 = atom+i*NUM_ATOMS;\n"
"                for (int j = 0; j < 3; j++) {\n"
"                    prevDipoles[3*index1+j] = prevDipoles[3*index2+j];\n"
"                    prevDipolesPolar[3*index1+j] = prevDipolesPolar[3*index2+j];\n"
"                    if (!isGK)\n"
"                        prevErrors[3*index1+j] = prevErrors[3*index2+j];\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        // Compute the new dipole, and record it along with the error.\n"
"\n"
"        real3 oldDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"        real3 oldDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"        real3 fixed = make_real3(fixedField[atom], fixedField[atom+PADDED_NUM_ATOMS], fixedField[atom+2*PADDED_NUM_ATOMS])*fieldScale;\n"
"        real3 fixedPolar = make_real3(fixedFieldPolar[atom], fixedFieldPolar[atom+PADDED_NUM_ATOMS], fixedFieldPolar[atom+2*PADDED_NUM_ATOMS])*fieldScale;\n"
"        real3 induced = make_real3(inducedField[atom], inducedField[atom+PADDED_NUM_ATOMS], inducedField[atom+2*PADDED_NUM_ATOMS])*fieldScale;\n"
"        real3 inducedPolar = make_real3(inducedFieldPolar[atom], inducedFieldPolar[atom+PADDED_NUM_ATOMS], inducedFieldPolar[atom+2*PADDED_NUM_ATOMS])*fieldScale;\n"
"        real3 fixedS = make_real3(0);\n"
"        if (isGK)\n"
"            fixedS = make_real3(fixedFieldS[atom], fixedFieldS[atom+PADDED_NUM_ATOMS], fixedFieldS[atom+2*PADDED_NUM_ATOMS])*fieldScale;\n"
"        real3 newDipole = scale*(fixed+fixedS+induced);\n"
"        real3 newDipolePolar = scale*(fixedPolar+fixedS+inducedPolar);\n"
"        int storePrevIndex = atom+min(iteration, MAX_PREV_DIIS_DIPOLES-1)*NUM_ATOMS;\n"
"        prevDipoles[3*storePrevIndex] = newDipole.x;\n"
"        prevDipoles[3*storePrevIndex+1] = newDipole.y;\n"
"        prevDipoles[3*storePrevIndex+2] = newDipole.z;\n"
"        prevDipolesPolar[3*storePrevIndex] = newDipolePolar.x;\n"
"        prevDipolesPolar[3*storePrevIndex+1] = newDipolePolar.y;\n"
"        prevDipolesPolar[3*storePrevIndex+2] = newDipolePolar.z;\n"
"        if (!isGK) {\n"
"            prevErrors[3*storePrevIndex] = newDipole.x-oldDipole.x;\n"
"            prevErrors[3*storePrevIndex+1] = newDipole.y-oldDipole.y;\n"
"            prevErrors[3*storePrevIndex+2] = newDipole.z-oldDipole.z;\n"
"        }\n"
"        real3 errors = (newDipole-oldDipole)*(newDipole-oldDipole);\n"
"        real3 errorsPolar = (newDipolePolar-oldDipolePolar)*(newDipolePolar-oldDipolePolar);\n"
"        sumErrors += errors.x + errors.y + errors.z;\n"
"        sumPolarErrors += errorsPolar.x + errorsPolar.y + errorsPolar.z;\n"
"    }\n"
"    \n"
"    // Sum the errors over threads and store the total for this block.\n"
"    \n"
"    buffer[LOCAL_ID] = make_real2(sumErrors, sumPolarErrors);\n"
"    SYNC_THREADS;\n"
"    for (int offset = 1; offset < LOCAL_SIZE; offset *= 2) {\n"
"        if (LOCAL_ID+offset < LOCAL_SIZE && (LOCAL_ID&(2*offset-1)) == 0) {\n"
"            buffer[LOCAL_ID].x += buffer[LOCAL_ID+offset].x;\n"
"            buffer[LOCAL_ID].y += buffer[LOCAL_ID+offset].y;\n"
"        }\n"
"        SYNC_THREADS;\n"
"    }\n"
"    if (LOCAL_ID == 0)\n"
"        errors[GROUP_ID] = make_float2((float) buffer[0].x, (float) buffer[0].y);\n"
"    \n"
"    if (iteration >= MAX_PREV_DIIS_DIPOLES && !isGK && GROUP_ID == 0) {\n"
"        // Shift over the existing matrix elements.\n"
"        \n"
"        for (int i = 0; i < MAX_PREV_DIIS_DIPOLES-1; i++) {\n"
"            if (LOCAL_ID < MAX_PREV_DIIS_DIPOLES-1)\n"
"                matrix[LOCAL_ID+i*MAX_PREV_DIIS_DIPOLES] = matrix[(LOCAL_ID+1)+(i+1)*MAX_PREV_DIIS_DIPOLES];\n"
"            SYNC_THREADS;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeDIISMatrix(GLOBAL real* RESTRICT prevErrors, int iteration, GLOBAL real* RESTRICT matrix) {\n"
"    LOCAL real sumBuffer[512];\n"
"    int j = min(iteration, MAX_PREV_DIIS_DIPOLES-1);\n"
"    for (int i = GROUP_ID; i <= j; i += NUM_GROUPS) {\n"
"        // All the threads in this thread block work together to compute a single matrix element.\n"
"\n"
"        real sum = 0;\n"
"        for (int index = LOCAL_ID; index < 3*NUM_ATOMS; index += LOCAL_SIZE)\n"
"            sum += prevErrors[index+i*3*NUM_ATOMS]*prevErrors[index+j*3*NUM_ATOMS];\n"
"        sumBuffer[LOCAL_ID] = sum;\n"
"        SYNC_THREADS;\n"
"        for (int offset = 1; offset < LOCAL_SIZE; offset *= 2) { \n"
"            if (LOCAL_ID+offset < LOCAL_SIZE && (LOCAL_ID&(2*offset-1)) == 0)\n"
"                sumBuffer[LOCAL_ID] += sumBuffer[LOCAL_ID+offset];\n"
"            SYNC_THREADS;\n"
"        }\n"
"        if (LOCAL_ID == 0) {\n"
"            matrix[i+MAX_PREV_DIIS_DIPOLES*j] = sumBuffer[0];\n"
"            if (i != j)\n"
"                matrix[j+MAX_PREV_DIIS_DIPOLES*i] = sumBuffer[0];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void solveDIISMatrix(int iteration, GLOBAL const real* RESTRICT matrix, GLOBAL float* RESTRICT coefficients) {\n"
"    LOCAL real b[MAX_PREV_DIIS_DIPOLES+1][MAX_PREV_DIIS_DIPOLES+1];\n"
"    LOCAL real piv[MAX_PREV_DIIS_DIPOLES+1];\n"
"    LOCAL real x[MAX_PREV_DIIS_DIPOLES+1];\n"
"\n"
"    // On the first iteration we don't need to do any calculation.\n"
"    \n"
"    if (iteration == 0) {\n"
"        if (LOCAL_ID == 0)\n"
"            coefficients[0] = 1;\n"
"        return;\n"
"    }\n"
"    \n"
"    // Load the matrix.\n"
"    \n"
"    int numPrev = min(iteration+1, MAX_PREV_DIIS_DIPOLES);\n"
"    int rank = numPrev+1;\n"
"    for (int index = LOCAL_ID; index < numPrev*numPrev; index += LOCAL_SIZE) {\n"
"        int i = index/numPrev;\n"
"        int j = index-i*numPrev;\n"
"        b[i+1][j+1] = matrix[i*MAX_PREV_DIIS_DIPOLES+j];\n"
"    }\n"
"    for (int i = LOCAL_ID; i < rank; i += LOCAL_SIZE) {\n"
"        b[i][0] = -1;\n"
"        piv[i] = i;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    \n"
"    // Compute the mean absolute value of the values we just loaded.  We use that for preconditioning it,\n"
"    // which is essential for doing the computation in single precision.\n"
"    \n"
"    if (LOCAL_ID == 0) {\n"
"        real mean = 0;\n"
"        for (int i = 0; i < numPrev; i++)\n"
"            for (int j = 0; j < numPrev; j++)\n"
"                mean += fabs(b[i+1][j+1]);\n"
"        mean /= numPrev*numPrev;\n"
"        b[0][0] = 0;\n"
"        for (int i = 1; i < rank; i++)\n"
"            b[0][i] = -mean;\n"
"\n"
"        // Compute the LU decomposition of the matrix.  This code is adapted from JAMA.\n"
"    \n"
"        int pivsign = 1;\n"
"        for (int j = 0; j < rank; j++) {\n"
"            // Apply previous transformations.\n"
"\n"
"            for (int i = 0; i < rank; i++) {\n"
"                // Most of the time is spent in the following dot product.\n"
"\n"
"                int kmax = min(i, j);\n"
"                real s = 0;\n"
"                for (int k = 0; k < kmax; k++)\n"
"                    s += b[i][k] * b[k][j];\n"
"                b[i][j] -= s;\n"
"            }\n"
"\n"
"            // Find pivot and exchange if necessary.\n"
"\n"
"            int p = j;\n"
"            for (int i = j+1; i < rank; i++)\n"
"                if (fabs(b[i][j]) > fabs(b[p][j]))\n"
"                    p = i;\n"
"            if (p != j) {\n"
"                int k = 0;\n"
"                for (k = 0; k < rank; k++) {\n"
"                    real t = b[p][k];\n"
"                    b[p][k] = b[j][k];\n"
"                    b[j][k] = t;\n"
"                }\n"
"                k = piv[p];\n"
"                piv[p] = piv[j];\n"
"                piv[j] = k;\n"
"                pivsign = -pivsign;\n"
"            }\n"
"\n"
"            // Compute multipliers.\n"
"\n"
"            if ((j < rank) && (b[j][j] != 0))\n"
"                for (int i = j+1; i < rank; i++)\n"
"                    b[i][j] /= b[j][j];\n"
"        }\n"
"        for (int i = 0; i < rank; i++)\n"
"            if (b[i][i] == 0) {\n"
"                // The matrix is singular.\n"
"                \n"
"                for (int j = 0; j < rank-1; j++)\n"
"                    coefficients[j] = 0;\n"
"                coefficients[rank-1] = 1;\n"
"                return;\n"
"            }\n"
"\n"
"        // Solve b*Y = X(piv)\n"
"        \n"
"        for (int i = 0; i < rank; i++) \n"
"            x[i] = (piv[i] == 0 ? -1 : 0);\n"
"        for (int k = 0; k < rank; k++)\n"
"            for (int i = k+1; i < rank; i++)\n"
"                x[i] -= x[k] * b[i][k];\n"
"\n"
"        // Solve U*X = Y;\n"
"        \n"
"        for (int k = rank-1; k >= 0; k--) {\n"
"            x[k] /= b[k][k];\n"
"            for (int i = 0; i < k; i++)\n"
"                x[i] -= x[k] * b[i][k];\n"
"        }\n"
"        \n"
"        // Record the coefficients.\n"
"        \n"
"        real lastCoeff = 1;\n"
"        for (int i = 0; i < rank-1; i++) {\n"
"            real c = x[i+1]*mean;\n"
"            coefficients[i] = c;\n"
"            lastCoeff -= c;\n"
"        }\n"
"        coefficients[rank-1] = lastCoeff;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void updateInducedFieldByDIIS(GLOBAL real* RESTRICT inducedDipole, GLOBAL real* RESTRICT inducedDipolePolar, \n"
"        GLOBAL const real* RESTRICT prevDipoles, GLOBAL const real* RESTRICT prevDipolesPolar, GLOBAL const float* RESTRICT coefficients, int numPrev) {\n"
"    for (int index = GLOBAL_ID; index < 3*NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        real sum = 0;\n"
"        real sumPolar = 0;\n"
"        for (int i = 0; i < numPrev; i++) {\n"
"            sum += coefficients[i]*prevDipoles[i*3*NUM_ATOMS+index];\n"
"            sumPolar += coefficients[i]*prevDipolesPolar[i*3*NUM_ATOMS+index];\n"
"        }\n"
"        inducedDipole[index] = sum;\n"
"        inducedDipolePolar[index] = sumPolar;\n"
"    }\n"
"}\n"
"#endif // not HIPPO\n"
"\n"
"KERNEL void initExtrapolatedDipoles(GLOBAL real* RESTRICT inducedDipole, GLOBAL real* RESTRICT extrapolatedDipole\n"
"#ifndef HIPPO\n"
"        , GLOBAL real* RESTRICT inducedDipolePolar, GLOBAL real* RESTRICT extrapolatedDipolePolar, GLOBAL mm_long* RESTRICT inducedDipoleFieldGradient, GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientPolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , GLOBAL real* RESTRICT inducedDipoleGk, GLOBAL real* RESTRICT inducedDipoleGkPolar, GLOBAL real* RESTRICT extrapolatedDipoleGk, GLOBAL real* RESTRICT extrapolatedDipoleGkPolar,\n"
"        GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientGk, GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientGkPolar\n"
"#endif\n"
"        ) {\n"
"    for (int index = GLOBAL_ID; index < 3*NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        extrapolatedDipole[index] = inducedDipole[index];\n"
"#ifndef HIPPO\n"
"        extrapolatedDipolePolar[index] = inducedDipolePolar[index];\n"
"#endif\n"
"#ifdef USE_GK\n"
"        extrapolatedDipoleGk[index] = inducedDipoleGk[index];\n"
"        extrapolatedDipoleGkPolar[index] = inducedDipoleGkPolar[index];\n"
"#endif\n"
"    }\n"
"#ifndef HIPPO\n"
"    for (int index = GLOBAL_ID; index < 6*NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        inducedDipoleFieldGradient[index] = 0;\n"
"        inducedDipoleFieldGradientPolar[index] = 0;\n"
"#ifdef USE_GK\n"
"        inducedDipoleFieldGradientGk[index] = 0;\n"
"        inducedDipoleFieldGradientGkPolar[index] = 0;\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"KERNEL void iterateExtrapolatedDipoles(int order, GLOBAL real* RESTRICT inducedDipole, GLOBAL real* RESTRICT extrapolatedDipole, GLOBAL mm_long* RESTRICT inducedDipoleField,\n"
"#ifndef HIPPO\n"
"        GLOBAL real* RESTRICT inducedDipolePolar, GLOBAL real* RESTRICT extrapolatedDipolePolar, GLOBAL mm_long* RESTRICT inducedDipoleFieldPolar, GLOBAL mm_long* RESTRICT inducedDipoleFieldGradient,\n"
"        GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientPolar, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradient, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientPolar,\n"
"#endif\n"
"#ifdef USE_GK\n"
"        GLOBAL real* RESTRICT inducedDipoleGk, GLOBAL real* RESTRICT inducedDipoleGkPolar, GLOBAL real* RESTRICT extrapolatedDipoleGk, GLOBAL real* RESTRICT extrapolatedDipoleGkPolar,\n"
"        GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientGk, GLOBAL mm_long* RESTRICT inducedDipoleFieldGradientGkPolar, GLOBAL mm_long* RESTRICT inducedDipoleFieldGk,\n"
"        GLOBAL mm_long* RESTRICT inducedDipoleFieldGkPolar, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientGk, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientGkPolar,\n"
"#endif\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT polarizability\n"
"#else\n"
"        GLOBAL const float* RESTRICT polarizability\n"
"#endif\n"
"    ) {\n"
"    const real fieldScale = 1/(real) 0x100000000;\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        float polar = polarizability[atom];\n"
"        real3 value = make_real3(inducedDipoleField[atom], inducedDipoleField[atom+PADDED_NUM_ATOMS], inducedDipoleField[atom+2*PADDED_NUM_ATOMS])*fieldScale*polar;\n"
"        inducedDipole[3*atom] = value.x;\n"
"        inducedDipole[3*atom+1] = value.y;\n"
"        inducedDipole[3*atom+2] = value.z;\n"
"        extrapolatedDipole[3*(order*NUM_ATOMS+atom)] = value.x;\n"
"        extrapolatedDipole[3*(order*NUM_ATOMS+atom)+1] = value.y;\n"
"        extrapolatedDipole[3*(order*NUM_ATOMS+atom)+2] = value.z;\n"
"#ifndef HIPPO\n"
"        value = make_real3(inducedDipoleFieldPolar[atom], inducedDipoleFieldPolar[atom+PADDED_NUM_ATOMS], inducedDipoleFieldPolar[atom+2*PADDED_NUM_ATOMS])*fieldScale*polar;\n"
"        inducedDipolePolar[3*atom] = value.x;\n"
"        inducedDipolePolar[3*atom+1] = value.y;\n"
"        inducedDipolePolar[3*atom+2] = value.z;\n"
"        extrapolatedDipolePolar[3*(order*NUM_ATOMS+atom)] = value.x;\n"
"        extrapolatedDipolePolar[3*(order*NUM_ATOMS+atom)+1] = value.y;\n"
"        extrapolatedDipolePolar[3*(order*NUM_ATOMS+atom)+2] = value.z;\n"
"#endif\n"
"#ifdef USE_GK\n"
"        value = make_real3(inducedDipoleFieldGk[atom], inducedDipoleFieldGk[atom+PADDED_NUM_ATOMS], inducedDipoleFieldGk[atom+2*PADDED_NUM_ATOMS])*fieldScale*polar;\n"
"        inducedDipoleGk[3*atom] = value.x;\n"
"        inducedDipoleGk[3*atom+1] = value.y;\n"
"        inducedDipoleGk[3*atom+2] = value.z;\n"
"        extrapolatedDipoleGk[3*(order*NUM_ATOMS+atom)] = value.x;\n"
"        extrapolatedDipoleGk[3*(order*NUM_ATOMS+atom)+1] = value.y;\n"
"        extrapolatedDipoleGk[3*(order*NUM_ATOMS+atom)+2] = value.z;\n"
"        value = make_real3(inducedDipoleFieldGkPolar[atom], inducedDipoleFieldGkPolar[atom+PADDED_NUM_ATOMS], inducedDipoleFieldGkPolar[atom+2*PADDED_NUM_ATOMS])*fieldScale*polar;\n"
"        inducedDipoleGkPolar[3*atom] = value.x;\n"
"        inducedDipoleGkPolar[3*atom+1] = value.y;\n"
"        inducedDipoleGkPolar[3*atom+2] = value.z;\n"
"        extrapolatedDipoleGkPolar[3*(order*NUM_ATOMS+atom)] = value.x;\n"
"        extrapolatedDipoleGkPolar[3*(order*NUM_ATOMS+atom)+1] = value.y;\n"
"        extrapolatedDipoleGkPolar[3*(order*NUM_ATOMS+atom)+2] = value.z;\n"
"#endif\n"
"    }\n"
"#ifndef HIPPO\n"
"    for (int index = GLOBAL_ID; index < 2*NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        int index2 = (order-1)*2*NUM_ATOMS+index;\n"
"        for (int i = 0; i < 3; i++) {\n"
"            extrapolatedDipoleFieldGradient[3*index2+i] = fieldScale*inducedDipoleFieldGradient[3*index+i];\n"
"            extrapolatedDipoleFieldGradientPolar[3*index2+i] = fieldScale*inducedDipoleFieldGradientPolar[3*index+i];\n"
"#ifdef USE_GK\n"
"            extrapolatedDipoleFieldGradientGk[3*index2+i] = fieldScale*inducedDipoleFieldGradientGk[3*index+i];\n"
"            extrapolatedDipoleFieldGradientGkPolar[3*index2+i] = fieldScale*inducedDipoleFieldGradientGkPolar[3*index+i];\n"
"#endif\n"
"        }\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"KERNEL void computeExtrapolatedDipoles(GLOBAL real* RESTRICT inducedDipole, GLOBAL real* RESTRICT extrapolatedDipole\n"
"#ifndef HIPPO\n"
"        , GLOBAL real* RESTRICT inducedDipolePolar, GLOBAL real* RESTRICT extrapolatedDipolePolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , GLOBAL real* RESTRICT inducedDipoleGk, GLOBAL real* RESTRICT inducedDipoleGkPolar, GLOBAL real* RESTRICT extrapolatedDipoleGk, GLOBAL real* RESTRICT extrapolatedDipoleGkPolar\n"
"#endif\n"
"        ) {\n"
"    real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"    for (int index = GLOBAL_ID; index < 3*NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        real sum = 0, sumPolar = 0, sumGk = 0, sumGkPolar = 0;\n"
"        for (int order = 0; order < MAX_EXTRAPOLATION_ORDER; order++) {\n"
"            sum += extrapolatedDipole[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#ifndef HIPPO\n"
"            sumPolar += extrapolatedDipolePolar[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#endif\n"
"#ifdef USE_GK\n"
"            sumGk += extrapolatedDipoleGk[order*3*NUM_ATOMS+index]*coeff[order];\n"
"            sumGkPolar += extrapolatedDipoleGkPolar[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#endif\n"
"        }\n"
"        inducedDipole[index] = sum;\n"
"#ifndef HIPPO\n"
"        inducedDipolePolar[index] = sumPolar;\n"
"#endif\n"
"#ifdef USE_GK\n"
"        inducedDipoleGk[index] = sumGk;\n"
"        inducedDipoleGkPolar[index] = sumGkPolar;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"KERNEL void addExtrapolatedFieldGradientToForce(GLOBAL mm_long* RESTRICT forceBuffers, GLOBAL real* RESTRICT extrapolatedDipole,\n"
"        GLOBAL real* RESTRICT extrapolatedDipolePolar, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradient, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientPolar\n"
"#ifdef USE_GK\n"
"        , GLOBAL real* RESTRICT extrapolatedDipoleGk, GLOBAL real* RESTRICT extrapolatedDipoleGkPolar,\n"
"        GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientGk, GLOBAL real* RESTRICT extrapolatedDipoleFieldGradientGkPolar\n"
"#endif\n"
"        ) {\n"
"    real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real fx = 0, fy = 0, fz = 0;\n"
"        for (int l = 0; l < MAX_EXTRAPOLATION_ORDER-1; l++) {\n"
"            int index1 = 3*(l*NUM_ATOMS+atom);\n"
"            real dipole[] = {extrapolatedDipole[index1], extrapolatedDipole[index1+1], extrapolatedDipole[index1+2]};\n"
"            real dipolePolar[] = {extrapolatedDipolePolar[index1], extrapolatedDipolePolar[index1+1], extrapolatedDipolePolar[index1+2]};\n"
"#ifdef USE_GK\n"
"            real dipoleGk[] = {extrapolatedDipoleGk[index1], extrapolatedDipoleGk[index1+1], extrapolatedDipoleGk[index1+2]};\n"
"            real dipoleGkPolar[] = {extrapolatedDipoleGkPolar[index1], extrapolatedDipoleGkPolar[index1+1], extrapolatedDipoleGkPolar[index1+2]};\n"
"#endif\n"
"            for (int m = 0; m < MAX_EXTRAPOLATION_ORDER-1-l; m++) {\n"
"                int index2 = 6*(m*NUM_ATOMS+atom);\n"
"                real scale = 0.5f*coeff[l+m+1]*ENERGY_SCALE_FACTOR;\n"
"                real gradient[] = {extrapolatedDipoleFieldGradient[index2], extrapolatedDipoleFieldGradient[index2+1], extrapolatedDipoleFieldGradient[index2+2],\n"
"                                   extrapolatedDipoleFieldGradient[index2+3], extrapolatedDipoleFieldGradient[index2+4], extrapolatedDipoleFieldGradient[index2+5]};\n"
"                real gradientPolar[] = {extrapolatedDipoleFieldGradientPolar[index2], extrapolatedDipoleFieldGradientPolar[index2+1], extrapolatedDipoleFieldGradientPolar[index2+2],\n"
"                                        extrapolatedDipoleFieldGradientPolar[index2+3], extrapolatedDipoleFieldGradientPolar[index2+4], extrapolatedDipoleFieldGradientPolar[index2+5]};\n"
"                fx += scale*(dipole[0]*gradientPolar[0] + dipole[1]*gradientPolar[3] + dipole[2]*gradientPolar[4]);\n"
"                fy += scale*(dipole[0]*gradientPolar[3] + dipole[1]*gradientPolar[1] + dipole[2]*gradientPolar[5]);\n"
"                fz += scale*(dipole[0]*gradientPolar[4] + dipole[1]*gradientPolar[5] + dipole[2]*gradientPolar[2]);\n"
"                fx += scale*(dipolePolar[0]*gradient[0] + dipolePolar[1]*gradient[3] + dipolePolar[2]*gradient[4]);\n"
"                fy += scale*(dipolePolar[0]*gradient[3] + dipolePolar[1]*gradient[1] + dipolePolar[2]*gradient[5]);\n"
"                fz += scale*(dipolePolar[0]*gradient[4] + dipolePolar[1]*gradient[5] + dipolePolar[2]*gradient[2]);\n"
"#ifdef USE_GK\n"
"                real gradientGk[] = {extrapolatedDipoleFieldGradient[index2], extrapolatedDipoleFieldGradient[index2+1], extrapolatedDipoleFieldGradient[index2+2],\n"
"                                   extrapolatedDipoleFieldGradient[index2+3], extrapolatedDipoleFieldGradient[index2+4], extrapolatedDipoleFieldGradient[index2+5]};\n"
"                real gradientGkPolar[] = {extrapolatedDipoleFieldGradientPolar[index2], extrapolatedDipoleFieldGradientPolar[index2+1], extrapolatedDipoleFieldGradientPolar[index2+2],\n"
"                                        extrapolatedDipoleFieldGradientPolar[index2+3], extrapolatedDipoleFieldGradientPolar[index2+4], extrapolatedDipoleFieldGradientPolar[index2+5]};\n"
"                fx += scale*(dipoleGk[0]*gradientGkPolar[0] + dipoleGk[1]*gradientGkPolar[3] + dipoleGk[2]*gradientGkPolar[4]);\n"
"                fy += scale*(dipoleGk[0]*gradientGkPolar[3] + dipoleGk[1]*gradientGkPolar[1] + dipoleGk[2]*gradientGkPolar[5]);\n"
"                fz += scale*(dipoleGk[0]*gradientGkPolar[4] + dipoleGk[1]*gradientGkPolar[5] + dipoleGk[2]*gradientGkPolar[2]);\n"
"                fx += scale*(dipoleGkPolar[0]*gradientGk[0] + dipoleGkPolar[1]*gradientGk[3] + dipoleGkPolar[2]*gradientGk[4]);\n"
"                fy += scale*(dipoleGkPolar[0]*gradientGk[3] + dipoleGkPolar[1]*gradientGk[1] + dipoleGkPolar[2]*gradientGk[5]);\n"
"                fz += scale*(dipoleGkPolar[0]*gradientGk[4] + dipoleGkPolar[1]*gradientGk[5] + dipoleGkPolar[2]*gradientGk[2]);\n"
"#endif\n"
"            }\n"
"        }\n"
"        forceBuffers[atom] += (mm_long) (fx*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] += (mm_long) (fy*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS*2] += (mm_long) (fz*0x100000000);\n"
"    }\n"
"}\n"
"\n"
"#ifdef HIPPO\n"
"KERNEL void computePolarizationEnergy(GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT extrapolatedDipole, GLOBAL const real* RESTRICT polarizability) {\n"
"    mixed energy = 0;\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE)\n"
"        for (int i = 0; i < 3; i++)\n"
"            energy -= (ENERGY_SCALE_FACTOR/2)*extrapolatedDipole[3*atom+i]*inducedDipole[3*atom+i]/polarizability[atom];\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"#endif";
const string CommonAmoebaKernelSources::multipolePme = "#define ARRAY(x,y) array[(x)-1+((y)-1)*PME_ORDER]\n"
"\n"
"/**\n"
" * Calculate the spline coefficients for a single atom along a single axis.\n"
" */\n"
"DEVICE void computeBSplinePoint(real4* thetai, real w, real* array) {\n"
"    // initialization to get to 2nd order recursion\n"
"\n"
"    ARRAY(2,2) = w;\n"
"    ARRAY(2,1) = 1 - w;\n"
"\n"
"    // perform one pass to get to 3rd order recursion\n"
"\n"
"    ARRAY(3,3) = 0.5f * w * ARRAY(2,2);\n"
"    ARRAY(3,2) = 0.5f * ((1+w)*ARRAY(2,1)+(2-w)*ARRAY(2,2));\n"
"    ARRAY(3,1) = 0.5f * (1-w) * ARRAY(2,1);\n"
"\n"
"    // compute standard B-spline recursion to desired order\n"
"\n"
"    for (int i = 4; i <= PME_ORDER; i++)\n"
"    {\n"
"        int k = i - 1;\n"
"        real denom = RECIP((real) k);\n"
"        ARRAY(i,i) = denom * w * ARRAY(k,k);\n"
"        for (int j = 1; j <= i-2; j++)\n"
"            ARRAY(i,i-j) = denom * ((w+j)*ARRAY(k,i-j-1)+(i-j-w)*ARRAY(k,i-j));\n"
"        ARRAY(i,1) = denom * (1-w) * ARRAY(k,1);\n"
"    }\n"
"\n"
"    // get coefficients for the B-spline first derivative\n"
"\n"
"    int k = PME_ORDER - 1;\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // get coefficients for the B-spline second derivative\n"
"\n"
"    k = PME_ORDER - 2;\n"
"    ARRAY(k,PME_ORDER-1) = ARRAY(k,PME_ORDER-2);\n"
"    for (int i = PME_ORDER-2; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // get coefficients for the B-spline third derivative\n"
"\n"
"    k = PME_ORDER - 3;\n"
"    ARRAY(k,PME_ORDER-2) = ARRAY(k,PME_ORDER-3);\n"
"    for (int i = PME_ORDER-3; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER-1) = ARRAY(k,PME_ORDER-2);\n"
"    for (int i = PME_ORDER-2; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // copy coefficients from temporary to permanent storage\n"
"\n"
"    for (int i = 1; i <= PME_ORDER; i++)\n"
"        thetai[i-1] = make_real4(ARRAY(PME_ORDER,i), ARRAY(PME_ORDER-1,i), ARRAY(PME_ORDER-2,i), ARRAY(PME_ORDER-3,i));\n"
"}\n"
"\n"
"/**\n"
" * Convert the fixed multipoles from Cartesian to fractional coordinates.\n"
" */\n"
"KERNEL void transformMultipolesToFractionalCoordinates(GLOBAL const real* RESTRICT labDipole,\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT labQXX, GLOBAL const real* RESTRICT labQXY, GLOBAL const real* RESTRICT labQXZ, GLOBAL const real* RESTRICT labQYY, GLOBAL const real* RESTRICT labQYZ,\n"
"#else\n"
"        GLOBAL const real* RESTRICT labQuadrupole,\n"
"#endif\n"
"        GLOBAL real* RESTRICT fracDipole, GLOBAL real* RESTRICT fracQuadrupole, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // Build matrices for transforming the dipoles and quadrupoles.\n"
"    \n"
"    LOCAL real a[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        a[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        a[0][1] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        a[0][2] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        a[1][0] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        a[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        a[1][2] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        a[2][0] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        a[2][1] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        a[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    int index1[] = {0, 0, 0, 1, 1, 2};\n"
"    int index2[] = {0, 1, 2, 1, 2, 2};\n"
"    LOCAL real b[6][6];\n"
"    if (LOCAL_ID < 36) {\n"
"        int i = LOCAL_ID/6;\n"
"        int j = LOCAL_ID-6*i;\n"
"        b[i][j] = a[index1[i]][index1[j]]*a[index2[i]][index2[j]];\n"
"        if (index1[i] != index2[i])\n"
"            b[i][j] += a[index1[i]][index2[j]]*a[index2[i]][index1[j]];\n"
"    }\n"
"    SYNC_THREADS;\n"
"    \n"
"    // Transform the multipoles.\n"
"    \n"
"    real quadScale[] = {1, 2, 2, 1, 2, 1};\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        for (int j = 0; j < 3; j++) {\n"
"            real dipole = 0;\n"
"            for (int k = 0; k < 3; k++)\n"
"                dipole += a[j][k]*labDipole[3*i+k];\n"
"            fracDipole[3*i+j] = dipole;\n"
"        }\n"
"        for (int j = 0; j < 6; j++) {\n"
"#ifdef HIPPO\n"
"            real quadrupole = quadScale[0]*b[j][0]*labQXX[i] +\n"
"                              quadScale[1]*b[j][1]*labQXY[i] +\n"
"                              quadScale[2]*b[j][2]*labQXZ[i] +\n"
"                              quadScale[3]*b[j][3]*labQYY[i] +\n"
"                              quadScale[4]*b[j][4]*labQYZ[i] -\n"
"                              quadScale[5]*b[j][5]*(labQXX[i]+labQYY[i]);\n"
"#else\n"
"            real quadrupole = 0;\n"
"            for (int k = 0; k < 5; k++)\n"
"                quadrupole += quadScale[k]*b[j][k]*labQuadrupole[5*i+k];\n"
"            quadrupole -= quadScale[5]*b[j][5]*(labQuadrupole[5*i]+labQuadrupole[5*i+3]);\n"
"#endif\n"
"            fracQuadrupole[6*i+j] = quadrupole;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Convert the potential from fractional to Cartesian coordinates.\n"
" */\n"
"KERNEL void transformPotentialToCartesianCoordinates(GLOBAL const real* RESTRICT fphi, GLOBAL real* RESTRICT cphi, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // Build matrices for transforming the potential.\n"
"\n"
"    LOCAL real a[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        a[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        a[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        a[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        a[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        a[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        a[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        a[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        a[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        a[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    int index1[] = {0, 1, 2, 0, 0, 1};\n"
"    int index2[] = {0, 1, 2, 1, 2, 2};\n"
"    LOCAL real b[6][6];\n"
"    if (LOCAL_ID < 36) {\n"
"        int i = LOCAL_ID/6;\n"
"        int j = LOCAL_ID-6*i;\n"
"        b[i][j] = a[index1[i]][index1[j]]*a[index2[i]][index2[j]];\n"
"        if (index1[j] != index2[j])\n"
"            b[i][j] += (i < 3 ? b[i][j] : a[index1[i]][index2[j]]*a[index2[i]][index1[j]]);\n"
"    }\n"
"    SYNC_THREADS;\n"
"\n"
"    // Transform the potential.\n"
"    \n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        cphi[10*i] = fphi[i];\n"
"        cphi[10*i+1] = a[0][0]*fphi[i+NUM_ATOMS*1] + a[0][1]*fphi[i+NUM_ATOMS*2] + a[0][2]*fphi[i+NUM_ATOMS*3];\n"
"        cphi[10*i+2] = a[1][0]*fphi[i+NUM_ATOMS*1] + a[1][1]*fphi[i+NUM_ATOMS*2] + a[1][2]*fphi[i+NUM_ATOMS*3];\n"
"        cphi[10*i+3] = a[2][0]*fphi[i+NUM_ATOMS*1] + a[2][1]*fphi[i+NUM_ATOMS*2] + a[2][2]*fphi[i+NUM_ATOMS*3];\n"
"        for (int j = 0; j < 6; j++) {\n"
"            cphi[10*i+4+j] = 0;\n"
"            for (int k = 0; k < 6; k++)\n"
"                cphi[10*i+4+j] += b[j][k]*fphi[i+NUM_ATOMS*(4+k)];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void gridSpreadFixedMultipoles(GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT fracDipole,\n"
"        GLOBAL const real* RESTRICT fracQuadrupole,\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"        GLOBAL mm_ulong* RESTRICT pmeGrid,\n"
"#elif defined(HIPPO)\n"
"        GLOBAL real* RESTRICT pmeGrid,\n"
"#else\n"
"        GLOBAL real2* RESTRICT pmeGrid,\n"
"#endif\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT coreCharge, GLOBAL const real* RESTRICT valenceCharge,\n"
"#endif\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    LOCAL real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*LOCAL_ID];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    \n"
"    for (int m = GLOBAL_ID; m < NUM_ATOMS; m += GLOBAL_SIZE) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"#ifdef HIPPO\n"
"        real atomCharge = coreCharge[m]+valenceCharge[m];\n"
"#else\n"
"        real atomCharge = pos.w;\n"
"#endif\n"
"        real atomDipoleX = fracDipole[m*3];\n"
"        real atomDipoleY = fracDipole[m*3+1];\n"
"        real atomDipoleZ = fracDipole[m*3+2];\n"
"        real atomQuadrupoleXX = fracQuadrupole[m*6];\n"
"        real atomQuadrupoleXY = fracQuadrupole[m*6+1];\n"
"        real atomQuadrupoleXZ = fracQuadrupole[m*6+2];\n"
"        real atomQuadrupoleYY = fracQuadrupole[m*6+3];\n"
"        real atomQuadrupoleYZ = fracQuadrupole[m*6+4];\n"
"        real atomQuadrupoleZZ = fracQuadrupole[m*6+5];\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"        \n"
"        // Spread the charge from this atom onto each grid point.\n"
"         \n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = igrid1+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"            real4 t = theta1[ix];\n"
"            \n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = igrid2+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = xbase + ybase*GRID_SIZE_Z;\n"
"                real4 u = theta2[iy];\n"
"                real term0 = atomCharge*t.x*u.x + atomDipoleY*t.x*u.y + atomQuadrupoleYY*t.x*u.z + atomDipoleX*t.y*u.x + atomQuadrupoleXY*t.y*u.y + atomQuadrupoleXX*t.z*u.x;\n"
"                real term1 = atomDipoleZ*t.x*u.x + atomQuadrupoleYZ*t.x*u.y + atomQuadrupoleXZ*t.y*u.x;\n"
"                real term2 = atomQuadrupoleZZ*t.x*u.x;\n"
"                \n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = igrid3+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = ybase + zindex;\n"
"                    real4 v = theta3[iz];\n"
"                    real add = term0*v.x + term1*v.y + term2*v.z;\n"
"#ifdef HIPPO\n"
"    #ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"                    ATOMIC_ADD(&pmeGrid[index], (mm_ulong) ((mm_long) (add*0x100000000)));\n"
"    #else\n"
"                    ATOMIC_ADD(&pmeGrid[index], add);\n"
"    #endif\n"
"#else\n"
"    #ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"                    ATOMIC_ADD(&pmeGrid[2*index], (mm_ulong) ((mm_long) (add*0x100000000)));\n"
"    #else\n"
"                    ATOMIC_ADD(&pmeGrid[index].x, add);\n"
"    #endif\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void gridSpreadInducedDipoles(GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT inducedDipole,\n"
"#ifndef HIPPO\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"#endif\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"        GLOBAL mm_ulong* RESTRICT pmeGrid,\n"
"#elif defined(HIPPO)\n"
"        GLOBAL real* RESTRICT pmeGrid,\n"
"#else\n"
"        GLOBAL real2* RESTRICT pmeGrid,\n"
"#endif\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    LOCAL real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*LOCAL_ID];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    LOCAL real cartToFrac[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        cartToFrac[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        cartToFrac[0][1] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        cartToFrac[0][2] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        cartToFrac[1][0] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        cartToFrac[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        cartToFrac[1][2] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        cartToFrac[2][0] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        cartToFrac[2][1] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        cartToFrac[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    \n"
"    for (int m = GLOBAL_ID; m < NUM_ATOMS; m += GLOBAL_SIZE) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"        real3 cinducedDipole = make_real3(inducedDipole[3*m], inducedDipole[3*m+1], inducedDipole[3*m+2]);\n"
"        real3 finducedDipole = make_real3(cinducedDipole.x*cartToFrac[0][0] + cinducedDipole.y*cartToFrac[0][1] + cinducedDipole.z*cartToFrac[0][2],\n"
"                                          cinducedDipole.x*cartToFrac[1][0] + cinducedDipole.y*cartToFrac[1][1] + cinducedDipole.z*cartToFrac[1][2],\n"
"                                          cinducedDipole.x*cartToFrac[2][0] + cinducedDipole.y*cartToFrac[2][1] + cinducedDipole.z*cartToFrac[2][2]);\n"
"#ifndef HIPPO\n"
"        real3 cinducedDipolePolar = make_real3(inducedDipolePolar[3*m], inducedDipolePolar[3*m+1], inducedDipolePolar[3*m+2]);\n"
"        real3 finducedDipolePolar = make_real3(cinducedDipolePolar.x*cartToFrac[0][0] + cinducedDipolePolar.y*cartToFrac[0][1] + cinducedDipolePolar.z*cartToFrac[0][2],\n"
"                                               cinducedDipolePolar.x*cartToFrac[1][0] + cinducedDipolePolar.y*cartToFrac[1][1] + cinducedDipolePolar.z*cartToFrac[1][2],\n"
"                                               cinducedDipolePolar.x*cartToFrac[2][0] + cinducedDipolePolar.y*cartToFrac[2][1] + cinducedDipolePolar.z*cartToFrac[2][2]);\n"
"#endif\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"        \n"
"        // Spread the charge from this atom onto each grid point.\n"
"         \n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = igrid1+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"            real4 t = theta1[ix];\n"
"            \n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = igrid2+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = xbase + ybase*GRID_SIZE_Z;\n"
"                real4 u = theta2[iy];\n"
"                real term01 = finducedDipole.y*t.x*u.y + finducedDipole.x*t.y*u.x;\n"
"                real term11 = finducedDipole.z*t.x*u.x;\n"
"#ifndef HIPPO\n"
"                real term02 = finducedDipolePolar.y*t.x*u.y + finducedDipolePolar.x*t.y*u.x;\n"
"                real term12 = finducedDipolePolar.z*t.x*u.x;\n"
"#endif                \n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = igrid3+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = ybase + zindex;\n"
"                    real4 v = theta3[iz];\n"
"\n"
"                    real add1 = term01*v.x + term11*v.y;\n"
"#ifdef HIPPO\n"
"    #ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"                    ATOMIC_ADD(&pmeGrid[index], (mm_ulong) ((mm_long) (add1*0x100000000)));\n"
"    #else\n"
"                    ATOMIC_ADD(&pmeGrid[index], add1);\n"
"    #endif\n"
"#else\n"
"                    real add2 = term02*v.x + term12*v.y;\n"
"    #ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"                    ATOMIC_ADD(&pmeGrid[2*index], (mm_ulong) ((mm_long) (add1*0x100000000)));\n"
"                    ATOMIC_ADD(&pmeGrid[2*index+1], (mm_ulong) ((mm_long) (add2*0x100000000)));\n"
"    #else\n"
"                    ATOMIC_ADD(&pmeGrid[index].x, add1);\n"
"                    ATOMIC_ADD(&pmeGrid[index].y, add2);\n"
"    #endif\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * In double precision, we have to use fixed point to accumulate the grid values, so convert them to floating point.\n"
" */\n"
"KERNEL void finishSpreadCharge(GLOBAL const mm_long* RESTRICT pmeGridLong, GLOBAL real* RESTRICT pmeGrid) {\n"
"#ifdef HIPPO\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#else\n"
"    const unsigned int gridSize = 2*GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#endif\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < gridSize; index += GLOBAL_SIZE)\n"
"        pmeGrid[index] = scale*pmeGridLong[index];\n"
"}\n"
"\n"
"KERNEL void reciprocalConvolution(GLOBAL real2* RESTRICT pmeGrid, GLOBAL const real* RESTRICT pmeBsplineModuliX,\n"
"        GLOBAL const real* RESTRICT pmeBsplineModuliY, GLOBAL const real* RESTRICT pmeBsplineModuliZ, real4 periodicBoxSize,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"#ifdef HIPPO\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"#else\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#endif\n"
"    real expFactor = M_PI*M_PI/(EWALD_ALPHA*EWALD_ALPHA);\n"
"    real scaleFactor = RECIP(M_PI*periodicBoxSize.x*periodicBoxSize.y*periodicBoxSize.z);\n"
"    for (int index = GLOBAL_ID; index < gridSize; index += GLOBAL_SIZE) {\n"
"#ifdef HIPPO\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"        int ky = remainder/(GRID_SIZE_Z/2+1);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z/2+1);\n"
"#else\n"
"        int kx = index/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = index-kx*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        int ky = remainder/GRID_SIZE_Z;\n"
"        int kz = remainder-ky*GRID_SIZE_Z;\n"
"#endif\n"
"        if (kx == 0 && ky == 0 && kz == 0) {\n"
"            pmeGrid[index] = make_real2(0, 0);\n"
"            continue;\n"
"        }\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"        real2 grid = pmeGrid[index];\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = scaleFactor*EXP(-expFactor*m2)/denom;\n"
"        pmeGrid[index] = make_real2(grid.x*eterm, grid.y*eterm);\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeFixedPotentialFromGrid(\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT pmeGrid,\n"
"#else\n"
"        GLOBAL const real2* RESTRICT pmeGrid,\n"
"#endif\n"
"        GLOBAL real* RESTRICT phi, GLOBAL mm_long* RESTRICT fieldBuffers,\n"
"#ifndef HIPPO\n"
"        GLOBAL mm_long* RESTRICT fieldPolarBuffers,\n"
"#endif\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT labDipole, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    LOCAL real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*LOCAL_ID];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    LOCAL real fracToCart[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    \n"
"    for (int m = GLOBAL_ID; m < NUM_ATOMS; m += GLOBAL_SIZE) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"\n"
"        // Compute the potential from this grid point.\n"
"\n"
"        real tuv000 = 0;\n"
"        real tuv001 = 0;\n"
"        real tuv010 = 0;\n"
"        real tuv100 = 0;\n"
"        real tuv200 = 0;\n"
"        real tuv020 = 0;\n"
"        real tuv002 = 0;\n"
"        real tuv110 = 0;\n"
"        real tuv101 = 0;\n"
"        real tuv011 = 0;\n"
"        real tuv300 = 0;\n"
"        real tuv030 = 0;\n"
"        real tuv003 = 0;\n"
"        real tuv210 = 0;\n"
"        real tuv201 = 0;\n"
"        real tuv120 = 0;\n"
"        real tuv021 = 0;\n"
"        real tuv102 = 0;\n"
"        real tuv012 = 0;\n"
"        real tuv111 = 0;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int i = igrid1+ix-(igrid1+ix >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            real4 v = theta1[ix];\n"
"            real tu00 = 0;\n"
"            real tu10 = 0;\n"
"            real tu01 = 0;\n"
"            real tu20 = 0;\n"
"            real tu11 = 0;\n"
"            real tu02 = 0;\n"
"            real tu30 = 0;\n"
"            real tu21 = 0;\n"
"            real tu12 = 0;\n"
"            real tu03 = 0;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int j = igrid2+iy-(igrid2+iy >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                real4 u = theta2[iy];\n"
"                real4 t = make_real4(0, 0, 0, 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int k = igrid3+iz-(igrid3+iz >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int gridIndex = i*GRID_SIZE_Y*GRID_SIZE_Z + j*GRID_SIZE_Z + k;\n"
"#ifdef HIPPO\n"
"                    real tq = pmeGrid[gridIndex];\n"
"#else\n"
"                    real tq = pmeGrid[gridIndex].x;\n"
"#endif\n"
"                    real4 tadd = theta3[iz];\n"
"                    t.x += tq*tadd.x;\n"
"                    t.y += tq*tadd.y;\n"
"                    t.z += tq*tadd.z;\n"
"                    t.w += tq*tadd.w;\n"
"                }\n"
"                tu00 += u.x*t.x;\n"
"                tu10 += u.y*t.x;\n"
"                tu01 += u.x*t.y;\n"
"                tu20 += u.z*t.x;\n"
"                tu11 += u.y*t.y;\n"
"                tu02 += u.x*t.z;\n"
"                tu30 += u.w*t.x;\n"
"                tu21 += u.z*t.y;\n"
"                tu12 += u.y*t.z;\n"
"                tu03 += u.x*t.w;\n"
"            }\n"
"            tuv000 += v.x*tu00;\n"
"            tuv100 += v.y*tu00;\n"
"            tuv010 += v.x*tu10;\n"
"            tuv001 += v.x*tu01;\n"
"            tuv200 += v.z*tu00;\n"
"            tuv020 += v.x*tu20;\n"
"            tuv002 += v.x*tu02;\n"
"            tuv110 += v.y*tu10;\n"
"            tuv101 += v.y*tu01;\n"
"            tuv011 += v.x*tu11;\n"
"            tuv300 += v.w*tu00;\n"
"            tuv030 += v.x*tu30;\n"
"            tuv003 += v.x*tu03;\n"
"            tuv210 += v.z*tu10;\n"
"            tuv201 += v.z*tu01;\n"
"            tuv120 += v.y*tu20;\n"
"            tuv021 += v.x*tu21;\n"
"            tuv102 += v.y*tu02;\n"
"            tuv012 += v.x*tu12;\n"
"            tuv111 += v.y*tu11;\n"
"        }\n"
"        phi[m] = tuv000;\n"
"        phi[m+NUM_ATOMS] = tuv100;\n"
"        phi[m+NUM_ATOMS*2] = tuv010;\n"
"        phi[m+NUM_ATOMS*3] = tuv001;\n"
"        phi[m+NUM_ATOMS*4] = tuv200;\n"
"        phi[m+NUM_ATOMS*5] = tuv020;\n"
"        phi[m+NUM_ATOMS*6] = tuv002;\n"
"        phi[m+NUM_ATOMS*7] = tuv110;\n"
"        phi[m+NUM_ATOMS*8] = tuv101;\n"
"        phi[m+NUM_ATOMS*9] = tuv011;\n"
"        phi[m+NUM_ATOMS*10] = tuv300;\n"
"        phi[m+NUM_ATOMS*11] = tuv030;\n"
"        phi[m+NUM_ATOMS*12] = tuv003;\n"
"        phi[m+NUM_ATOMS*13] = tuv210;\n"
"        phi[m+NUM_ATOMS*14] = tuv201;\n"
"        phi[m+NUM_ATOMS*15] = tuv120;\n"
"        phi[m+NUM_ATOMS*16] = tuv021;\n"
"        phi[m+NUM_ATOMS*17] = tuv102;\n"
"        phi[m+NUM_ATOMS*18] = tuv012;\n"
"        phi[m+NUM_ATOMS*19] = tuv111;\n"
"        real dipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"        mm_long fieldx = (mm_long) ((dipoleScale*labDipole[m*3]-tuv100*fracToCart[0][0]-tuv010*fracToCart[0][1]-tuv001*fracToCart[0][2])*0x100000000);\n"
"        mm_long fieldy = (mm_long) ((dipoleScale*labDipole[m*3+1]-tuv100*fracToCart[1][0]-tuv010*fracToCart[1][1]-tuv001*fracToCart[1][2])*0x100000000);\n"
"        mm_long fieldz = (mm_long) ((dipoleScale*labDipole[m*3+2]-tuv100*fracToCart[2][0]-tuv010*fracToCart[2][1]-tuv001*fracToCart[2][2])*0x100000000);\n"
"        fieldBuffers[m] = fieldx;\n"
"        fieldBuffers[m+PADDED_NUM_ATOMS] = fieldy;\n"
"        fieldBuffers[m+2*PADDED_NUM_ATOMS] = fieldz;\n"
"#ifndef HIPPO\n"
"        fieldPolarBuffers[m] = fieldx;\n"
"        fieldPolarBuffers[m+PADDED_NUM_ATOMS] = fieldy;\n"
"        fieldPolarBuffers[m+2*PADDED_NUM_ATOMS] = fieldz;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeInducedPotentialFromGrid(\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT pmeGrid, GLOBAL real* RESTRICT extrapolatedPhi, int order,\n"
"#else\n"
"        GLOBAL const real2* RESTRICT pmeGrid, GLOBAL real* RESTRICT phid, GLOBAL real* RESTRICT phip,\n"
"#endif\n"
"        GLOBAL real* RESTRICT phidp, GLOBAL const real4* RESTRICT posq,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX,\n"
"        real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    LOCAL real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*LOCAL_ID];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    \n"
"    for (int m = GLOBAL_ID; m < NUM_ATOMS; m += GLOBAL_SIZE) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"\n"
"        // Compute the potential from this grid point.\n"
"\n"
"#ifndef HIPPO\n"
"        real tuv100_1 = 0;\n"
"        real tuv010_1 = 0;\n"
"        real tuv001_1 = 0;\n"
"        real tuv200_1 = 0;\n"
"        real tuv020_1 = 0;\n"
"        real tuv002_1 = 0;\n"
"        real tuv110_1 = 0;\n"
"        real tuv101_1 = 0;\n"
"        real tuv011_1 = 0;\n"
"        real tuv100_2 = 0;\n"
"        real tuv010_2 = 0;\n"
"        real tuv001_2 = 0;\n"
"        real tuv200_2 = 0;\n"
"        real tuv020_2 = 0;\n"
"        real tuv002_2 = 0;\n"
"        real tuv110_2 = 0;\n"
"        real tuv101_2 = 0;\n"
"        real tuv011_2 = 0;\n"
"#endif\n"
"        real tuv000 = 0;\n"
"        real tuv001 = 0;\n"
"        real tuv010 = 0;\n"
"        real tuv100 = 0;\n"
"        real tuv200 = 0;\n"
"        real tuv020 = 0;\n"
"        real tuv002 = 0;\n"
"        real tuv110 = 0;\n"
"        real tuv101 = 0;\n"
"        real tuv011 = 0;\n"
"        real tuv300 = 0;\n"
"        real tuv030 = 0;\n"
"        real tuv003 = 0;\n"
"        real tuv210 = 0;\n"
"        real tuv201 = 0;\n"
"        real tuv120 = 0;\n"
"        real tuv021 = 0;\n"
"        real tuv102 = 0;\n"
"        real tuv012 = 0;\n"
"        real tuv111 = 0;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int i = igrid1+ix-(igrid1+ix >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            real4 v = theta1[ix];\n"
"#ifndef HIPPO\n"
"            real tu00_1 = 0;\n"
"            real tu01_1 = 0;\n"
"            real tu10_1 = 0;\n"
"            real tu20_1 = 0;\n"
"            real tu11_1 = 0;\n"
"            real tu02_1 = 0;\n"
"            real tu00_2 = 0;\n"
"            real tu01_2 = 0;\n"
"            real tu10_2 = 0;\n"
"            real tu20_2 = 0;\n"
"            real tu11_2 = 0;\n"
"            real tu02_2 = 0;\n"
"#endif\n"
"            real tu00 = 0;\n"
"            real tu10 = 0;\n"
"            real tu01 = 0;\n"
"            real tu20 = 0;\n"
"            real tu11 = 0;\n"
"            real tu02 = 0;\n"
"            real tu30 = 0;\n"
"            real tu21 = 0;\n"
"            real tu12 = 0;\n"
"            real tu03 = 0;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int j = igrid2+iy-(igrid2+iy >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                real4 u = theta2[iy];\n"
"#ifdef HIPPO\n"
"                real t0 = 0;\n"
"                real t1 = 0;\n"
"                real t2 = 0;\n"
"#else\n"
"                real t0_1 = 0;\n"
"                real t1_1 = 0;\n"
"                real t2_1 = 0;\n"
"                real t0_2 = 0;\n"
"                real t1_2 = 0;\n"
"                real t2_2 = 0;\n"
"#endif\n"
"                real t3 = 0;\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int k = igrid3+iz-(igrid3+iz >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int gridIndex = i*GRID_SIZE_Y*GRID_SIZE_Z + j*GRID_SIZE_Z + k;\n"
"                    real4 tadd = theta3[iz];\n"
"#ifdef HIPPO\n"
"                    real tq = pmeGrid[gridIndex];\n"
"                    t0 += tq*tadd.x;\n"
"                    t1 += tq*tadd.y;\n"
"                    t2 += tq*tadd.z;\n"
"                    t3 += tq*tadd.w;\n"
"#else\n"
"                    real2 tq = pmeGrid[gridIndex];\n"
"                    t0_1 += tq.x*tadd.x;\n"
"                    t1_1 += tq.x*tadd.y;\n"
"                    t2_1 += tq.x*tadd.z;\n"
"                    t0_2 += tq.y*tadd.x;\n"
"                    t1_2 += tq.y*tadd.y;\n"
"                    t2_2 += tq.y*tadd.z;\n"
"                    t3 += (tq.x+tq.y)*tadd.w;\n"
"#endif\n"
"                }\n"
"#ifndef HIPPO\n"
"                tu00_1 += u.x*t0_1;\n"
"                tu10_1 += u.y*t0_1;\n"
"                tu01_1 += u.x*t1_1;\n"
"                tu20_1 += u.z*t0_1;\n"
"                tu11_1 += u.y*t1_1;\n"
"                tu02_1 += u.x*t2_1;\n"
"                tu00_2 += u.x*t0_2;\n"
"                tu10_2 += u.y*t0_2;\n"
"                tu01_2 += u.x*t1_2;\n"
"                tu20_2 += u.z*t0_2;\n"
"                tu11_2 += u.y*t1_2;\n"
"                tu02_2 += u.x*t2_2;\n"
"                real t0 = t0_1 + t0_2;\n"
"                real t1 = t1_1 + t1_2;\n"
"                real t2 = t2_1 + t2_2;\n"
"#endif\n"
"                tu00 += u.x*t0;\n"
"                tu10 += u.y*t0;\n"
"                tu01 += u.x*t1;\n"
"                tu20 += u.z*t0;\n"
"                tu11 += u.y*t1;\n"
"                tu02 += u.x*t2;\n"
"                tu30 += u.w*t0;\n"
"                tu21 += u.z*t1;\n"
"                tu12 += u.y*t2;\n"
"                tu03 += u.x*t3;\n"
"            }\n"
"#ifndef HIPPO\n"
"            tuv100_1 += v.y*tu00_1;\n"
"            tuv010_1 += v.x*tu10_1;\n"
"            tuv001_1 += v.x*tu01_1;\n"
"            tuv200_1 += v.z*tu00_1;\n"
"            tuv020_1 += v.x*tu20_1;\n"
"            tuv002_1 += v.x*tu02_1;\n"
"            tuv110_1 += v.y*tu10_1;\n"
"            tuv101_1 += v.y*tu01_1;\n"
"            tuv011_1 += v.x*tu11_1;\n"
"            tuv100_2 += v.y*tu00_2;\n"
"            tuv010_2 += v.x*tu10_2;\n"
"            tuv001_2 += v.x*tu01_2;\n"
"            tuv200_2 += v.z*tu00_2;\n"
"            tuv020_2 += v.x*tu20_2;\n"
"            tuv002_2 += v.x*tu02_2;\n"
"            tuv110_2 += v.y*tu10_2;\n"
"            tuv101_2 += v.y*tu01_2;\n"
"            tuv011_2 += v.x*tu11_2;\n"
"#endif\n"
"            tuv000 += v.x*tu00;\n"
"            tuv100 += v.y*tu00;\n"
"            tuv010 += v.x*tu10;\n"
"            tuv001 += v.x*tu01;\n"
"            tuv200 += v.z*tu00;\n"
"            tuv020 += v.x*tu20;\n"
"            tuv002 += v.x*tu02;\n"
"            tuv110 += v.y*tu10;\n"
"            tuv101 += v.y*tu01;\n"
"            tuv011 += v.x*tu11;\n"
"            tuv300 += v.w*tu00;\n"
"            tuv030 += v.x*tu30;\n"
"            tuv003 += v.x*tu03;\n"
"            tuv210 += v.z*tu10;\n"
"            tuv201 += v.z*tu01;\n"
"            tuv120 += v.y*tu20;\n"
"            tuv021 += v.x*tu21;\n"
"            tuv102 += v.y*tu02;\n"
"            tuv012 += v.x*tu12;\n"
"            tuv111 += v.y*tu11;\n"
"        }\n"
"#ifndef HIPPO\n"
"        phid[m]   = 0;\n"
"        phid[m+NUM_ATOMS] = tuv100_1;\n"
"        phid[m+NUM_ATOMS*2] = tuv010_1;\n"
"        phid[m+NUM_ATOMS*3] = tuv001_1;\n"
"        phid[m+NUM_ATOMS*4] = tuv200_1;\n"
"        phid[m+NUM_ATOMS*5] = tuv020_1;\n"
"        phid[m+NUM_ATOMS*6] = tuv002_1;\n"
"        phid[m+NUM_ATOMS*7] = tuv110_1;\n"
"        phid[m+NUM_ATOMS*8] = tuv101_1;\n"
"        phid[m+NUM_ATOMS*9] = tuv011_1;\n"
"\n"
"        phip[m]   = 0;\n"
"        phip[m+NUM_ATOMS] = tuv100_2;\n"
"        phip[m+NUM_ATOMS*2] = tuv010_2;\n"
"        phip[m+NUM_ATOMS*3] = tuv001_2;\n"
"        phip[m+NUM_ATOMS*4] = tuv200_2;\n"
"        phip[m+NUM_ATOMS*5] = tuv020_2;\n"
"        phip[m+NUM_ATOMS*6] = tuv002_2;\n"
"        phip[m+NUM_ATOMS*7] = tuv110_2;\n"
"        phip[m+NUM_ATOMS*8] = tuv101_2;\n"
"        phip[m+NUM_ATOMS*9] = tuv011_2;\n"
"#endif\n"
"        phidp[m] = tuv000;\n"
"        phidp[m+NUM_ATOMS*1] = tuv100;\n"
"        phidp[m+NUM_ATOMS*2] = tuv010;\n"
"        phidp[m+NUM_ATOMS*3] = tuv001;\n"
"        phidp[m+NUM_ATOMS*4] = tuv200;\n"
"        phidp[m+NUM_ATOMS*5] = tuv020;\n"
"        phidp[m+NUM_ATOMS*6] = tuv002;\n"
"        phidp[m+NUM_ATOMS*7] = tuv110;\n"
"        phidp[m+NUM_ATOMS*8] = tuv101;\n"
"        phidp[m+NUM_ATOMS*9] = tuv011;\n"
"        phidp[m+NUM_ATOMS*10] = tuv300;\n"
"        phidp[m+NUM_ATOMS*11] = tuv030;\n"
"        phidp[m+NUM_ATOMS*12] = tuv003;\n"
"        phidp[m+NUM_ATOMS*13] = tuv210;\n"
"        phidp[m+NUM_ATOMS*14] = tuv201;\n"
"        phidp[m+NUM_ATOMS*15] = tuv120;\n"
"        phidp[m+NUM_ATOMS*16] = tuv021;\n"
"        phidp[m+NUM_ATOMS*17] = tuv102;\n"
"        phidp[m+NUM_ATOMS*18] = tuv012;\n"
"        phidp[m+NUM_ATOMS*19] = tuv111;\n"
"#ifdef HIPPO\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m] = tuv000;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*1] = tuv100;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*2] = tuv010;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*3] = tuv001;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*4] = tuv200;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*5] = tuv020;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*6] = tuv002;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*7] = tuv110;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*8] = tuv101;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*9] = tuv011;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeFixedMultipoleForceAndEnergy(GLOBAL real4* RESTRICT posq, GLOBAL mm_ulong* RESTRICT forceBuffers,\n"
"        GLOBAL mm_long* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real* RESTRICT labDipole,\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT coreCharge, GLOBAL const real* RESTRICT valenceCharge, GLOBAL const real* RESTRICT labQXX,\n"
"        GLOBAL const real* RESTRICT labQXY, GLOBAL const real* RESTRICT labQXZ, GLOBAL const real* RESTRICT labQYY, GLOBAL const real* RESTRICT labQYZ,\n"
"#else\n"
"        GLOBAL const real* RESTRICT labQuadrupole,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT fracDipole, GLOBAL const real* RESTRICT fracQuadrupole,\n"
"        GLOBAL const real* RESTRICT phi, GLOBAL const real* RESTRICT cphi_global, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    real multipole[10];\n"
"    const int deriv1[] = {1, 4, 7, 8, 10, 15, 17, 13, 14, 19};\n"
"    const int deriv2[] = {2, 7, 5, 9, 13, 11, 18, 15, 19, 16};\n"
"    const int deriv3[] = {3, 8, 9, 6, 14, 16, 12, 19, 17, 18};\n"
"    mixed energy = 0;\n"
"    LOCAL real fracToCart[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        // Compute the torque.\n"
"\n"
"        multipole[1] = labDipole[i*3];\n"
"        multipole[2] = labDipole[i*3+1];\n"
"        multipole[3] = labDipole[i*3+2];\n"
"#ifdef HIPPO\n"
"        multipole[0] = coreCharge[i]+valenceCharge[i];\n"
"        multipole[4] = labQXX[i];\n"
"        multipole[5] = labQYY[i];\n"
"        multipole[7] = 2*labQXY[i];\n"
"        multipole[8] = 2*labQXZ[i];\n"
"        multipole[9] = 2*labQYZ[i];\n"
"#else\n"
"        multipole[0] = posq[i].w;\n"
"        multipole[4] = labQuadrupole[i*5];\n"
"        multipole[5] = labQuadrupole[i*5+3];\n"
"        multipole[7] = 2*labQuadrupole[i*5+1];\n"
"        multipole[8] = 2*labQuadrupole[i*5+2];\n"
"        multipole[9] = 2*labQuadrupole[i*5+4];\n"
"#endif\n"
"        multipole[6] = -(multipole[4]+multipole[5]);\n"
"\n"
"        GLOBAL const real* cphi = &cphi_global[10*i];\n"
"\n"
"        torqueBuffers[i] = (mm_long) (EPSILON_FACTOR*(multipole[3]*cphi[2] - multipole[2]*cphi[3]\n"
"                      + 2*(multipole[6]-multipole[5])*cphi[9]\n"
"                      + multipole[8]*cphi[7] + multipole[9]*cphi[5]\n"
"                      - multipole[7]*cphi[8] - multipole[9]*cphi[6])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] = (mm_long) (EPSILON_FACTOR*(multipole[1]*cphi[3] - multipole[3]*cphi[1]\n"
"                      + 2*(multipole[4]-multipole[6])*cphi[8]\n"
"                      + multipole[7]*cphi[9] + multipole[8]*cphi[6]\n"
"                      - multipole[8]*cphi[4] - multipole[9]*cphi[7])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] = (mm_long) (EPSILON_FACTOR*(multipole[2]*cphi[1] - multipole[1]*cphi[2]\n"
"                      + 2*(multipole[5]-multipole[4])*cphi[7]\n"
"                      + multipole[7]*cphi[4] + multipole[9]*cphi[8]\n"
"                      - multipole[7]*cphi[5] - multipole[8]*cphi[9])*0x100000000);\n"
"\n"
"        // Compute the force and energy.\n"
"\n"
"        multipole[1] = fracDipole[i*3];\n"
"        multipole[2] = fracDipole[i*3+1];\n"
"        multipole[3] = fracDipole[i*3+2];\n"
"        multipole[4] = fracQuadrupole[i*6];\n"
"        multipole[5] = fracQuadrupole[i*6+3];\n"
"        multipole[6] = fracQuadrupole[i*6+5];\n"
"        multipole[7] = fracQuadrupole[i*6+1];\n"
"        multipole[8] = fracQuadrupole[i*6+2];\n"
"        multipole[9] = fracQuadrupole[i*6+4];\n"
"\n"
"        real3 f = make_real3(0);\n"
"        for (int k = 0; k < 10; k++) {\n"
"            energy += multipole[k]*phi[i+NUM_ATOMS*k];\n"
"            f.x += multipole[k]*phi[i+NUM_ATOMS*deriv1[k]];\n"
"            f.y += multipole[k]*phi[i+NUM_ATOMS*deriv2[k]];\n"
"            f.z += multipole[k]*phi[i+NUM_ATOMS*deriv3[k]];\n"
"        }\n"
"        f = make_real3(EPSILON_FACTOR*(f.x*fracToCart[0][0] + f.y*fracToCart[0][1] + f.z*fracToCart[0][2]),\n"
"                       EPSILON_FACTOR*(f.x*fracToCart[1][0] + f.y*fracToCart[1][1] + f.z*fracToCart[1][2]),\n"
"                       EPSILON_FACTOR*(f.x*fracToCart[2][0] + f.y*fracToCart[2][1] + f.z*fracToCart[2][2]));\n"
"        forceBuffers[i] -= (mm_ulong) ((mm_long) (f.x*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS] -= (mm_ulong) ((mm_long) (f.y*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS*2] -= (mm_ulong) ((mm_long) (f.z*0x100000000));\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += 0.5f*EPSILON_FACTOR*energy;\n"
"}\n"
"\n"
"KERNEL void computeInducedDipoleForceAndEnergy(GLOBAL real4* RESTRICT posq, GLOBAL mm_ulong* RESTRICT forceBuffers,\n"
"        GLOBAL mm_long* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real* RESTRICT labDipole,\n"
"#ifdef HIPPO\n"
"        GLOBAL const real* RESTRICT coreCharge, GLOBAL const real* RESTRICT valenceCharge, GLOBAL const real* RESTRICT extrapolatedDipole,\n"
"        GLOBAL const real* RESTRICT extrapolatedPhi, GLOBAL const real* RESTRICT labQXX, GLOBAL const real* RESTRICT labQXY,\n"
"        GLOBAL const real* RESTRICT labQXZ, GLOBAL const real* RESTRICT labQYY, GLOBAL const real* RESTRICT labQYZ,\n"
"#else\n"
"        GLOBAL const real* RESTRICT labQuadrupole,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT fracDipole, GLOBAL const real* RESTRICT fracQuadrupole, GLOBAL const real* RESTRICT inducedDipole_global,\n"
"#ifndef HIPPO\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar_global,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT phi,\n"
"#ifndef HIPPO\n"
"        GLOBAL const real* RESTRICT phid, GLOBAL const real* RESTRICT phip,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT phidp, GLOBAL const real* RESTRICT cphi_global, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    real multipole[10];\n"
"    real cinducedDipole[3], inducedDipole[3];\n"
"    real cinducedDipolePolar[3], inducedDipolePolar[3];\n"
"    const int deriv1[] = {1, 4, 7, 8, 10, 15, 17, 13, 14, 19};\n"
"    const int deriv2[] = {2, 7, 5, 9, 13, 11, 18, 15, 19, 16};\n"
"    const int deriv3[] = {3, 8, 9, 6, 14, 16, 12, 19, 17, 18};\n"
"#ifdef HIPPO\n"
"    const real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"#endif\n"
"    mixed energy = 0;\n"
"    LOCAL real fracToCart[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        // Compute the torque.\n"
"\n"
"        multipole[1] = labDipole[i*3];\n"
"        multipole[2] = labDipole[i*3+1];\n"
"        multipole[3] = labDipole[i*3+2];\n"
"#ifdef HIPPO\n"
"        multipole[0] = coreCharge[i]+valenceCharge[i];\n"
"        multipole[4] = labQXX[i];\n"
"        multipole[5] = labQYY[i];\n"
"        multipole[7] = 2*labQXY[i];\n"
"        multipole[8] = 2*labQXZ[i];\n"
"        multipole[9] = 2*labQYZ[i];\n"
"        const real scale = EPSILON_FACTOR;\n"
"#else\n"
"        multipole[0] = posq[i].w;\n"
"        multipole[4] = labQuadrupole[i*5];\n"
"        multipole[5] = labQuadrupole[i*5+3];\n"
"        multipole[7] = 2*labQuadrupole[i*5+1];\n"
"        multipole[8] = 2*labQuadrupole[i*5+2];\n"
"        multipole[9] = 2*labQuadrupole[i*5+4];\n"
"        const real scale = EPSILON_FACTOR/2;\n"
"#endif\n"
"        multipole[6] = -(multipole[4]+multipole[5]);\n"
"        GLOBAL const real* cphi = &cphi_global[10*i];\n"
" \n"
"        torqueBuffers[i] += (mm_long) (scale*(multipole[3]*cphi[2] - multipole[2]*cphi[3]\n"
"                      + 2*(multipole[6]-multipole[5])*cphi[9]\n"
"                      + multipole[8]*cphi[7] + multipole[9]*cphi[5]\n"
"                      - multipole[7]*cphi[8] - multipole[9]*cphi[6])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] += (mm_long) (scale*(multipole[1]*cphi[3] - multipole[3]*cphi[1]\n"
"                      + 2*(multipole[4]-multipole[6])*cphi[8]\n"
"                      + multipole[7]*cphi[9] + multipole[8]*cphi[6]\n"
"                      - multipole[8]*cphi[4] - multipole[9]*cphi[7])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] += (mm_long) (scale*(multipole[2]*cphi[1] - multipole[1]*cphi[2]\n"
"                      + 2*(multipole[5]-multipole[4])*cphi[7]\n"
"                      + multipole[7]*cphi[4] + multipole[9]*cphi[8]\n"
"                      - multipole[7]*cphi[5] - multipole[8]*cphi[9])*0x100000000);\n"
"\n"
"        // Compute the force and energy.\n"
"\n"
"        multipole[1] = fracDipole[i*3];\n"
"        multipole[2] = fracDipole[i*3+1];\n"
"        multipole[3] = fracDipole[i*3+2];\n"
"        multipole[4] = fracQuadrupole[i*6];\n"
"        multipole[5] = fracQuadrupole[i*6+3];\n"
"        multipole[6] = fracQuadrupole[i*6+5];\n"
"        multipole[7] = fracQuadrupole[i*6+1];\n"
"        multipole[8] = fracQuadrupole[i*6+2];\n"
"        multipole[9] = fracQuadrupole[i*6+4];\n"
"\n"
"        cinducedDipole[0] = inducedDipole_global[3*i];\n"
"        cinducedDipole[1] = inducedDipole_global[3*i+1];\n"
"        cinducedDipole[2] = inducedDipole_global[3*i+2];\n"
"#ifndef HIPPO\n"
"        cinducedDipolePolar[0] = inducedDipolePolar_global[3*i];\n"
"        cinducedDipolePolar[1] = inducedDipolePolar_global[3*i+1];\n"
"        cinducedDipolePolar[2] = inducedDipolePolar_global[3*i+2];\n"
"#endif\n"
"        \n"
"        // Multiply the dipoles by cartToFrac, which is just the transpose of fracToCart.\n"
"        \n"
"        inducedDipole[0] = cinducedDipole[0]*fracToCart[0][0] + cinducedDipole[1]*fracToCart[1][0] + cinducedDipole[2]*fracToCart[2][0];\n"
"        inducedDipole[1] = cinducedDipole[0]*fracToCart[0][1] + cinducedDipole[1]*fracToCart[1][1] + cinducedDipole[2]*fracToCart[2][1];\n"
"        inducedDipole[2] = cinducedDipole[0]*fracToCart[0][2] + cinducedDipole[1]*fracToCart[1][2] + cinducedDipole[2]*fracToCart[2][2];\n"
"#ifndef HIPPO\n"
"        inducedDipolePolar[0] = cinducedDipolePolar[0]*fracToCart[0][0] + cinducedDipolePolar[1]*fracToCart[1][0] + cinducedDipolePolar[2]*fracToCart[2][0];\n"
"        inducedDipolePolar[1] = cinducedDipolePolar[0]*fracToCart[0][1] + cinducedDipolePolar[1]*fracToCart[1][1] + cinducedDipolePolar[2]*fracToCart[2][1];\n"
"        inducedDipolePolar[2] = cinducedDipolePolar[0]*fracToCart[0][2] + cinducedDipolePolar[1]*fracToCart[1][2] + cinducedDipolePolar[2]*fracToCart[2][2];\n"
"        energy += (inducedDipole[0]+inducedDipolePolar[0])*phi[i+NUM_ATOMS];\n"
"        energy += (inducedDipole[1]+inducedDipolePolar[1])*phi[i+NUM_ATOMS*2];\n"
"        energy += (inducedDipole[2]+inducedDipolePolar[2])*phi[i+NUM_ATOMS*3];\n"
"#endif\n"
"        real3 f = make_real3(0, 0, 0);\n"
"        for (int k = 0; k < 3; k++) {\n"
"            int j1 = deriv1[k+1];\n"
"            int j2 = deriv2[k+1];\n"
"            int j3 = deriv3[k+1];\n"
"#ifdef HIPPO\n"
"            f.x += inducedDipole[k]*phi[i+NUM_ATOMS*j1];\n"
"            f.y += inducedDipole[k]*phi[i+NUM_ATOMS*j2];\n"
"            f.z += inducedDipole[k]*phi[i+NUM_ATOMS*j3];\n"
"#else\n"
"            f.x += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j1];\n"
"            f.y += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j2];\n"
"            f.z += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j3];\n"
"#endif\n"
"#ifdef MUTUAL_POLARIZATION\n"
"            f.x += (inducedDipole[k]*phip[i+NUM_ATOMS*j1] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j1]);\n"
"            f.y += (inducedDipole[k]*phip[i+NUM_ATOMS*j2] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j2]);\n"
"            f.z += (inducedDipole[k]*phip[i+NUM_ATOMS*j3] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j3]);\n"
"#endif\n"
"        }\n"
"\n"
"        for (int k = 0; k < 10; k++) {\n"
"            f.x += multipole[k]*phidp[i+NUM_ATOMS*deriv1[k]];\n"
"            f.y += multipole[k]*phidp[i+NUM_ATOMS*deriv2[k]];\n"
"            f.z += multipole[k]*phidp[i+NUM_ATOMS*deriv3[k]];\n"
"        }\n"
"\n"
"#ifdef HIPPO\n"
"        // Account for dipole response terms in the OPT method\n"
"\n"
"        for (int j = 0; j < MAX_EXTRAPOLATION_ORDER-1; j++) {\n"
"            for (int m = 0; m < MAX_EXTRAPOLATION_ORDER-1-j; m++) {\n"
"                real3 optDipole = make_real3(\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][0] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][0] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][0],\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][1] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][1] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][1],\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][2] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][2] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][2]);\n"
"                real3 h = make_real3(\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[3]],\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[3]],\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[3]]);\n"
"                f += coeff[j+m+1]*h;\n"
"            }\n"
"        }\n"
"#endif\n"
"        f = make_real3(scale*(f.x*fracToCart[0][0] + f.y*fracToCart[0][1] + f.z*fracToCart[0][2]),\n"
"                       scale*(f.x*fracToCart[1][0] + f.y*fracToCart[1][1] + f.z*fracToCart[1][2]),\n"
"                       scale*(f.x*fracToCart[2][0] + f.y*fracToCart[2][1] + f.z*fracToCart[2][2]));\n"
"        forceBuffers[i] -= (mm_ulong) ((mm_long) (f.x*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS] -= (mm_ulong) ((mm_long) (f.y*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS*2] -= (mm_ulong) ((mm_long) (f.z*0x100000000));\n"
"    }\n"
"#ifndef HIPPO\n"
"    energyBuffer[GLOBAL_ID] += 0.25f*EPSILON_FACTOR*energy;\n"
"#endif\n"
"}\n"
"\n"
"#ifdef HIPPO\n"
"KERNEL void recordInducedFieldDipoles(GLOBAL const real* RESTRICT phidp, GLOBAL mm_long* RESTRICT inducedField,\n"
"        GLOBAL const real* RESTRICT inducedDipole, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    LOCAL real fracToCart[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    real selfDipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        inducedField[i] -= (mm_long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[0][0] + phidp[i+NUM_ATOMS*2]*fracToCart[0][1] + phidp[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipole[3*i]));\n"
"        inducedField[i+PADDED_NUM_ATOMS] -= (mm_long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[1][0] + phidp[i+NUM_ATOMS*2]*fracToCart[1][1] + phidp[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipole[3*i+1]));\n"
"        inducedField[i+PADDED_NUM_ATOMS*2] -= (mm_long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[2][0] + phidp[i+NUM_ATOMS*2]*fracToCart[2][1] + phidp[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipole[3*i+2]));\n"
"    }\n"
"}\n"
"\n"
"KERNEL void calculateSelfEnergyAndTorque(GLOBAL mm_long* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real* RESTRICT labDipole, GLOBAL const real* RESTRICT coreCharge, GLOBAL const real* RESTRICT valenceCharge,\n"
"        GLOBAL const real* RESTRICT c6, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT labQXX, GLOBAL const real* RESTRICT labQXY,\n"
"        GLOBAL const real* RESTRICT labQXZ, GLOBAL const real* RESTRICT labQYY, GLOBAL const real* RESTRICT labQYZ) {\n"
"    const real torqueScale = 4*EPSILON_FACTOR*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/(3*SQRT_PI);\n"
"    real cii = 0;\n"
"    real dii = 0;\n"
"    real qii = 0;\n"
"    real c6ii = 0;\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        real charge = coreCharge[i]+valenceCharge[i];\n"
"        real3 dipole = make_real3(labDipole[3*i], labDipole[3*i+1], labDipole[3*i+2]);\n"
"        real3 induced = make_real3(inducedDipole[3*i], inducedDipole[3*i+1], inducedDipole[3*i+2]);\n"
"        real qXX = labQXX[i];\n"
"        real qXY = labQXY[i];\n"
"        real qXZ = labQXZ[i];\n"
"        real qYY = labQYY[i];\n"
"        real qYZ = labQYZ[i];\n"
"        real qZZ = -qXX-qYY;\n"
"        real c6i = c6[i];\n"
"        cii += charge*charge;\n"
"        dii += dot(dipole, dipole);\n"
"        qii += qXX*qXX + qYY*qYY + qZZ*qZZ + 2*(qXY*qXY + qXZ*qXZ + qYZ*qYZ);\n"
"        c6ii += c6i*c6i;\n"
"        real3 torque = torqueScale*cross(dipole, induced);\n"
"        torqueBuffers[i] += (mm_long) (torque.x*0x100000000);\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] += (mm_long) (torque.y*0x100000000);\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] += (mm_long) (torque.z*0x100000000);\n"
"    }\n"
"    real term = 2*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fterm = -EPSILON_FACTOR*EWALD_ALPHA/SQRT_PI;\n"
"    real alpha3 = DISPERSION_EWALD_ALPHA*DISPERSION_EWALD_ALPHA*DISPERSION_EWALD_ALPHA;\n"
"    energyBuffer[GLOBAL_ID] += fterm*(cii + term*(dii/3+2*term*qii/5)) + alpha3*alpha3*c6ii/12;\n"
"}\n"
"#else\n"
"KERNEL void recordInducedFieldDipoles(GLOBAL const real* RESTRICT phid, GLOBAL real* const RESTRICT phip, GLOBAL mm_long* RESTRICT inducedField,\n"
"        GLOBAL mm_long* RESTRICT inducedFieldPolar, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        , GLOBAL mm_ulong* RESTRICT fieldGradient, GLOBAL mm_ulong* RESTRICT fieldGradientPolar\n"
"#endif\n"
"        ) {\n"
"    LOCAL real fracToCart[3][3];\n"
"    if (LOCAL_ID == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    real selfDipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        inducedField[i] -= (mm_long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[0][0] + phid[i+NUM_ATOMS*2]*fracToCart[0][1] + phid[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipole[3*i]));\n"
"        inducedField[i+PADDED_NUM_ATOMS] -= (mm_long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[1][0] + phid[i+NUM_ATOMS*2]*fracToCart[1][1] + phid[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipole[3*i+1]));\n"
"        inducedField[i+PADDED_NUM_ATOMS*2] -= (mm_long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[2][0] + phid[i+NUM_ATOMS*2]*fracToCart[2][1] + phid[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipole[3*i+2]));\n"
"        inducedFieldPolar[i] -= (mm_long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[0][0] + phip[i+NUM_ATOMS*2]*fracToCart[0][1] + phip[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipolePolar[3*i]));\n"
"        inducedFieldPolar[i+PADDED_NUM_ATOMS] -= (mm_long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[1][0] + phip[i+NUM_ATOMS*2]*fracToCart[1][1] + phip[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipolePolar[3*i+1]));\n"
"        inducedFieldPolar[i+PADDED_NUM_ATOMS*2] -= (mm_long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[2][0] + phip[i+NUM_ATOMS*2]*fracToCart[2][1] + phip[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipolePolar[3*i+2]));\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        // Compute and store the field gradients for later use.\n"
"\n"
"        real EmatD[3][3] = {\n"
"            {phid[i+NUM_ATOMS*4], phid[i+NUM_ATOMS*7], phid[i+NUM_ATOMS*8]},\n"
"            {phid[i+NUM_ATOMS*7], phid[i+NUM_ATOMS*5], phid[i+NUM_ATOMS*9]},\n"
"            {phid[i+NUM_ATOMS*8], phid[i+NUM_ATOMS*9], phid[i+NUM_ATOMS*6]}\n"
"        };\n"
"        real Exx = 0, Eyy = 0, Ezz = 0, Exy = 0, Exz = 0, Eyz = 0;\n"
"        for (int k = 0; k < 3; ++k) {\n"
"            for (int l = 0; l < 3; ++l) {\n"
"                Exx += fracToCart[0][k] * EmatD[k][l] * fracToCart[0][l];\n"
"                Eyy += fracToCart[1][k] * EmatD[k][l] * fracToCart[1][l];\n"
"                Ezz += fracToCart[2][k] * EmatD[k][l] * fracToCart[2][l];\n"
"                Exy += fracToCart[0][k] * EmatD[k][l] * fracToCart[1][l];\n"
"                Exz += fracToCart[0][k] * EmatD[k][l] * fracToCart[2][l];\n"
"                Eyz += fracToCart[1][k] * EmatD[k][l] * fracToCart[2][l];\n"
"            }\n"
"        }\n"
"        ATOMIC_ADD(&fieldGradient[6*i+0], (mm_ulong) ((mm_long) (-Exx*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradient[6*i+1], (mm_ulong) ((mm_long) (-Eyy*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradient[6*i+2], (mm_ulong) ((mm_long) (-Ezz*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradient[6*i+3], (mm_ulong) ((mm_long) (-Exy*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradient[6*i+4], (mm_ulong) ((mm_long) (-Exz*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradient[6*i+5], (mm_ulong) ((mm_long) (-Eyz*0x100000000)));\n"
"\n"
"        real EmatP[3][3] = {\n"
"            {phip[i+NUM_ATOMS*4], phip[i+NUM_ATOMS*7], phip[i+NUM_ATOMS*8]},\n"
"            {phip[i+NUM_ATOMS*7], phip[i+NUM_ATOMS*5], phip[i+NUM_ATOMS*9]},\n"
"            {phip[i+NUM_ATOMS*8], phip[i+NUM_ATOMS*9], phip[i+NUM_ATOMS*6]}\n"
"        };\n"
"        Exx = 0; Eyy = 0; Ezz = 0; Exy = 0; Exz = 0; Eyz = 0;\n"
"        for (int k = 0; k < 3; ++k) {\n"
"            for (int l = 0; l < 3; ++l) {\n"
"                Exx += fracToCart[0][k] * EmatP[k][l] * fracToCart[0][l];\n"
"                Eyy += fracToCart[1][k] * EmatP[k][l] * fracToCart[1][l];\n"
"                Ezz += fracToCart[2][k] * EmatP[k][l] * fracToCart[2][l];\n"
"                Exy += fracToCart[0][k] * EmatP[k][l] * fracToCart[1][l];\n"
"                Exz += fracToCart[0][k] * EmatP[k][l] * fracToCart[2][l];\n"
"                Eyz += fracToCart[1][k] * EmatP[k][l] * fracToCart[2][l];\n"
"            }\n"
"        }\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+0], (mm_ulong) ((mm_long) (-Exx*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+1], (mm_ulong) ((mm_long) (-Eyy*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+2], (mm_ulong) ((mm_long) (-Ezz*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+3], (mm_ulong) ((mm_long) (-Exy*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+4], (mm_ulong) ((mm_long) (-Exz*0x100000000)));\n"
"        ATOMIC_ADD(&fieldGradientPolar[6*i+5], (mm_ulong) ((mm_long) (-Eyz*0x100000000)));\n"
"#endif\n"
"    }\n"
"}\n"
"#endif";
const string CommonAmoebaKernelSources::multipoles = "#define GROUP_SIZE 128\n"
"\n"
"KERNEL void computeLabFrameMoments(GLOBAL real4* RESTRICT posq, GLOBAL int4* RESTRICT multipoleParticles, GLOBAL float* RESTRICT molecularDipoles,\n"
"        GLOBAL float* RESTRICT molecularQuadrupoles, GLOBAL real* RESTRICT labFrameDipoles, GLOBAL real* RESTRICT labFrameQuadrupoles,\n"
"        GLOBAL real* RESTRICT sphericalDipoles, GLOBAL real* RESTRICT sphericalQuadrupoles) {\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        // Load the spherical multipoles.\n"
"        \n"
"        int offset = 3*atom;\n"
"        sphericalDipoles[offset+0] = molecularDipoles[offset+2]; // z -> Q_10\n"
"        sphericalDipoles[offset+1] = molecularDipoles[offset+0]; // x -> Q_11c\n"
"        sphericalDipoles[offset+2] = molecularDipoles[offset+1]; // y -> Q_11s\n"
"        offset = 5*atom;\n"
"        sphericalQuadrupoles[offset+0] = -3.0f*(molecularQuadrupoles[offset+0]+molecularQuadrupoles[offset+3]); // zz -> Q_20\n"
"        sphericalQuadrupoles[offset+1] = (2*SQRT((real) 3))*molecularQuadrupoles[offset+2]; // xz -> Q_21c\n"
"        sphericalQuadrupoles[offset+2] = (2*SQRT((real) 3))*molecularQuadrupoles[offset+4]; // yz -> Q_21s\n"
"        sphericalQuadrupoles[offset+3] = SQRT((real) 3)*(molecularQuadrupoles[offset+0]-molecularQuadrupoles[offset+3]); // xx-yy -> Q_22c\n"
"        sphericalQuadrupoles[offset+4] = (2*SQRT((real) 3))*molecularQuadrupoles[offset+1]; // xy -> Q_22s\n"
"        \n"
"        // get coordinates of this atom and the z & x axis atoms\n"
"        // compute the vector between the atoms and 1/sqrt(d2), d2 is distance between\n"
"        // this atom and the axis atom\n"
"\n"
"        // this atom is referred to as the k-atom in notes below\n"
"\n"
"        // code common to ZThenX and Bisector\n"
"        \n"
"        int4 particles = multipoleParticles[atom];\n"
"        if (particles.z >= 0) {\n"
"            real4 thisParticlePos = posq[atom];\n"
"            real4 posZ = posq[particles.z];\n"
"            real3 vectorZ = normalize(make_real3(posZ.x-thisParticlePos.x, posZ.y-thisParticlePos.y, posZ.z-thisParticlePos.z));\n"
"            int axisType = particles.w; \n"
"            real4 posX;\n"
"            real3 vectorX;\n"
"            if (axisType >= 4) {\n"
"                if (fabs(vectorZ.x) < 0.866)\n"
"                    vectorX = make_real3(1, 0, 0);\n"
"                else\n"
"                    vectorX = make_real3(0, 1, 0);\n"
"            }\n"
"            else {\n"
"                posX = posq[particles.x];\n"
"                vectorX = make_real3(posX.x-thisParticlePos.x, posX.y-thisParticlePos.y, posX.z-thisParticlePos.z);\n"
"            }\n"
"    \n"
"            /*\n"
"                z-only\n"
"                   (1) norm z\n"
"                   (2) select random x\n"
"                   (3) x = x - (x.z)z\n"
"                   (4) norm x\n"
"        \n"
"                z-then-x\n"
"                   (1) norm z\n"
"                   (2) norm x (not needed)\n"
"                   (3) x = x - (x.z)z\n"
"                   (4) norm x\n"
"        \n"
"                bisector\n"
"                   (1) norm z\n"
"                   (2) norm x \n"
"                   (3) z = x + z\n"
"                   (4) norm z\n"
"                   (5) x = x - (x.z)z \n"
"                   (6) norm x \n"
"        \n"
"                z-bisect\n"
"                   (1) norm z\n"
"                   (2) norm x \n"
"                   (3) norm y \n"
"                   (3) x = x + y\n"
"                   (4) norm x\n"
"                   (5) x = x - (x.z)z \n"
"                   (6) norm x \n"
"        \n"
"                3-fold\n"
"                   (1) norm z\n"
"                   (2) norm x \n"
"                   (3) norm y \n"
"                   (4) z = x + y + z\n"
"                   (5) norm z\n"
"                   (6) x = x - (x.z)z \n"
"                   (7) norm x \n"
"        \n"
"            */\n"
"        \n"
"            // branch based on axis type\n"
"                    \n"
"            if (axisType == 1) {\n"
"        \n"
"                // bisector\n"
"                \n"
"                vectorX = normalize(vectorX);\n"
"                vectorZ += vectorX;\n"
"                vectorZ = normalize(vectorZ);\n"
"            }\n"
"            else if (axisType == 2 || axisType == 3) { \n"
"         \n"
"                // z-bisect\n"
"        \n"
"                if (particles.y >= 0 && particles.y < NUM_ATOMS) {\n"
"                    real4 posY = posq[particles.y];\n"
"                    real3 vectorY = make_real3(posY.x-thisParticlePos.x, posY.y-thisParticlePos.y, posY.z-thisParticlePos.z);\n"
"                    vectorY = normalize(vectorY);\n"
"                    vectorX = normalize(vectorX);\n"
"                    if (axisType == 2) {\n"
"                        vectorX += vectorY;\n"
"                        vectorX = normalize(vectorX);\n"
"                    }\n"
"                    else { \n"
"             \n"
"                        // 3-fold\n"
"                \n"
"                        vectorZ += vectorX + vectorY;\n"
"                        vectorZ = normalize(vectorZ);\n"
"                    }\n"
"                }\n"
"         \n"
"            }\n"
"            \n"
"            // x = x - (x.z)z\n"
"        \n"
"            vectorX -= dot(vectorZ, vectorX)*vectorZ;\n"
"            vectorX = normalize(vectorX);\n"
"            real3 vectorY = cross(vectorZ, vectorX);\n"
"         \n"
"            // use identity rotation matrix for unrecognized axis types\n"
"        \n"
"            if (axisType < 0 || axisType > 4) {\n"
"        \n"
"                vectorX.x = 1;\n"
"                vectorX.y = 0;\n"
"                vectorX.z = 0;\n"
"        \n"
"                vectorY.x = 0;\n"
"                vectorY.y = 1;\n"
"                vectorY.z = 0;\n"
"        \n"
"                vectorZ.x = 0;\n"
"                vectorZ.y = 0;\n"
"                vectorZ.z = 1;\n"
"            }\n"
"            \n"
"            // Check the chirality and see whether it needs to be reversed\n"
"            \n"
"            bool reverse = false;\n"
"            if (axisType == 0 && particles.x >= 0 && particles.y >=0 && particles.z >= 0) {\n"
"                real4 posY = posq[particles.y];\n"
"                real delta[4][3];\n"
"\n"
"                delta[0][0] = thisParticlePos.x - posY.x;\n"
"                delta[0][1] = thisParticlePos.y - posY.y;\n"
"                delta[0][2] = thisParticlePos.z - posY.z;\n"
"\n"
"                delta[1][0] = posZ.x - posY.x;\n"
"                delta[1][1] = posZ.y - posY.y;\n"
"                delta[1][2] = posZ.z - posY.z;\n"
"\n"
"                delta[2][0] = posX.x - posY.x;\n"
"                delta[2][1] = posX.y - posY.y;\n"
"                delta[2][2] = posX.z - posY.z;\n"
"\n"
"                delta[3][0] = delta[1][1]*delta[2][2] - delta[1][2]*delta[2][1];\n"
"                delta[3][1] = delta[2][1]*delta[0][2] - delta[2][2]*delta[0][1];\n"
"                delta[3][2] = delta[0][1]*delta[1][2] - delta[0][2]*delta[1][1];\n"
"\n"
"                real volume = delta[3][0]*delta[0][0] + delta[3][1]*delta[1][0] + delta[3][2]*delta[2][0];\n"
"                reverse = (volume < 0);\n"
"            }\n"
"        \n"
"            // Transform the dipole\n"
"            \n"
"            offset = 3*atom;\n"
"            real molDipole[3];\n"
"            molDipole[0] = molecularDipoles[offset];\n"
"            molDipole[1] = molecularDipoles[offset+1];\n"
"            molDipole[2] = molecularDipoles[offset+2];\n"
"            if (reverse)\n"
"                molDipole[1] *= -1;\n"
"            labFrameDipoles[3*atom] = molDipole[0]*vectorX.x + molDipole[1]*vectorY.x + molDipole[2]*vectorZ.x;\n"
"            labFrameDipoles[3*atom+1] = molDipole[0]*vectorX.y + molDipole[1]*vectorY.y + molDipole[2]*vectorZ.y,\n"
"            labFrameDipoles[3*atom+2] = molDipole[0]*vectorX.z + molDipole[1]*vectorY.z + molDipole[2]*vectorZ.z;\n"
"            \n"
"            // ---------------------------------------------------------------------------------------\n"
"            \n"
"            // Transform the quadrupole\n"
"            \n"
"            offset = 5*atom;\n"
"            real mPoleXX = molecularQuadrupoles[offset];\n"
"            real mPoleXY = molecularQuadrupoles[offset+1];\n"
"            real mPoleXZ = molecularQuadrupoles[offset+2];\n"
"            real mPoleYY = molecularQuadrupoles[offset+3];\n"
"            real mPoleYZ = molecularQuadrupoles[offset+4];\n"
"            real mPoleZZ = -(mPoleXX+mPoleYY);\n"
"        \n"
"            if (reverse) {\n"
"                mPoleXY *= -1;\n"
"                mPoleYZ *= -1;\n"
"            }\n"
"            \n"
"            labFrameQuadrupoles[offset] = vectorX.x*(vectorX.x*mPoleXX + vectorY.x*mPoleXY + vectorZ.x*mPoleXZ)\n"
"                                        + vectorY.x*(vectorX.x*mPoleXY + vectorY.x*mPoleYY + vectorZ.x*mPoleYZ)\n"
"                                        + vectorZ.x*(vectorX.x*mPoleXZ + vectorY.x*mPoleYZ + vectorZ.x*mPoleZZ);\n"
"            labFrameQuadrupoles[offset+1] = vectorX.x*(vectorX.y*mPoleXX + vectorY.y*mPoleXY + vectorZ.y*mPoleXZ)\n"
"                                        + vectorY.x*(vectorX.y*mPoleXY + vectorY.y*mPoleYY + vectorZ.y*mPoleYZ)\n"
"                                        + vectorZ.x*(vectorX.y*mPoleXZ + vectorY.y*mPoleYZ + vectorZ.y*mPoleZZ);\n"
"            labFrameQuadrupoles[offset+2] = vectorX.x*(vectorX.z*mPoleXX + vectorY.z*mPoleXY + vectorZ.z*mPoleXZ)\n"
"                                        + vectorY.x*(vectorX.z*mPoleXY + vectorY.z*mPoleYY + vectorZ.z*mPoleYZ)\n"
"                                        + vectorZ.x*(vectorX.z*mPoleXZ + vectorY.z*mPoleYZ + vectorZ.z*mPoleZZ);\n"
"            labFrameQuadrupoles[offset+3] = vectorX.y*(vectorX.y*mPoleXX + vectorY.y*mPoleXY + vectorZ.y*mPoleXZ)\n"
"                                        + vectorY.y*(vectorX.y*mPoleXY + vectorY.y*mPoleYY + vectorZ.y*mPoleYZ)\n"
"                                        + vectorZ.y*(vectorX.y*mPoleXZ + vectorY.y*mPoleYZ + vectorZ.y*mPoleZZ);\n"
"            labFrameQuadrupoles[offset+4] = vectorX.y*(vectorX.z*mPoleXX + vectorY.z*mPoleXY + vectorZ.z*mPoleXZ)\n"
"                                        + vectorY.y*(vectorX.z*mPoleXY + vectorY.z*mPoleYY + vectorZ.z*mPoleYZ)\n"
"                                        + vectorZ.y*(vectorX.z*mPoleXZ + vectorY.z*mPoleYZ + vectorZ.z*mPoleZZ);\n"
"            \n"
"            // ---------------------------------------------------------------------------------------\n"
"            \n"
"            // Now transform the spherical multipoles.  First do the dipoles.\n"
"\n"
"            offset = 3*atom;\n"
"            real sphericalDipole[3];\n"
"            sphericalDipole[0] = sphericalDipoles[offset];\n"
"            sphericalDipole[1] = sphericalDipoles[offset+1];\n"
"            sphericalDipole[2] = sphericalDipoles[offset+2];\n"
"            if (reverse)\n"
"                sphericalDipole[2] *= -1;\n"
"            sphericalDipoles[offset] = sphericalDipole[0]*vectorZ.z + sphericalDipole[1]*vectorX.z + sphericalDipole[2]*vectorY.z;\n"
"            sphericalDipoles[offset+1] = sphericalDipole[0]*vectorZ.x + sphericalDipole[1]*vectorX.x + sphericalDipole[2]*vectorY.x;\n"
"            sphericalDipoles[offset+2] = sphericalDipole[0]*vectorZ.y + sphericalDipole[1]*vectorX.y + sphericalDipole[2]*vectorY.y;\n"
"            \n"
"            // Now the quadrupoles.\n"
"\n"
"            offset = 5*atom;\n"
"            real sphericalQuadrupole[5];\n"
"            sphericalQuadrupole[0] = sphericalQuadrupoles[offset];\n"
"            sphericalQuadrupole[1] = sphericalQuadrupoles[offset+1];\n"
"            sphericalQuadrupole[2] = sphericalQuadrupoles[offset+2];\n"
"            sphericalQuadrupole[3] = sphericalQuadrupoles[offset+3];\n"
"            sphericalQuadrupole[4] = sphericalQuadrupoles[offset+4];\n"
"            if (reverse) {\n"
"                sphericalQuadrupole[2] *= -1;\n"
"                sphericalQuadrupole[4] *= -1;\n"
"            }\n"
"            real rotatedQuadrupole[5] = {0, 0, 0, 0, 0};\n"
"            real sqrtThree = SQRT((real) 3);\n"
"            rotatedQuadrupole[0] += sphericalQuadrupole[0]*0.5f*(3.0f*vectorZ.z*vectorZ.z - 1.0f) +\n"
"                                    sphericalQuadrupole[1]*sqrtThree*vectorZ.z*vectorX.z +\n"
"                                    sphericalQuadrupole[2]*sqrtThree*vectorZ.z*vectorY.z +\n"
"                                    sphericalQuadrupole[3]*0.5f*sqrtThree*(vectorX.z*vectorX.z - vectorY.z*vectorY.z) +\n"
"                                    sphericalQuadrupole[4]*sqrtThree*vectorX.z*vectorY.z;\n"
"            rotatedQuadrupole[1] += sphericalQuadrupole[0]*sqrtThree*vectorZ.z*vectorZ.x +\n"
"                                    sphericalQuadrupole[1]*(vectorZ.x*vectorX.z + vectorZ.z*vectorX.x) +\n"
"                                    sphericalQuadrupole[2]*(vectorZ.x*vectorY.z + vectorZ.z*vectorY.x) +\n"
"                                    sphericalQuadrupole[3]*(vectorX.z*vectorX.x - vectorY.z*vectorY.x) +\n"
"                                    sphericalQuadrupole[4]*(vectorX.x*vectorY.z + vectorX.z*vectorY.x);\n"
"            rotatedQuadrupole[2] += sphericalQuadrupole[0]*sqrtThree*vectorZ.z*vectorZ.y +\n"
"                                    sphericalQuadrupole[1]*(vectorZ.y*vectorX.z + vectorZ.z*vectorX.y) +\n"
"                                    sphericalQuadrupole[2]*(vectorZ.y*vectorY.z + vectorZ.z*vectorY.y) +\n"
"                                    sphericalQuadrupole[3]*(vectorX.z*vectorX.y - vectorY.z*vectorY.y) +\n"
"                                    sphericalQuadrupole[4]*(vectorX.y*vectorY.z + vectorX.z*vectorY.y);\n"
"            rotatedQuadrupole[3] += sphericalQuadrupole[0]*0.5f*sqrtThree*(vectorZ.x*vectorZ.x - vectorZ.y*vectorZ.y) +\n"
"                                    sphericalQuadrupole[1]*(vectorZ.x*vectorX.x - vectorZ.y*vectorX.y) +\n"
"                                    sphericalQuadrupole[2]*(vectorZ.x*vectorY.x - vectorZ.y*vectorY.y) +\n"
"                                    sphericalQuadrupole[3]*0.5f*(vectorX.x*vectorX.x - vectorX.y*vectorX.y - vectorY.x*vectorY.x + vectorY.y*vectorY.y) +\n"
"                                    sphericalQuadrupole[4]*(vectorX.x*vectorY.x - vectorX.y*vectorY.y);\n"
"            rotatedQuadrupole[4] += sphericalQuadrupole[0]*sqrtThree*vectorZ.x*vectorZ.y +\n"
"                                    sphericalQuadrupole[1]*(vectorZ.y*vectorX.x + vectorZ.x*vectorX.y) +\n"
"                                    sphericalQuadrupole[2]*(vectorZ.y*vectorY.x + vectorZ.x*vectorY.y) +\n"
"                                    sphericalQuadrupole[3]*(vectorX.x*vectorX.y - vectorY.x*vectorY.y) +\n"
"                                    sphericalQuadrupole[4]*(vectorX.y*vectorY.x + vectorX.x*vectorY.y);\n"
"            sphericalQuadrupoles[offset] = rotatedQuadrupole[0];\n"
"            sphericalQuadrupoles[offset+1] = rotatedQuadrupole[1];\n"
"            sphericalQuadrupoles[offset+2] = rotatedQuadrupole[2];\n"
"            sphericalQuadrupoles[offset+3] = rotatedQuadrupole[3];\n"
"            sphericalQuadrupoles[offset+4] = rotatedQuadrupole[4];\n"
"        }\n"
"        else {\n"
"            labFrameDipoles[3*atom] = molecularDipoles[3*atom];\n"
"            labFrameDipoles[3*atom+1] = molecularDipoles[3*atom+1];\n"
"            labFrameDipoles[3*atom+2] = molecularDipoles[3*atom+2];\n"
"            labFrameQuadrupoles[5*atom] = molecularQuadrupoles[5*atom];\n"
"            labFrameQuadrupoles[5*atom+1] = molecularQuadrupoles[5*atom+1];\n"
"            labFrameQuadrupoles[5*atom+2] = molecularQuadrupoles[5*atom+2];\n"
"            labFrameQuadrupoles[5*atom+3] = molecularQuadrupoles[5*atom+3];\n"
"            labFrameQuadrupoles[5*atom+4] = molecularQuadrupoles[5*atom+4];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void recordInducedDipoles(GLOBAL const mm_long* RESTRICT fieldBuffers, GLOBAL const mm_long* RESTRICT fieldPolarBuffers,\n"
"#ifdef USE_GK\n"
"        GLOBAL const mm_long* RESTRICT gkFieldBuffers, GLOBAL real* RESTRICT inducedDipoleS, GLOBAL real* RESTRICT inducedDipolePolarS, \n"
"#endif\n"
"        GLOBAL real* RESTRICT inducedDipole, GLOBAL real* RESTRICT inducedDipolePolar, GLOBAL const float* RESTRICT polarizability) {\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real scale = polarizability[atom]/(real) 0x100000000;\n"
"        inducedDipole[3*atom] = scale*fieldBuffers[atom];\n"
"        inducedDipole[3*atom+1] = scale*fieldBuffers[atom+PADDED_NUM_ATOMS];\n"
"        inducedDipole[3*atom+2] = scale*fieldBuffers[atom+PADDED_NUM_ATOMS*2];\n"
"        inducedDipolePolar[3*atom] = scale*fieldPolarBuffers[atom];\n"
"        inducedDipolePolar[3*atom+1] = scale*fieldPolarBuffers[atom+PADDED_NUM_ATOMS];\n"
"        inducedDipolePolar[3*atom+2] = scale*fieldPolarBuffers[atom+PADDED_NUM_ATOMS*2];\n"
"#ifdef USE_GK\n"
"        inducedDipoleS[3*atom] = scale*(fieldBuffers[atom]+gkFieldBuffers[atom]);\n"
"        inducedDipoleS[3*atom+1] = scale*(fieldBuffers[atom+PADDED_NUM_ATOMS]+gkFieldBuffers[atom+PADDED_NUM_ATOMS]);\n"
"        inducedDipoleS[3*atom+2] = scale*(fieldBuffers[atom+PADDED_NUM_ATOMS*2]+gkFieldBuffers[atom+PADDED_NUM_ATOMS*2]);\n"
"        inducedDipolePolarS[3*atom] = scale*(fieldPolarBuffers[atom]+gkFieldBuffers[atom]);\n"
"        inducedDipolePolarS[3*atom+1] = scale*(fieldPolarBuffers[atom+PADDED_NUM_ATOMS]+gkFieldBuffers[atom+PADDED_NUM_ATOMS]);\n"
"        inducedDipolePolarS[3*atom+2] = scale*(fieldPolarBuffers[atom+PADDED_NUM_ATOMS*2]+gkFieldBuffers[atom+PADDED_NUM_ATOMS*2]);\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Normalize a vector and return what its magnitude was.\n"
" */\n"
"inline DEVICE real normVector(real3* v) {\n"
"    real n = SQRT(dot(*v, *v));\n"
"    *v *= (n > 0 ? RECIP(n) : 0);\n"
"    return n;\n"
"}\n"
"\n"
"/**\n"
" * Compute the force on each particle due to the torque.\n"
" */\n"
"KERNEL void mapTorqueToForce(GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL const mm_long* RESTRICT torqueBuffers,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT multipoleParticles) {\n"
"    const int U = 0;\n"
"    const int V = 1;\n"
"    const int W = 2;\n"
"    const int R = 3;\n"
"    const int S = 4;\n"
"    const int UV = 5;\n"
"    const int UW = 6;\n"
"    const int VW = 7;\n"
"    const int UR = 8;\n"
"    const int US = 9;\n"
"    const int VS = 10;\n"
"    const int WS = 11;\n"
"    \n"
"    const int X = 0;\n"
"    const int Y = 1;\n"
"    const int Z = 2;\n"
"    const int I = 3;\n"
"    \n"
"    const real torqueScale = RECIP((double) 0x100000000);\n"
"    \n"
"    real3 forces[4];\n"
"    real norms[12];\n"
"    real3 vector[12];\n"
"    real angles[12][2];\n"
"  \n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        int4 particles = multipoleParticles[atom];\n"
"        int axisAtom = particles.z;\n"
"        int axisType = particles.w;\n"
"    \n"
"        // NoAxisType\n"
"    \n"
"        if (axisType < 5 && particles.z >= 0) {\n"
"            real3 atomPos = trimTo3(posq[atom]);\n"
"            vector[U] = atomPos - trimTo3(posq[axisAtom]);\n"
"            norms[U] = normVector(&vector[U]);\n"
"            if (axisType != 4 && particles.x >= 0)\n"
"                vector[V] = atomPos - trimTo3(posq[particles.x]);\n"
"            else {\n"
"                if (fabs(vector[U].x/norms[U]) < 0.866)\n"
"                    vector[V] = make_real3(1, 0, 0);\n"
"                else\n"
"                    vector[V] = make_real3(0, 1, 0);\n"
"            }\n"
"            norms[V] = normVector(&vector[V]);\n"
"        \n"
"            // W = UxV\n"
"        \n"
"            if (axisType < 2 || axisType > 3)\n"
"                vector[W] = cross(vector[U], vector[V]);\n"
"            else\n"
"                vector[W] = atomPos - trimTo3(posq[particles.y]);\n"
"            norms[W] = normVector(&vector[W]);\n"
"        \n"
"            vector[UV] = cross(vector[V], vector[U]);\n"
"            vector[UW] = cross(vector[W], vector[U]);\n"
"            vector[VW] = cross(vector[W], vector[V]);\n"
"        \n"
"            norms[UV] = normVector(&vector[UV]);\n"
"            norms[UW] = normVector(&vector[UW]);\n"
"            norms[VW] = normVector(&vector[VW]);\n"
"        \n"
"            angles[UV][0] = dot(vector[U], vector[V]);\n"
"            angles[UV][1] = SQRT(1 - angles[UV][0]*angles[UV][0]);\n"
"        \n"
"            angles[UW][0] = dot(vector[U], vector[W]);\n"
"            angles[UW][1] = SQRT(1 - angles[UW][0]*angles[UW][0]);\n"
"        \n"
"            angles[VW][0] = dot(vector[V], vector[W]);\n"
"            angles[VW][1] = SQRT(1 - angles[VW][0]*angles[VW][0]);\n"
"        \n"
"            real dphi[3];\n"
"            real3 torque = make_real3(torqueScale*torqueBuffers[atom], torqueScale*torqueBuffers[atom+PADDED_NUM_ATOMS], torqueScale*torqueBuffers[atom+PADDED_NUM_ATOMS*2]);\n"
"            dphi[U] = -dot(vector[U], torque);\n"
"            dphi[V] = -dot(vector[V], torque);\n"
"            dphi[W] = -dot(vector[W], torque);\n"
"        \n"
"            // z-then-x and bisector\n"
"        \n"
"            if (axisType == 0 || axisType == 1) {\n"
"                real factor1 = dphi[V]/(norms[U]*angles[UV][1]);\n"
"                real factor2 = dphi[W]/(norms[U]);\n"
"                real factor3 = -dphi[U]/(norms[V]*angles[UV][1]);\n"
"                real factor4 = 0;\n"
"                if (axisType == 1) {\n"
"                    factor2 *= 0.5f;\n"
"                    factor4 = 0.5f*dphi[W]/(norms[V]);\n"
"                }\n"
"                forces[Z] = vector[UV]*factor1 + factor2*vector[UW];\n"
"                forces[X] = vector[UV]*factor3 + factor4*vector[VW];\n"
"                forces[I] = -(forces[X]+forces[Z]);\n"
"                forces[Y] = make_real3(0);\n"
"            }\n"
"            else if (axisType == 2) {\n"
"                // z-bisect\n"
"        \n"
"                vector[R] = vector[V] + vector[W]; \n"
"        \n"
"                vector[S] = cross(vector[U], vector[R]);\n"
"        \n"
"                norms[R] = normVector(&vector[R]);\n"
"                norms[S] = normVector(&vector[S]);\n"
"        \n"
"                vector[UR] = cross(vector[R], vector[U]);\n"
"                vector[US] = cross(vector[S], vector[U]);\n"
"                vector[VS] = cross(vector[S], vector[V]);\n"
"                vector[WS] = cross(vector[S], vector[W]);\n"
"        \n"
"                norms[UR] = normVector(&vector[UR]);\n"
"                norms[US] = normVector(&vector[US]);\n"
"                norms[VS] = normVector(&vector[VS]);\n"
"                norms[WS] = normVector(&vector[WS]);\n"
"        \n"
"                angles[UR][0] = dot(vector[U], vector[R]);\n"
"                angles[UR][1] = SQRT(1 - angles[UR][0]*angles[UR][0]);\n"
"        \n"
"                angles[US][0] = dot(vector[U], vector[S]);\n"
"                angles[US][1] = SQRT(1 - angles[US][0]*angles[US][0]);\n"
"        \n"
"                angles[VS][0] = dot(vector[V], vector[S]);\n"
"                angles[VS][1] = SQRT(1 - angles[VS][0]*angles[VS][0]);\n"
"        \n"
"                angles[WS][0] = dot(vector[W], vector[S]);\n"
"                angles[WS][1] = SQRT(1 - angles[WS][0]*angles[WS][0]);\n"
"         \n"
"                real3 t1 = vector[V] - vector[S]*angles[VS][0];\n"
"                real3 t2 = vector[W] - vector[S]*angles[WS][0];\n"
"                normVector(&t1);\n"
"                normVector(&t2);\n"
"                real ut1cos = dot(vector[U], t1);\n"
"                real ut1sin = SQRT(1 - ut1cos*ut1cos);\n"
"                real ut2cos = dot(vector[U], t2);\n"
"                real ut2sin = SQRT(1 - ut2cos*ut2cos);\n"
"        \n"
"                real dphiR = -dot(vector[R], torque);\n"
"                real dphiS = -dot(vector[S], torque);\n"
"        \n"
"                real factor1 = dphiR/(norms[U]*angles[UR][1]);\n"
"                real factor2 = dphiS/(norms[U]);\n"
"                real factor3 = dphi[U]/(norms[V]*(ut1sin+ut2sin));\n"
"                real factor4 = dphi[U]/(norms[W]*(ut1sin+ut2sin));\n"
"                forces[Z] = vector[UR]*factor1 + factor2*vector[US];\n"
"                forces[X] = (angles[VS][1]*vector[S] - angles[VS][0]*t1)*factor3;\n"
"                forces[Y] = (angles[WS][1]*vector[S] - angles[WS][0]*t2)*factor4;\n"
"                forces[I] = -(forces[X] + forces[Y] + forces[Z]);\n"
"            }\n"
"            else if (axisType == 3) {\n"
"                // 3-fold\n"
"        \n"
"                forces[Z] = (vector[UW]*dphi[W]/(norms[U]*angles[UW][1]) +\n"
"                            vector[UV]*dphi[V]/(norms[U]*angles[UV][1]) -\n"
"                            vector[UW]*dphi[U]/(norms[U]*angles[UW][1]) -\n"
"                            vector[UV]*dphi[U]/(norms[U]*angles[UV][1]))/3;\n"
"\n"
"                forces[X] = (vector[VW]*dphi[W]/(norms[V]*angles[VW][1]) -\n"
"                            vector[UV]*dphi[U]/(norms[V]*angles[UV][1]) -\n"
"                            vector[VW]*dphi[V]/(norms[V]*angles[VW][1]) +\n"
"                            vector[UV]*dphi[V]/(norms[V]*angles[UV][1]))/3;\n"
"\n"
"                forces[Y] = (-vector[UW]*dphi[U]/(norms[W]*angles[UW][1]) -\n"
"                            vector[VW]*dphi[V]/(norms[W]*angles[VW][1]) +\n"
"                            vector[UW]*dphi[W]/(norms[W]*angles[UW][1]) +\n"
"                            vector[VW]*dphi[W]/(norms[W]*angles[VW][1]))/3;\n"
"                forces[I] = -(forces[X] + forces[Y] + forces[Z]);\n"
"            }\n"
"            else if (axisType == 4) {\n"
"                // z-only\n"
"        \n"
"                forces[Z] = vector[UV]*dphi[V]/(norms[U]*angles[UV][1]) + vector[UW]*dphi[W]/norms[U];\n"
"                forces[X] = make_real3(0);\n"
"                forces[Y] = make_real3(0);\n"
"                forces[I] = -forces[Z];\n"
"            }\n"
"            else {\n"
"                forces[Z] = make_real3(0);\n"
"                forces[X] = make_real3(0);\n"
"                forces[Y] = make_real3(0);\n"
"                forces[I] = make_real3(0);\n"
"            }\n"
"        \n"
"            // Store results\n"
"        \n"
"            ATOMIC_ADD(&forceBuffers[particles.z], (mm_ulong) ((mm_long) (forces[Z].x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[particles.z+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Z].y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[particles.z+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Z].z*0x100000000)));\n"
"            if (axisType != 4) {\n"
"                ATOMIC_ADD(&forceBuffers[particles.x], (mm_ulong) ((mm_long) (forces[X].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.x+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[X].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.x+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[X].z*0x100000000)));\n"
"            }\n"
"            if ((axisType == 2 || axisType == 3) && particles.y > -1) {\n"
"                ATOMIC_ADD(&forceBuffers[particles.y], (mm_ulong) ((mm_long) (forces[Y].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.y+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Y].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[particles.y+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[Y].z*0x100000000)));\n"
"            }\n"
"            ATOMIC_ADD(&forceBuffers[atom], (mm_ulong) ((mm_long) (forces[I].x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[I].y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forces[I].z*0x100000000)));\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the electrostatic potential at each of a set of points.\n"
" */\n"
"KERNEL void computePotentialAtPoints(GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT labFrameDipole,\n"
"        GLOBAL const real* RESTRICT labFrameQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real4* RESTRICT points,\n"
"        GLOBAL real* RESTRICT potential, int numPoints, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ) {\n"
"    LOCAL real4 localPosq[GROUP_SIZE];\n"
"    LOCAL real3 localDipole[GROUP_SIZE];\n"
"    LOCAL real3 localInducedDipole[GROUP_SIZE];\n"
"    LOCAL real localQuadrupole[5*GROUP_SIZE];\n"
"    for (int basePoint = GROUP_ID*LOCAL_SIZE; basePoint < numPoints; basePoint += GLOBAL_SIZE) {\n"
"        int point = basePoint+LOCAL_ID;\n"
"        real4 pointPos = points[point];\n"
"        real p = 0;\n"
"        for (int baseAtom = 0; baseAtom < NUM_ATOMS; baseAtom += LOCAL_SIZE) {\n"
"            int atom = baseAtom+LOCAL_ID;\n"
"            \n"
"            // Load data into shared memory.\n"
"            \n"
"            if (atom < NUM_ATOMS) {\n"
"                localPosq[LOCAL_ID] = posq[atom];\n"
"                localDipole[LOCAL_ID] = make_real3(labFrameDipole[3*atom], labFrameDipole[3*atom+1], labFrameDipole[3*atom+2]);\n"
"                localInducedDipole[LOCAL_ID] = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"                localQuadrupole[5*LOCAL_ID] = labFrameQuadrupole[5*atom];\n"
"                localQuadrupole[5*LOCAL_ID+1] = labFrameQuadrupole[5*atom+1];\n"
"                localQuadrupole[5*LOCAL_ID+2] = labFrameQuadrupole[5*atom+2];\n"
"                localQuadrupole[5*LOCAL_ID+3] = labFrameQuadrupole[5*atom+3];\n"
"                localQuadrupole[5*LOCAL_ID+4] = labFrameQuadrupole[5*atom+4];\n"
"            }\n"
"            SYNC_THREADS;\n"
"            \n"
"            // Loop over atoms and compute the potential at this point.\n"
"\n"
"            if (point < numPoints) {\n"
"                int end = min((int) LOCAL_SIZE, NUM_ATOMS-baseAtom);\n"
"                for (int i = 0; i < end; i++) {\n"
"                    real3 delta = trimTo3(localPosq[i]-pointPos);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta, delta);\n"
"                    real rInv = RSQRT(r2);\n"
"                    p += localPosq[i].w*rInv;\n"
"                    real rr2 = rInv*rInv;\n"
"                    real rr3 = rInv*rr2;\n"
"                    real scd = dot(localDipole[i], delta);\n"
"                    real scu = dot(localInducedDipole[i], delta);\n"
"                    p -= (scd+scu)*rr3;\n"
"                    real rr5 = 3*rr3*rr2;\n"
"                    real scq = delta.x*dot(delta, make_real3(localQuadrupole[5*i+0], localQuadrupole[5*i+1], localQuadrupole[5*i+2])) +\n"
"                            delta.y*dot(delta, make_real3(localQuadrupole[5*i+1], localQuadrupole[5*i+3], localQuadrupole[5*i+4])) +\n"
"                            delta.z*dot(delta, make_real3(localQuadrupole[5*i+2], localQuadrupole[5*i+4], -localQuadrupole[5*i]-localQuadrupole[5*i+3]));\n"
"                    p += scq*rr5;\n"
"                }\n"
"            }\n"
"            SYNC_THREADS;\n"
"        }\n"
"        if (point < numPoints)\n"
"            potential[point] = p*ENERGY_SCALE_FACTOR;\n"
"    }\n"
"}";
const string CommonAmoebaKernelSources::pmeMultipoleElectrostatics = "#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real3 pos, force, torque, inducedDipole, inducedDipolePolar, sphericalDipole;\n"
"    real q;\n"
"    float thole, damp;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real sphericalQuadrupole[5];\n"
"#endif\n"
"} AtomData;\n"
"\n"
"inline DEVICE AtomData loadAtomData(int atom, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT sphericalDipole,\n"
"            GLOBAL const real* RESTRICT sphericalQuadrupole, GLOBAL const real* RESTRICT inducedDipole, GLOBAL const real* RESTRICT inducedDipolePolar,\n"
"            GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    AtomData data;\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    data.q = atomPosq.w;\n"
"    data.sphericalDipole.x = sphericalDipole[atom*3];\n"
"    data.sphericalDipole.y = sphericalDipole[atom*3+1];\n"
"    data.sphericalDipole.z = sphericalDipole[atom*3+2];\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    data.sphericalQuadrupole[0] = sphericalQuadrupole[atom*5];\n"
"    data.sphericalQuadrupole[1] = sphericalQuadrupole[atom*5+1];\n"
"    data.sphericalQuadrupole[2] = sphericalQuadrupole[atom*5+2];\n"
"    data.sphericalQuadrupole[3] = sphericalQuadrupole[atom*5+3];\n"
"    data.sphericalQuadrupole[4] = sphericalQuadrupole[atom*5+4];\n"
"#endif\n"
"    data.inducedDipole = make_real3(inducedDipole[3*atom], inducedDipole[3*atom+1], inducedDipole[3*atom+2]);\n"
"    data.inducedDipolePolar = make_real3(inducedDipolePolar[3*atom], inducedDipolePolar[3*atom+1], inducedDipolePolar[3*atom+2]);\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"    return data;\n"
"}\n"
"\n"
"DEVICE real computeDScaleFactor(unsigned int polarizationGroup, int index) {\n"
"    return (polarizationGroup & 1<<index ? 0 : 1);\n"
"}\n"
"\n"
"DEVICE float computeMScaleFactor(uint2 covalent, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    return (x ? (y ? 0.0f : 0.4f) : (y ? 0.8f : 1.0f));\n"
"}\n"
"\n"
"DEVICE float computePScaleFactor(uint2 covalent, unsigned int polarizationGroup, int index) {\n"
"    int mask = 1<<index;\n"
"    bool x = (covalent.x & mask);\n"
"    bool y = (covalent.y & mask);\n"
"    bool p = (polarizationGroup & mask);\n"
"    return (x && y ? 0.0f : (x && p ? 0.5f : 1.0f));\n"
"}\n"
"\n"
"DEVICE void computeOneInteraction(AtomData* atom1, LOCAL_ARG AtomData* atom2, bool hasExclusions, float dScale, float pScale, float mScale, float forceFactor,\n"
"                                      mixed* energy, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ) {\n"
"    // Compute the displacement.\n"
"    \n"
"    real3 delta;\n"
"    delta.x = atom2->pos.x - atom1->pos.x;\n"
"    delta.y = atom2->pos.y - atom1->pos.y;\n"
"    delta.z = atom2->pos.z - atom1->pos.z;\n"
"    APPLY_PERIODIC_TO_DELTA(delta)\n"
"    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"    if (r2 > CUTOFF_SQUARED)\n"
"        return;\n"
"\n"
"    real rInv = RSQRT(r2);\n"
"    real r = r2*rInv;\n"
"\n"
"    // Rotate the various dipoles and quadrupoles.\n"
"\n"
"    real qiRotationMatrix[3][3];\n"
"    buildQIRotationMatrix(delta, rInv, qiRotationMatrix);\n"
"\n"
"    \n"
"    real3 qiUindI = 0.5f*make_real3(qiRotationMatrix[0][1]*atom1->inducedDipole.x + qiRotationMatrix[0][2]*atom1->inducedDipole.y + qiRotationMatrix[0][0]*atom1->inducedDipole.z,\n"
"                                    qiRotationMatrix[1][1]*atom1->inducedDipole.x + qiRotationMatrix[1][2]*atom1->inducedDipole.y + qiRotationMatrix[1][0]*atom1->inducedDipole.z,\n"
"                                    qiRotationMatrix[2][1]*atom1->inducedDipole.x + qiRotationMatrix[2][2]*atom1->inducedDipole.y + qiRotationMatrix[2][0]*atom1->inducedDipole.z);\n"
"    real3 qiUindJ = 0.5f*make_real3(qiRotationMatrix[0][1]*atom2->inducedDipole.x + qiRotationMatrix[0][2]*atom2->inducedDipole.y + qiRotationMatrix[0][0]*atom2->inducedDipole.z,\n"
"                                    qiRotationMatrix[1][1]*atom2->inducedDipole.x + qiRotationMatrix[1][2]*atom2->inducedDipole.y + qiRotationMatrix[1][0]*atom2->inducedDipole.z,\n"
"                                    qiRotationMatrix[2][1]*atom2->inducedDipole.x + qiRotationMatrix[2][2]*atom2->inducedDipole.y + qiRotationMatrix[2][0]*atom2->inducedDipole.z);\n"
"    real3 qiUinpI = 0.5f*make_real3(qiRotationMatrix[0][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[0][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[0][0]*atom1->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[1][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[1][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[1][0]*atom1->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[2][1]*atom1->inducedDipolePolar.x + qiRotationMatrix[2][2]*atom1->inducedDipolePolar.y + qiRotationMatrix[2][0]*atom1->inducedDipolePolar.z);\n"
"    real3 qiUinpJ = 0.5f*make_real3(qiRotationMatrix[0][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[0][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[0][0]*atom2->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[1][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[1][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[1][0]*atom2->inducedDipolePolar.z,\n"
"                                    qiRotationMatrix[2][1]*atom2->inducedDipolePolar.x + qiRotationMatrix[2][2]*atom2->inducedDipolePolar.y + qiRotationMatrix[2][0]*atom2->inducedDipolePolar.z);\n"
"    \n"
"    real3 rotatedDipole1 = rotateDipole(atom1->sphericalDipole, qiRotationMatrix);\n"
"    real3 rotatedDipole2 = rotateDipole(atom2->sphericalDipole, qiRotationMatrix);\n"
"    real rotatedQuadrupole1[] = {0, 0, 0, 0, 0};\n"
"    real rotatedQuadrupole2[] = {0, 0, 0, 0, 0};\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    rotateQuadrupoles(qiRotationMatrix, atom1->sphericalQuadrupole, atom2->sphericalQuadrupole, rotatedQuadrupole1, rotatedQuadrupole2);\n"
"#endif    \n"
"    \n"
"    // The field derivatives at I due to permanent and induced moments on J, and vice-versa.\n"
"    // Also, their derivatives w.r.t. R, which are needed for force calculations\n"
"    real Vij[9], Vji[9], VjiR[9], VijR[9];\n"
"    // The field derivatives at I due to only permanent moments on J, and vice-versa.\n"
"    real Vijp[3], Vijd[3], Vjip[3], Vjid[3];\n"
"    real rInvVec[7], alphaRVec[8], bVec[5];\n"
"\n"
"    // The rInvVec array is defined such that the ith element is R^-i, with the\n"
"    // dieleectric constant folded in, to avoid conversions later.\n"
"    rInvVec[1] = rInv;\n"
"    for (int i = 2; i < 7; ++i)\n"
"        rInvVec[i] = rInvVec[i-1] * rInv;\n"
"\n"
"    // The alpharVec array is defined such that the ith element is (alpha R)^i,\n"
"    // where kappa (alpha in OpenMM parlance) is the Ewald attenuation parameter.\n"
"    real ralpha = EWALD_ALPHA*r;\n"
"    real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    const real erfAlphaR = erf(ralpha);\n"
"#else\n"
"    // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"    // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"    // error of 1.5e-7.\n"
"\n"
"    const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"    const real erfAlphaR = 1-(0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"    alphaRVec[1] = ralpha;\n"
"    for (int i = 2; i < 8; ++i)\n"
"        alphaRVec[i] = alphaRVec[i-1]*ralpha;\n"
"    real X = 2*exp2a/SQRT_PI;\n"
"    int doubleFactorial = 1, facCount = 1;\n"
"    real tmp = alphaRVec[1];\n"
"    bVec[1] = -erfAlphaR;\n"
"    for (int i = 2; i < 5; ++i) {\n"
"        bVec[i] = bVec[i-1] + tmp * X / (real)(doubleFactorial);\n"
"        facCount = facCount + 2;\n"
"        doubleFactorial = doubleFactorial * facCount;\n"
"        tmp *= 2*alphaRVec[2];\n"
"    }\n"
"\n"
"    real dmp = atom1->damp*atom2->damp;\n"
"    real a = min(atom1->thole, atom2->thole);\n"
"    real u = r/dmp;\n"
"    real au3 = fabs(dmp) > 1.0e-5f ? a*u*u*u : 0;\n"
"    real expau3 = fabs(dmp) > 1.0e-5f ? EXP(-au3) : 0;\n"
"    real a2u6 = au3*au3;\n"
"    real a3u9 = a2u6*au3;\n"
"    // Thole damping factors for energies\n"
"    real thole_c  = 1 - expau3;\n"
"    real thole_d0 = 1 - expau3*(1 + 1.5f*au3);\n"
"    real thole_d1 = 1 - expau3;\n"
"    real thole_q0 = 1 - expau3*(1 + au3 + a2u6);\n"
"    real thole_q1 = 1 - expau3*(1 + au3);\n"
"    // Thole damping factors for derivatives\n"
"    real dthole_c  = 1 - expau3*(1 + 1.5f*au3);\n"
"    real dthole_d0 = 1 - expau3*(1 + au3 + 1.5f*a2u6);\n"
"    real dthole_d1 = 1 - expau3*(1 + au3);\n"
"    real dthole_q0 = 1 - expau3*(1 + au3 + 0.25f*a2u6 + 0.75f*a3u9);\n"
"    real dthole_q1 = 1 - expau3*(1 + au3 + 0.75f*a2u6);\n"
"\n"
"    // Now we compute the (attenuated) Coulomb operator and its derivatives, contracted with\n"
"    // permanent moments and induced dipoles.  Note that the coefficient of the permanent force\n"
"    // terms is half of the expected value; this is because we compute the interaction of I with\n"
"    // the sum of induced and permanent moments on J, as well as the interaction of J with I's\n"
"    // permanent and induced moments; doing so double counts the permanent-permanent interaction.\n"
"    real ePermCoef, dPermCoef, eUIndCoef, dUIndCoef, eUInpCoef, dUInpCoef;\n"
"\n"
"    // C-C terms (m=0)\n"
"    ePermCoef = rInvVec[1]*(mScale + bVec[2] - alphaRVec[1]*X);\n"
"    dPermCoef = -0.5f*(mScale + bVec[2])*rInvVec[2];\n"
"    Vij[0]  = ePermCoef*atom2->q;\n"
"    Vji[0]  = ePermCoef*atom1->q;\n"
"    VijR[0] = dPermCoef*atom2->q;\n"
"    VjiR[0] = dPermCoef*atom1->q;\n"
"\n"
"    // C-D and C-Uind terms (m=0)\n"
"    ePermCoef = rInvVec[2]*(mScale + bVec[2]);\n"
"    eUIndCoef = rInvVec[2]*(pScale*thole_c + bVec[2]);\n"
"    eUInpCoef = rInvVec[2]*(dScale*thole_c + bVec[2]);\n"
"    dPermCoef = -rInvVec[3]*(mScale + bVec[2] + alphaRVec[3]*X);\n"
"    dUIndCoef = -2*rInvVec[3]*(pScale*dthole_c + bVec[2] + alphaRVec[3]*X);\n"
"    dUInpCoef = -2*rInvVec[3]*(dScale*dthole_c + bVec[2] + alphaRVec[3]*X);\n"
"    Vij[0]  += -(ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x);\n"
"    Vji[1]   = -(ePermCoef*atom1->q);\n"
"    VijR[0] += -(dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x);\n"
"    VjiR[1]  = -(dPermCoef*atom1->q);\n"
"    Vjip[0]  = -(eUInpCoef*atom1->q);\n"
"    Vjid[0]  = -(eUIndCoef*atom1->q);\n"
"    // D-C and Uind-C terms (m=0)\n"
"    Vij[1]   = ePermCoef*atom2->q;\n"
"    Vji[0]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1]  = dPermCoef*atom2->q;\n"
"    VjiR[0] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0]  = eUInpCoef*atom2->q;\n"
"    Vijd[0]  = eUIndCoef*atom2->q;\n"
"\n"
"    // D-D and D-Uind terms (m=0)\n"
"    const real twoThirds = (real) 2/3;\n"
"    ePermCoef = -twoThirds*rInvVec[3]*(3*(mScale + bVec[3]) + alphaRVec[3]*X);\n"
"    eUIndCoef = -twoThirds*rInvVec[3]*(3*(pScale*thole_d0 + bVec[3]) + alphaRVec[3]*X);\n"
"    eUInpCoef = -twoThirds*rInvVec[3]*(3*(dScale*thole_d0 + bVec[3]) + alphaRVec[3]*X);\n"
"    dPermCoef = rInvVec[4]*(3*(mScale + bVec[3]) + 2*alphaRVec[5]*X);\n"
"    dUIndCoef = rInvVec[4]*(6*(pScale*dthole_d0 + bVec[3]) + 4*alphaRVec[5]*X);\n"
"    dUInpCoef = rInvVec[4]*(6*(dScale*dthole_d0 + bVec[3]) + 4*alphaRVec[5]*X);\n"
"    Vij[1]  += ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x;\n"
"    Vji[1]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1] += dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x;\n"
"    VjiR[1] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0] += eUInpCoef*rotatedDipole2.x;\n"
"    Vijd[0] += eUIndCoef*rotatedDipole2.x;\n"
"    Vjip[0] += eUInpCoef*rotatedDipole1.x;\n"
"    Vjid[0] += eUIndCoef*rotatedDipole1.x;\n"
"    // D-D and D-Uind terms (m=1)\n"
"    ePermCoef = rInvVec[3]*(mScale + bVec[3] - twoThirds*alphaRVec[3]*X);\n"
"    eUIndCoef = rInvVec[3]*(pScale*thole_d1 + bVec[3] - twoThirds*alphaRVec[3]*X);\n"
"    eUInpCoef = rInvVec[3]*(dScale*thole_d1 + bVec[3] - twoThirds*alphaRVec[3]*X);\n"
"    dPermCoef = -1.5f*rInvVec[4]*(mScale + bVec[3]);\n"
"    dUIndCoef = -3*rInvVec[4]*(pScale*dthole_d1 + bVec[3]);\n"
"    dUInpCoef = -3*rInvVec[4]*(dScale*dthole_d1 + bVec[3]);\n"
"    Vij[2]  = ePermCoef*rotatedDipole2.y + eUIndCoef*qiUindJ.y + eUInpCoef*qiUinpJ.y;\n"
"    Vji[2]  = ePermCoef*rotatedDipole1.y + eUIndCoef*qiUindI.y + eUInpCoef*qiUinpI.y;\n"
"    VijR[2] = dPermCoef*rotatedDipole2.y + dUIndCoef*qiUindJ.y + dUInpCoef*qiUinpJ.y;\n"
"    VjiR[2] = dPermCoef*rotatedDipole1.y + dUIndCoef*qiUindI.y + dUInpCoef*qiUinpI.y;\n"
"    Vij[3]  = ePermCoef*rotatedDipole2.z + eUIndCoef*qiUindJ.z + eUInpCoef*qiUinpJ.z;\n"
"    Vji[3]  = ePermCoef*rotatedDipole1.z + eUIndCoef*qiUindI.z + eUInpCoef*qiUinpI.z;\n"
"    VijR[3] = dPermCoef*rotatedDipole2.z + dUIndCoef*qiUindJ.z + dUInpCoef*qiUinpJ.z;\n"
"    VjiR[3] = dPermCoef*rotatedDipole1.z + dUIndCoef*qiUindI.z + dUInpCoef*qiUinpI.z;\n"
"    Vijp[1] = eUInpCoef*rotatedDipole2.y;\n"
"    Vijd[1] = eUIndCoef*rotatedDipole2.y;\n"
"    Vjip[1] = eUInpCoef*rotatedDipole1.y;\n"
"    Vjid[1] = eUIndCoef*rotatedDipole1.y;\n"
"    Vijp[2] = eUInpCoef*rotatedDipole2.z;\n"
"    Vijd[2] = eUIndCoef*rotatedDipole2.z;\n"
"    Vjip[2] = eUInpCoef*rotatedDipole1.z;\n"
"    Vjid[2] = eUIndCoef*rotatedDipole1.z;\n"
"\n"
"    // C-Q terms (m=0)\n"
"    ePermCoef = (mScale + bVec[3])*rInvVec[3];\n"
"    dPermCoef = -((real) 1/3)*rInvVec[4]*(4.5f*(mScale + bVec[3]) + 2*alphaRVec[5]*X);\n"
"    Vij[0]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]   = ePermCoef*atom1->q;\n"
"    VijR[0] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4]  = dPermCoef*atom1->q;\n"
"    // Q-C terms (m=0)\n"
"    Vij[4]   = ePermCoef*atom2->q;\n"
"    Vji[0]  += ePermCoef*rotatedQuadrupole1[0];\n"
"    VijR[4]  = dPermCoef*atom2->q;\n"
"    VjiR[0] += dPermCoef*rotatedQuadrupole1[0];\n"
"\n"
"    // D-Q and Uind-Q terms (m=0)\n"
"    const real fourThirds = (real) 4/3;\n"
"    ePermCoef = rInvVec[4]*(3*(mScale + bVec[3]) + fourThirds*alphaRVec[5]*X);\n"
"    eUIndCoef = rInvVec[4]*(3*(pScale*thole_q0 + bVec[3]) + fourThirds*alphaRVec[5]*X);\n"
"    eUInpCoef = rInvVec[4]*(3*(dScale*thole_q0 + bVec[3]) + fourThirds*alphaRVec[5]*X);\n"
"    dPermCoef = -fourThirds*rInvVec[5]*(4.5f*(mScale + bVec[3]) + (1 + alphaRVec[2])*alphaRVec[5]*X);\n"
"    dUIndCoef = -fourThirds*rInvVec[5]*(9*(pScale*dthole_q0 + bVec[3]) + 2*(1 + alphaRVec[2])*alphaRVec[5]*X);\n"
"    dUInpCoef = -fourThirds*rInvVec[5]*(9*(dScale*dthole_q0 + bVec[3]) + 2*(1 + alphaRVec[2])*alphaRVec[5]*X);\n"
"    Vij[1]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]  += ePermCoef*rotatedDipole1.x + eUIndCoef*qiUindI.x + eUInpCoef*qiUinpI.x;\n"
"    VijR[1] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4] += dPermCoef*rotatedDipole1.x + dUIndCoef*qiUindI.x + dUInpCoef*qiUinpI.x;\n"
"    Vijp[0] += eUInpCoef*rotatedQuadrupole2[0];\n"
"    Vijd[0] += eUIndCoef*rotatedQuadrupole2[0];\n"
"    // Q-D and Q-Uind terms (m=0)\n"
"    Vij[4]  += -(ePermCoef*rotatedDipole2.x + eUIndCoef*qiUindJ.x + eUInpCoef*qiUinpJ.x);\n"
"    Vji[1]  += -(ePermCoef*rotatedQuadrupole1[0]);\n"
"    VijR[4] += -(dPermCoef*rotatedDipole2.x + dUIndCoef*qiUindJ.x + dUInpCoef*qiUinpJ.x);\n"
"    VjiR[1] += -(dPermCoef*rotatedQuadrupole1[0]);\n"
"    Vjip[0] += -(eUInpCoef*rotatedQuadrupole1[0]);\n"
"    Vjid[0] += -(eUIndCoef*rotatedQuadrupole1[0]);\n"
"\n"
"    // D-Q and Uind-Q terms (m=1)\n"
"    const real sqrtThree = SQRT((real) 3);\n"
"    ePermCoef = -sqrtThree*rInvVec[4]*(mScale + bVec[3]);\n"
"    eUIndCoef = -sqrtThree*rInvVec[4]*(pScale*thole_q1 + bVec[3]);\n"
"    eUInpCoef = -sqrtThree*rInvVec[4]*(dScale*thole_q1 + bVec[3]);\n"
"    const real fourSqrtOneThird = 4/sqrt((real) 3);\n"
"    dPermCoef = fourSqrtOneThird*rInvVec[5]*(1.5f*(mScale + bVec[3]) + 0.5f*alphaRVec[5]*X);\n"
"    dUIndCoef = fourSqrtOneThird*rInvVec[5]*(3*(pScale*dthole_q1 + bVec[3]) + alphaRVec[5]*X);\n"
"    dUInpCoef = fourSqrtOneThird*rInvVec[5]*(3*(dScale*dthole_q1 + bVec[3]) + alphaRVec[5]*X);\n"
"    Vij[2]  += ePermCoef*rotatedQuadrupole2[1];\n"
"    Vji[5]   = ePermCoef*rotatedDipole1.y + eUIndCoef*qiUindI.y + eUInpCoef*qiUinpI.y;\n"
"    VijR[2] += dPermCoef*rotatedQuadrupole2[1];\n"
"    VjiR[5]  = dPermCoef*rotatedDipole1.y + dUIndCoef*qiUindI.y + dUInpCoef*qiUinpI.y;\n"
"    Vij[3]  += ePermCoef*rotatedQuadrupole2[2];\n"
"    Vji[6]   = ePermCoef*rotatedDipole1.z + eUIndCoef*qiUindI.z + eUInpCoef*qiUinpI.z;\n"
"    VijR[3] += dPermCoef*rotatedQuadrupole2[2];\n"
"    VjiR[6]  = dPermCoef*rotatedDipole1.z + dUIndCoef*qiUindI.z + dUInpCoef*qiUinpI.z;\n"
"    Vijp[1] += eUInpCoef*rotatedQuadrupole2[1];\n"
"    Vijd[1] += eUIndCoef*rotatedQuadrupole2[1];\n"
"    Vijp[2] += eUInpCoef*rotatedQuadrupole2[2];\n"
"    Vijd[2] += eUIndCoef*rotatedQuadrupole2[2];\n"
"    // D-Q and Uind-Q terms (m=1)\n"
"    Vij[5]   = -(ePermCoef*rotatedDipole2.y + eUIndCoef*qiUindJ.y + eUInpCoef*qiUinpJ.y);\n"
"    Vji[2]  += -(ePermCoef*rotatedQuadrupole1[1]);\n"
"    VijR[5]  = -(dPermCoef*rotatedDipole2.y + dUIndCoef*qiUindJ.y + dUInpCoef*qiUinpJ.y);\n"
"    VjiR[2] += -(dPermCoef*rotatedQuadrupole1[1]);\n"
"    Vij[6]   = -(ePermCoef*rotatedDipole2.z + eUIndCoef*qiUindJ.z + eUInpCoef*qiUinpJ.z);\n"
"    Vji[3]  += -(ePermCoef*rotatedQuadrupole1[2]);\n"
"    VijR[6]  = -(dPermCoef*rotatedDipole2.z + dUIndCoef*qiUindJ.z + dUInpCoef*qiUinpJ.z);\n"
"    VjiR[3] += -(dPermCoef*rotatedQuadrupole1[2]);\n"
"    Vjip[1] += -(eUInpCoef*rotatedQuadrupole1[1]);\n"
"    Vjid[1] += -(eUIndCoef*rotatedQuadrupole1[1]);\n"
"    Vjip[2] += -(eUInpCoef*rotatedQuadrupole1[2]);\n"
"    Vjid[2] += -(eUIndCoef*rotatedQuadrupole1[2]);\n"
"\n"
"    // Q-Q terms (m=0)\n"
"    ePermCoef = rInvVec[5]*(6*(mScale + bVec[4]) + ((real) 4/45)*(-3 + 10*alphaRVec[2])*alphaRVec[5]*X);\n"
"    dPermCoef = -rInvVec[6]*(135*(mScale + bVec[4]) + 4*(1 + 2*alphaRVec[2])*alphaRVec[7]*X)/9;\n"
"    Vij[4]  += ePermCoef*rotatedQuadrupole2[0];\n"
"    Vji[4]  += ePermCoef*rotatedQuadrupole1[0];\n"
"    VijR[4] += dPermCoef*rotatedQuadrupole2[0];\n"
"    VjiR[4] += dPermCoef*rotatedQuadrupole1[0];\n"
"    // Q-Q terms (m=1)\n"
"    const real fourOverFifteen = (real) 4/15;\n"
"    ePermCoef = -fourOverFifteen*rInvVec[5]*(15*(mScale + bVec[4]) + alphaRVec[5]*X);\n"
"    dPermCoef = rInvVec[6]*(10*(mScale + bVec[4]) + fourThirds*alphaRVec[7]*X);\n"
"    Vij[5]  += ePermCoef*rotatedQuadrupole2[1];\n"
"    Vji[5]  += ePermCoef*rotatedQuadrupole1[1];\n"
"    VijR[5] += dPermCoef*rotatedQuadrupole2[1];\n"
"    VjiR[5] += dPermCoef*rotatedQuadrupole1[1];\n"
"    Vij[6]  += ePermCoef*rotatedQuadrupole2[2];\n"
"    Vji[6]  += ePermCoef*rotatedQuadrupole1[2];\n"
"    VijR[6] += dPermCoef*rotatedQuadrupole2[2];\n"
"    VjiR[6] += dPermCoef*rotatedQuadrupole1[2];\n"
"    // Q-Q terms (m=2)\n"
"    ePermCoef = rInvVec[5]*(mScale + bVec[4] - fourOverFifteen*alphaRVec[5]*X);\n"
"    dPermCoef = -2.5f*(mScale + bVec[4])*rInvVec[6];\n"
"    Vij[7]  = ePermCoef*rotatedQuadrupole2[3];\n"
"    Vji[7]  = ePermCoef*rotatedQuadrupole1[3];\n"
"    VijR[7] = dPermCoef*rotatedQuadrupole2[3];\n"
"    VjiR[7] = dPermCoef*rotatedQuadrupole1[3];\n"
"    Vij[8]  = ePermCoef*rotatedQuadrupole2[4];\n"
"    Vji[8]  = ePermCoef*rotatedQuadrupole1[4];\n"
"    VijR[8] = dPermCoef*rotatedQuadrupole2[4];\n"
"    VjiR[8] = dPermCoef*rotatedQuadrupole1[4];\n"
"\n"
"    // Evaluate the energies, forces and torques due to permanent+induced moments\n"
"    // interacting with just the permanent moments.\n"
"    *energy += forceFactor*0.5f*(\n"
"        atom1->q*Vij[0] + rotatedDipole1.x*Vij[1] + rotatedDipole1.y*Vij[2] + rotatedDipole1.z*Vij[3] + rotatedQuadrupole1[0]*Vij[4] + rotatedQuadrupole1[1]*Vij[5] + rotatedQuadrupole1[2]*Vij[6] + rotatedQuadrupole1[3]*Vij[7] + rotatedQuadrupole1[4]*Vij[8] +\n"
"        atom2->q*Vji[0] + rotatedDipole2.x*Vji[1] + rotatedDipole2.y*Vji[2] + rotatedDipole2.z*Vji[3] + rotatedQuadrupole2[0]*Vji[4] + rotatedQuadrupole2[1]*Vji[5] + rotatedQuadrupole2[2]*Vji[6] + rotatedQuadrupole2[3]*Vji[7] + rotatedQuadrupole2[4]*Vji[8]);\n"
"    real fIZ = atom1->q*VijR[0] + rotatedDipole1.x*VijR[1] + rotatedDipole1.y*VijR[2] + rotatedDipole1.z*VijR[3] + rotatedQuadrupole1[0]*VijR[4] + rotatedQuadrupole1[1]*VijR[5] + rotatedQuadrupole1[2]*VijR[6] + rotatedQuadrupole1[3]*VijR[7] + rotatedQuadrupole1[4]*VijR[8];\n"
"    real fJZ = atom2->q*VjiR[0] + rotatedDipole2.x*VjiR[1] + rotatedDipole2.y*VjiR[2] + rotatedDipole2.z*VjiR[3] + rotatedQuadrupole2[0]*VjiR[4] + rotatedQuadrupole2[1]*VjiR[5] + rotatedQuadrupole2[2]*VjiR[6] + rotatedQuadrupole2[3]*VjiR[7] + rotatedQuadrupole2[4]*VjiR[8];\n"
"    real EIX = rotatedDipole1.z*Vij[1] - rotatedDipole1.x*Vij[3] + sqrtThree*rotatedQuadrupole1[2]*Vij[4] + rotatedQuadrupole1[4]*Vij[5] - (sqrtThree*rotatedQuadrupole1[0]+rotatedQuadrupole1[3])*Vij[6] + rotatedQuadrupole1[2]*Vij[7] - rotatedQuadrupole1[1]*Vij[8];\n"
"    real EIY = -rotatedDipole1.y*Vij[1] + rotatedDipole1.x*Vij[2] - sqrtThree*rotatedQuadrupole1[1]*Vij[4] + (sqrtThree*rotatedQuadrupole1[0]-rotatedQuadrupole1[3])*Vij[5] - rotatedQuadrupole1[4]*Vij[6] + rotatedQuadrupole1[1]*Vij[7] + rotatedQuadrupole1[2]*Vij[8];\n"
"    real EIZ = -rotatedDipole1.z*Vij[2] + rotatedDipole1.y*Vij[3] - rotatedQuadrupole1[2]*Vij[5] + rotatedQuadrupole1[1]*Vij[6] - 2*rotatedQuadrupole1[4]*Vij[7] + 2*rotatedQuadrupole1[3]*Vij[8];\n"
"    real EJX = rotatedDipole2.z*Vji[1] - rotatedDipole2.x*Vji[3] + sqrtThree*rotatedQuadrupole2[2]*Vji[4] + rotatedQuadrupole2[4]*Vji[5] - (sqrtThree*rotatedQuadrupole2[0]+rotatedQuadrupole2[3])*Vji[6] + rotatedQuadrupole2[2]*Vji[7] - rotatedQuadrupole2[1]*Vji[8];\n"
"    real EJY = -rotatedDipole2.y*Vji[1] + rotatedDipole2.x*Vji[2] - sqrtThree*rotatedQuadrupole2[1]*Vji[4] + (sqrtThree*rotatedQuadrupole2[0]-rotatedQuadrupole2[3])*Vji[5] - rotatedQuadrupole2[4]*Vji[6] + rotatedQuadrupole2[1]*Vji[7] + rotatedQuadrupole2[2]*Vji[8];\n"
"    real EJZ = -rotatedDipole2.z*Vji[2] + rotatedDipole2.y*Vji[3] - rotatedQuadrupole2[2]*Vji[5] + rotatedQuadrupole2[1]*Vji[6] - 2*rotatedQuadrupole2[4]*Vji[7] + 2*rotatedQuadrupole2[3]*Vji[8];\n"
"\n"
"    // Define the torque intermediates for the induced dipoles. These are simply the induced dipole torque\n"
"    // intermediates dotted with the field due to permanent moments only, at each center. We inline the\n"
"    // induced dipole torque intermediates here, for simplicity. N.B. There are no torques on the dipoles\n"
"    // themselves, so we accumulate the torque intermediates into separate variables to allow them to be\n"
"    // used only in the force calculation.\n"
"    //\n"
"    // The torque about the x axis (needed to obtain the y force on the induced dipoles, below)\n"
"    //    qiUindIx[0] = qiQUindI[2];    qiUindIx[1] = 0;    qiUindIx[2] = -qiQUindI[0]\n"
"    real iEIX = qiUinpI.z*Vijp[0] + qiUindI.z*Vijd[0] - qiUinpI.x*Vijp[2] - qiUindI.x*Vijd[2];\n"
"    real iEJX = qiUinpJ.z*Vjip[0] + qiUindJ.z*Vjid[0] - qiUinpJ.x*Vjip[2] - qiUindJ.x*Vjid[2];\n"
"    // The torque about the y axis (needed to obtain the x force on the induced dipoles, below)\n"
"    //    qiUindIy[0] = -qiQUindI[1];   qiUindIy[1] = qiQUindI[0];    qiUindIy[2] = 0\n"
"    real iEIY = qiUinpI.x*Vijp[1] + qiUindI.x*Vijd[1] - qiUinpI.y*Vijp[0] - qiUindI.y*Vijd[0];\n"
"    real iEJY = qiUinpJ.x*Vjip[1] + qiUindJ.x*Vjid[1] - qiUinpJ.y*Vjip[0] - qiUindJ.y*Vjid[0];\n"
"\n"
"#ifdef MUTUAL_POLARIZATION\n"
"    // Uind-Uind terms (m=0)\n"
"    real eCoef = -fourThirds*rInvVec[3]*(3*(thole_d0 + bVec[3]) + alphaRVec[3]*X);\n"
"    real dCoef = rInvVec[4]*(6*(dthole_d0 + bVec[3]) + 4*alphaRVec[5]*X);\n"
"    iEIX += eCoef*(qiUinpI.z*qiUindJ.x + qiUindI.z*qiUinpJ.x);\n"
"    iEJX += eCoef*(qiUinpJ.z*qiUindI.x + qiUindJ.z*qiUinpI.x);\n"
"    iEIY -= eCoef*(qiUinpI.y*qiUindJ.x + qiUindI.y*qiUinpJ.x);\n"
"    iEJY -= eCoef*(qiUinpJ.y*qiUindI.x + qiUindJ.y*qiUinpI.x);\n"
"    fIZ += dCoef*(qiUinpI.x*qiUindJ.x + qiUindI.x*qiUinpJ.x);\n"
"    fIZ += dCoef*(qiUinpJ.x*qiUindI.x + qiUindJ.x*qiUinpI.x);\n"
"    // Uind-Uind terms (m=1)\n"
"    eCoef = 2*rInvVec[3]*(thole_d1 + bVec[3] - twoThirds*alphaRVec[3]*X);\n"
"    dCoef = -3*rInvVec[4]*(dthole_d1 + bVec[3]);\n"
"    iEIX -= eCoef*(qiUinpI.x*qiUindJ.z + qiUindI.x*qiUinpJ.z);\n"
"    iEJX -= eCoef*(qiUinpJ.x*qiUindI.z + qiUindJ.x*qiUinpI.z);\n"
"    iEIY += eCoef*(qiUinpI.x*qiUindJ.y + qiUindI.x*qiUinpJ.y);\n"
"    iEJY += eCoef*(qiUinpJ.x*qiUindI.y + qiUindJ.x*qiUinpI.y);\n"
"    fIZ += dCoef*(qiUinpI.y*qiUindJ.y + qiUindI.y*qiUinpJ.y + qiUinpI.z*qiUindJ.z + qiUindI.z*qiUinpJ.z);\n"
"    fIZ += dCoef*(qiUinpJ.y*qiUindI.y + qiUindJ.y*qiUinpI.y + qiUinpJ.z*qiUindI.z + qiUindJ.z*qiUinpI.z);\n"
"#endif\n"
"\n"
"    // The quasi-internal frame forces and torques.  Note that the induced torque intermediates are\n"
"    // used in the force expression, but not in the torques; the induced dipoles are isotropic.\n"
"    real qiForce[3] = {rInv*(EIY+EJY+iEIY+iEJY), -rInv*(EIX+EJX+iEIX+iEJX), -(fJZ+fIZ)};\n"
"    real qiTorqueI[3] = {-EIX, -EIY, -EIZ};\n"
"    real qiTorqueJ[3] = {-EJX, -EJY, -EJZ};\n"
"\n"
"\n"
"    real3 force = make_real3(qiRotationMatrix[1][1]*qiForce[0] + qiRotationMatrix[2][1]*qiForce[1] + qiRotationMatrix[0][1]*qiForce[2],\n"
"                             qiRotationMatrix[1][2]*qiForce[0] + qiRotationMatrix[2][2]*qiForce[1] + qiRotationMatrix[0][2]*qiForce[2],\n"
"                             qiRotationMatrix[1][0]*qiForce[0] + qiRotationMatrix[2][0]*qiForce[1] + qiRotationMatrix[0][0]*qiForce[2]);\n"
"    atom1->force += force;\n"
"    atom1->torque += make_real3(qiRotationMatrix[1][1]*qiTorqueI[0] + qiRotationMatrix[2][1]*qiTorqueI[1] + qiRotationMatrix[0][1]*qiTorqueI[2],\n"
"                               qiRotationMatrix[1][2]*qiTorqueI[0] + qiRotationMatrix[2][2]*qiTorqueI[1] + qiRotationMatrix[0][2]*qiTorqueI[2],\n"
"                               qiRotationMatrix[1][0]*qiTorqueI[0] + qiRotationMatrix[2][0]*qiTorqueI[1] + qiRotationMatrix[0][0]*qiTorqueI[2]);\n"
"    if (forceFactor == 1) {\n"
"        atom2->force -= force;\n"
"        atom2->torque += make_real3(qiRotationMatrix[1][1]*qiTorqueJ[0] + qiRotationMatrix[2][1]*qiTorqueJ[1] + qiRotationMatrix[0][1]*qiTorqueJ[2],\n"
"                                   qiRotationMatrix[1][2]*qiTorqueJ[0] + qiRotationMatrix[2][2]*qiTorqueJ[1] + qiRotationMatrix[0][2]*qiTorqueJ[2],\n"
"                                   qiRotationMatrix[1][0]*qiTorqueJ[0] + qiRotationMatrix[2][0]*qiTorqueJ[1] + qiRotationMatrix[0][0]*qiTorqueJ[2]);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the self energy and self torque.\n"
" */\n"
"DEVICE void computeSelfEnergyAndTorque(AtomData* atom1, mixed* energy) {\n"
"    real cii = atom1->q*atom1->q;\n"
"    real3 dipole = make_real3(atom1->sphericalDipole.y, atom1->sphericalDipole.z, atom1->sphericalDipole.x);\n"
"    real dii = dot(dipole, dipole+(atom1->inducedDipole+atom1->inducedDipolePolar)*0.5f);\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"    real qii = (atom1->sphericalQuadrupole[0]*atom1->sphericalQuadrupole[0] +\n"
"                atom1->sphericalQuadrupole[1]*atom1->sphericalQuadrupole[1] +\n"
"                atom1->sphericalQuadrupole[2]*atom1->sphericalQuadrupole[2] +\n"
"                atom1->sphericalQuadrupole[3]*atom1->sphericalQuadrupole[3] +\n"
"                atom1->sphericalQuadrupole[4]*atom1->sphericalQuadrupole[4]);\n"
"#else\n"
"    real qii = 0;\n"
"#endif\n"
"    real prefac = -EWALD_ALPHA/SQRT_PI;\n"
"    real a2 = EWALD_ALPHA*EWALD_ALPHA;\n"
"    real a4 = a2*a2;\n"
"    *energy += prefac*(cii + ((real)2/3)*a2*dii + ((real) 4/15)*a4*qii);\n"
"\n"
"    // self-torque for PME\n"
"\n"
"    real3 ui = atom1->inducedDipole+atom1->inducedDipolePolar;\n"
"    atom1->torque += ((2/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI)*cross(dipole, ui);\n"
"}\n"
"\n"
"/**\n"
" * Compute electrostatic interactions.\n"
" */\n"
"KERNEL void computeElectrostatics(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT torqueBuffers, GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const uint2* RESTRICT covalentFlags, GLOBAL const unsigned int* RESTRICT polarizationGroupFlags,\n"
"        GLOBAL const int2* RESTRICT exclusionTiles, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const unsigned int* RESTRICT interactingAtoms,\n"
"#endif\n"
"        GLOBAL const real* RESTRICT sphericalDipole, GLOBAL const real* RESTRICT sphericalQuadrupole, GLOBAL const real* RESTRICT inducedDipole,\n"
"        GLOBAL const real* RESTRICT inducedDipolePolar, GLOBAL const float2* RESTRICT dampingAndThole) {\n"
"    const unsigned int totalWarps = (GLOBAL_SIZE)/TILE_SIZE;\n"
"    const unsigned int warp = (GLOBAL_ID)/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        AtomData data = loadAtomData(atom1, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"        data.force = make_real3(0);\n"
"        data.torque = make_real3(0);\n"
"        uint2 covalent = covalentFlags[pos*TILE_SIZE+tgx];\n"
"        unsigned int polarizationGroup = polarizationGroupFlags[pos*TILE_SIZE+tgx];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].pos = data.pos;\n"
"            localData[LOCAL_ID].q = data.q;\n"
"            localData[LOCAL_ID].sphericalDipole = data.sphericalDipole;\n"
"#ifdef INCLUDE_QUADRUPOLES\n"
"            localData[LOCAL_ID].sphericalQuadrupole[0] = data.sphericalQuadrupole[0];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[1] = data.sphericalQuadrupole[1];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[2] = data.sphericalQuadrupole[2];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[3] = data.sphericalQuadrupole[3];\n"
"            localData[LOCAL_ID].sphericalQuadrupole[4] = data.sphericalQuadrupole[4];\n"
"#endif\n"
"            localData[LOCAL_ID].inducedDipole = data.inducedDipole;\n"
"            localData[LOCAL_ID].inducedDipolePolar = data.inducedDipolePolar;\n"
"            localData[LOCAL_ID].thole = data.thole;\n"
"            localData[LOCAL_ID].damp = data.damp;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    float d = computeDScaleFactor(polarizationGroup, j);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, j);\n"
"                    float m = computeMScaleFactor(covalent, j);\n"
"                    computeOneInteraction(&data, &localData[tbx+j], true, d, p, m, 0.5f, &energy, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"                }\n"
"            }\n"
"            if (atom1 < NUM_ATOMS)\n"
"                computeSelfEnergyAndTorque(&data, &energy);\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            localData[LOCAL_ID].torque = make_real3(0);\n"
"            unsigned int tj = tgx;\n"
"            SYNC_WARPS;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = y*TILE_SIZE+tj;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    float d = computeDScaleFactor(polarizationGroup, tj);\n"
"                    float p = computePScaleFactor(covalent, polarizationGroup, tj);\n"
"                    float m = computeMScaleFactor(covalent, tj);\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], true, d, p, m, 1, &energy, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"            SYNC_WARPS;\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= -ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].torque *= ENERGY_SCALE_FACTOR;\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.z*0x100000000)));\n"
"            SYNC_WARPS;\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(mm_long)numTileIndices/totalWarps : warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(mm_long)numTileIndices/totalWarps : (warp+1)*(mm_long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[THREAD_BLOCK_SIZE];\n"
"    LOCAL volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"    \n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            AtomData data = loadAtomData(atom1, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            data.force = make_real3(0);\n"
"            data.torque = make_real3(0);\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            localData[LOCAL_ID] = loadAtomData(j, posq, sphericalDipole, sphericalQuadrupole, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"            localData[LOCAL_ID].force = make_real3(0);\n"
"            localData[LOCAL_ID].torque = make_real3(0);\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute forces.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = atomIndices[tbx+tj];\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    computeOneInteraction(&data, &localData[tbx+tj], false, 1, 1, 1, 1, &energy, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"            data.force *= -ENERGY_SCALE_FACTOR;\n"
"            data.torque *= ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].force *= -ENERGY_SCALE_FACTOR;\n"
"            localData[LOCAL_ID].torque *= ENERGY_SCALE_FACTOR;\n"
"\n"
"            // Write results.\n"
"\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (data.force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (data.torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (data.torque.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"            offset = atomIndices[LOCAL_ID];\n"
"#else\n"
"            offset = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].force.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].torque.z*0x100000000)));\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy*ENERGY_SCALE_FACTOR;\n"
"}";
const string CommonAmoebaKernelSources::sphericalMultipoles = "DEVICE void buildQIRotationMatrix(real3 deltaR, real rInv, real rotationMatrix[][3]) {\n"
"    real3 vectorZ = deltaR*rInv;\n"
"    real3 vectorX = vectorZ;\n"
"    if (deltaR.y != 0 || deltaR.z != 0)\n"
"        vectorX.x += 1;\n"
"    else\n"
"        vectorX.y += 1;\n"
"\n"
"    vectorX -= vectorZ*dot(vectorX, vectorZ);\n"
"    vectorX = normalize(vectorX);\n"
"    real3 vectorY = cross(vectorZ, vectorX);\n"
"\n"
"    // Reorder the Cartesian {x,y,z} dipole rotation matrix, to account\n"
"    // for spherical harmonic ordering {z,x,y}.\n"
"    rotationMatrix[0][0] = vectorZ.z;\n"
"    rotationMatrix[0][1] = vectorZ.x;\n"
"    rotationMatrix[0][2] = vectorZ.y;\n"
"    rotationMatrix[1][0] = vectorX.z;\n"
"    rotationMatrix[1][1] = vectorX.x;\n"
"    rotationMatrix[1][2] = vectorX.y;\n"
"    rotationMatrix[2][0] = vectorY.z;\n"
"    rotationMatrix[2][1] = vectorY.x;\n"
"    rotationMatrix[2][2] = vectorY.y;\n"
"}\n"
"\n"
"DEVICE real3 rotateDipole(real3 dipole, const real rotationMatrix[][3]) {\n"
"    return make_real3(rotationMatrix[0][0]*dipole.x + rotationMatrix[0][1]*dipole.y + rotationMatrix[0][2]*dipole.z,\n"
"                      rotationMatrix[1][0]*dipole.x + rotationMatrix[1][1]*dipole.y + rotationMatrix[1][2]*dipole.z,\n"
"                      rotationMatrix[2][0]*dipole.x + rotationMatrix[2][1]*dipole.y + rotationMatrix[2][2]*dipole.z);\n"
"}\n"
"\n"
"DEVICE void rotateQuadrupoles(const real rotationMatrix[][3], const real* quad1, LOCAL_ARG const real* quad2, real* rotated1, real* rotated2) {\n"
"    real sqrtThree = SQRT((real) 3);\n"
"    real element;\n"
"    element = 0.5f*(3.0f*rotationMatrix[0][0]*rotationMatrix[0][0] - 1.0f);\n"
"    rotated1[0] += quad1[0]*element;\n"
"    rotated2[0] += quad2[0]*element;\n"
"    element = sqrtThree*rotationMatrix[0][0]*rotationMatrix[0][1];\n"
"    rotated1[0] += quad1[1]*element;\n"
"    rotated2[0] += quad2[1]*element;\n"
"    element = sqrtThree*rotationMatrix[0][0]*rotationMatrix[0][2];\n"
"    rotated1[0] += quad1[2]*element;\n"
"    rotated2[0] += quad2[2]*element;\n"
"    element = 0.5f*sqrtThree*(rotationMatrix[0][1]*rotationMatrix[0][1] - rotationMatrix[0][2]*rotationMatrix[0][2]);\n"
"    rotated1[0] += quad1[3]*element;\n"
"    rotated2[0] += quad2[3]*element;\n"
"    element = sqrtThree*rotationMatrix[0][1]*rotationMatrix[0][2];\n"
"    rotated1[0] += quad1[4]*element;\n"
"    rotated2[0] += quad2[4]*element;\n"
"    element = sqrtThree*rotationMatrix[0][0]*rotationMatrix[1][0];\n"
"    rotated1[1] += quad1[0]*element;\n"
"    rotated2[1] += quad2[0]*element;\n"
"    element = rotationMatrix[1][0]*rotationMatrix[0][1] + rotationMatrix[0][0]*rotationMatrix[1][1];\n"
"    rotated1[1] += quad1[1]*element;\n"
"    rotated2[1] += quad2[1]*element;\n"
"    element = rotationMatrix[1][0]*rotationMatrix[0][2] + rotationMatrix[0][0]*rotationMatrix[1][2];\n"
"    rotated1[1] += quad1[2]*element;\n"
"    rotated2[1] += quad2[2]*element;\n"
"    element = rotationMatrix[0][1]*rotationMatrix[1][1] - rotationMatrix[0][2]*rotationMatrix[1][2];\n"
"    rotated1[1] += quad1[3]*element;\n"
"    rotated2[1] += quad2[3]*element;\n"
"    element = rotationMatrix[1][1]*rotationMatrix[0][2] + rotationMatrix[0][1]*rotationMatrix[1][2];\n"
"    rotated1[1] += quad1[4]*element;\n"
"    rotated2[1] += quad2[4]*element;\n"
"    element = sqrtThree*rotationMatrix[0][0]*rotationMatrix[2][0];\n"
"    rotated1[2] += quad1[0]*element;\n"
"    rotated2[2] += quad2[0]*element;\n"
"    element = rotationMatrix[2][0]*rotationMatrix[0][1] + rotationMatrix[0][0]*rotationMatrix[2][1];\n"
"    rotated1[2] += quad1[1]*element;\n"
"    rotated2[2] += quad2[1]*element;\n"
"    element = rotationMatrix[2][0]*rotationMatrix[0][2] + rotationMatrix[0][0]*rotationMatrix[2][2];\n"
"    rotated1[2] += quad1[2]*element;\n"
"    rotated2[2] += quad2[2]*element;\n"
"    element = rotationMatrix[0][1]*rotationMatrix[2][1] - rotationMatrix[0][2]*rotationMatrix[2][2];\n"
"    rotated1[2] += quad1[3]*element;\n"
"    rotated2[2] += quad2[3]*element;\n"
"    element = rotationMatrix[2][1]*rotationMatrix[0][2] + rotationMatrix[0][1]*rotationMatrix[2][2];\n"
"    rotated1[2] += quad1[4]*element;\n"
"    rotated2[2] += quad2[4]*element;\n"
"    element = 0.5f*sqrtThree*(rotationMatrix[1][0]*rotationMatrix[1][0] - rotationMatrix[2][0]*rotationMatrix[2][0]);\n"
"    rotated1[3] += quad1[0]*element;\n"
"    rotated2[3] += quad2[0]*element;\n"
"    element = rotationMatrix[1][0]*rotationMatrix[1][1] - rotationMatrix[2][0]*rotationMatrix[2][1];\n"
"    rotated1[3] += quad1[1]*element;\n"
"    rotated2[3] += quad2[1]*element;\n"
"    element = rotationMatrix[1][0]*rotationMatrix[1][2] - rotationMatrix[2][0]*rotationMatrix[2][2];\n"
"    rotated1[3] += quad1[2]*element;\n"
"    rotated2[3] += quad2[2]*element;\n"
"    element = 0.5f*(rotationMatrix[1][1]*rotationMatrix[1][1] - rotationMatrix[2][1]*rotationMatrix[2][1] - rotationMatrix[1][2]*rotationMatrix[1][2] + rotationMatrix[2][2]*rotationMatrix[2][2]);\n"
"    rotated1[3] += quad1[3]*element;\n"
"    rotated2[3] += quad2[3]*element;\n"
"    element = rotationMatrix[1][1]*rotationMatrix[1][2] - rotationMatrix[2][1]*rotationMatrix[2][2];\n"
"    rotated1[3] += quad1[4]*element;\n"
"    rotated2[3] += quad2[4]*element;\n"
"    element = sqrtThree*rotationMatrix[1][0]*rotationMatrix[2][0];\n"
"    rotated1[4] += quad1[0]*element;\n"
"    rotated2[4] += quad2[0]*element;\n"
"    element = rotationMatrix[2][0]*rotationMatrix[1][1] + rotationMatrix[1][0]*rotationMatrix[2][1];\n"
"    rotated1[4] += quad1[1]*element;\n"
"    rotated2[4] += quad2[1]*element;\n"
"    element = rotationMatrix[2][0]*rotationMatrix[1][2] + rotationMatrix[1][0]*rotationMatrix[2][2];\n"
"    rotated1[4] += quad1[2]*element;\n"
"    rotated2[4] += quad2[2]*element;\n"
"    element = rotationMatrix[1][1]*rotationMatrix[2][1] - rotationMatrix[1][2]*rotationMatrix[2][2];\n"
"    rotated1[4] += quad1[3]*element;\n"
"    rotated2[4] += quad2[3]*element;\n"
"    element = rotationMatrix[2][1]*rotationMatrix[1][2] + rotationMatrix[1][1]*rotationMatrix[2][2];\n"
"    rotated1[4] += quad1[4]*element;\n"
"    rotated2[4] += quad2[4]*element;\n"
"}\n"
"";
