/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2012 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CudaAmoebaKernelSources.h"

using namespace OpenMM;
using namespace std;

const string CudaAmoebaKernelSources::multipoleInducedField = "#ifndef HIPPO\n"
"#define WARPS_PER_GROUP (THREAD_BLOCK_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real3 pos;\n"
"    real3 field, fieldPolar, inducedDipole, inducedDipolePolar;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    real fieldGradient[6], fieldGradientPolar[6];\n"
"#endif\n"
"#ifdef USE_GK\n"
"    real3 fieldS, fieldPolarS, inducedDipoleS, inducedDipolePolarS;\n"
"    real bornRadius;\n"
"    #ifdef EXTRAPOLATED_POLARIZATION\n"
"        real fieldGradientS[6], fieldGradientPolarS[6];\n"
"    #endif\n"
"#endif\n"
"    float thole, damp;\n"
"} AtomData;\n"
"\n"
"#ifdef USE_GK\n"
"inline __device__ void loadAtomData(AtomData& data, int atom, const real4* __restrict__ posq, const real3* __restrict__ inducedDipole,\n"
"        const real3* __restrict__ inducedDipolePolar, const float2* __restrict__ dampingAndThole, const real3* __restrict__ inducedDipoleS,\n"
"        const real3* __restrict__ inducedDipolePolarS, const real* __restrict__ bornRadii) {\n"
"#else\n"
"inline __device__ void loadAtomData(AtomData& data, int atom, const real4* __restrict__ posq, const real3* __restrict__ inducedDipole,\n"
"        const real3* __restrict__ inducedDipolePolar, const float2* __restrict__ dampingAndThole) {\n"
"#endif\n"
"    real4 atomPosq = posq[atom];\n"
"    data.pos = make_real3(atomPosq.x, atomPosq.y, atomPosq.z);\n"
"    data.inducedDipole = inducedDipole[atom];\n"
"    data.inducedDipolePolar = inducedDipolePolar[atom];\n"
"    float2 temp = dampingAndThole[atom];\n"
"    data.damp = temp.x;\n"
"    data.thole = temp.y;\n"
"#ifdef USE_GK\n"
"    data.inducedDipoleS = inducedDipoleS[atom];\n"
"    data.inducedDipolePolarS = inducedDipolePolarS[atom];\n"
"    data.bornRadius = bornRadii[atom];\n"
"#endif\n"
"}\n"
"\n"
"inline __device__ void zeroAtomData(AtomData& data) {\n"
"    data.field = make_real3(0);\n"
"    data.fieldPolar = make_real3(0);\n"
"#ifdef USE_GK\n"
"    data.fieldS = make_real3(0);\n"
"    data.fieldPolarS = make_real3(0);\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    for (int i = 0; i < 6; i++) {\n"
"        data.fieldGradient[i] = 0;\n"
"        data.fieldGradientPolar[i] = 0;\n"
"#ifdef USE_GK\n"
"        data.fieldGradientS[i] = 0;\n"
"        data.fieldGradientPolarS[i] = 0;\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    #ifdef USE_GK\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldGradient, fieldGradientPolar, fieldS, fieldPolarS, fieldGradientS, fieldGradientPolarS);\n"
"    #else\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldGradient, fieldGradientPolar);\n"
"    #endif\n"
"#else\n"
"    #ifdef USE_GK\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar, fieldS, fieldPolarS);\n"
"    #else\n"
"        #define SAVE_ATOM_DATA(index, data) saveAtomData(index, data, field, fieldPolar);\n"
"    #endif\n"
"#endif\n"
"\n"
"inline __device__ void saveAtomData(int index, AtomData& data, unsigned long long* __restrict__ field, unsigned long long* __restrict__ fieldPolar\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        , unsigned long long* __restrict__ fieldGradient, unsigned long long* __restrict__ fieldGradientPolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , unsigned long long* __restrict__ fieldS, unsigned long long* __restrict__ fieldPolarS\n"
"    #ifdef EXTRAPOLATED_POLARIZATION\n"
"        , unsigned long long* __restrict__ fieldGradientS, unsigned long long* __restrict__ fieldGradientPolarS\n"
"    #endif\n"
"#endif\n"
"        ) {\n"
"    atomicAdd(&field[index], static_cast<unsigned long long>((long long) (data.field.x*0x100000000)));\n"
"    atomicAdd(&field[index+PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.field.y*0x100000000)));\n"
"    atomicAdd(&field[index+2*PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.field.z*0x100000000)));\n"
"    atomicAdd(&fieldPolar[index], static_cast<unsigned long long>((long long) (data.fieldPolar.x*0x100000000)));\n"
"    atomicAdd(&fieldPolar[index+PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldPolar.y*0x100000000)));\n"
"    atomicAdd(&fieldPolar[index+2*PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldPolar.z*0x100000000)));\n"
"#ifdef USE_GK\n"
"    atomicAdd(&fieldS[index], static_cast<unsigned long long>((long long) (data.fieldS.x*0x100000000)));\n"
"    atomicAdd(&fieldS[index+PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldS.y*0x100000000)));\n"
"    atomicAdd(&fieldS[index+2*PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldS.z*0x100000000)));\n"
"    atomicAdd(&fieldPolarS[index], static_cast<unsigned long long>((long long) (data.fieldPolarS.x*0x100000000)));\n"
"    atomicAdd(&fieldPolarS[index+PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldPolarS.y*0x100000000)));\n"
"    atomicAdd(&fieldPolarS[index+2*PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (data.fieldPolarS.z*0x100000000)));\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    for (int i = 0; i < 6; i++) {\n"
"        atomicAdd(&fieldGradient[6*index+i], static_cast<unsigned long long>((long long) (data.fieldGradient[i]*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*index+i], static_cast<unsigned long long>((long long) (data.fieldGradientPolar[i]*0x100000000)));\n"
"#ifdef USE_GK\n"
"        atomicAdd(&fieldGradientS[6*index+i], static_cast<unsigned long long>((long long) (data.fieldGradientS[i]*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolarS[6*index+i], static_cast<unsigned long long>((long long) (data.fieldGradientPolarS[i]*0x100000000)));\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#ifdef USE_EWALD\n"
"__device__ void computeOneInteraction(AtomData& atom1, AtomData& atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    if (isSelfInteraction)\n"
"        return;\n"
"    real scale1, scale2, scale3;\n"
"    real r2 = dot(deltaR, deltaR);\n"
"    if (r2 < CUTOFF_SQUARED) {\n"
"        real rI = RSQRT(r2);\n"
"        real r = RECIP(rI);\n"
"        real rI2 = rI*rI;\n"
"\n"
"        // calculate the error function damping terms\n"
"\n"
"        real ralpha = EWALD_ALPHA*r;\n"
"        real exp2a = EXP(-(ralpha*ralpha));\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"        const real erfcAlphaR = erfc(ralpha);\n"
"#else\n"
"        // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"        // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"        // error of 1.5e-7.\n"
"\n"
"        const real t = RECIP(1.0f+0.3275911f*ralpha);\n"
"        const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*exp2a;\n"
"#endif\n"
"        real bn0 = erfcAlphaR*rI;\n"
"        real alsq2 = 2*EWALD_ALPHA*EWALD_ALPHA;\n"
"        real alsq2n = RECIP(SQRT_PI*EWALD_ALPHA);\n"
"        alsq2n *= alsq2;\n"
"        real bn1 = (bn0+alsq2n*exp2a)*rI2;\n"
"\n"
"        alsq2n *= alsq2;\n"
"        real bn2 = (3*bn1+alsq2n*exp2a)*rI2;\n"
"\n"
"        alsq2n *= alsq2;\n"
"        real bn3 = (5*bn2+alsq2n*exp2a)*rI2;\n"
"\n"
"        // compute the error function scaled and unscaled terms\n"
"\n"
"        real damp = atom1.damp*atom2.damp;\n"
"        real ratio = (r/damp);\n"
"        ratio = ratio*ratio*ratio;\n"
"        float pgamma = atom1.thole < atom2.thole ? atom1.thole : atom2.thole;\n"
"        damp = damp == 0 ? 0 : -pgamma*ratio;\n"
"        real expdamp = EXP(damp);\n"
"        real dsc3 = 1 - expdamp;\n"
"        real dsc5 = 1 - expdamp*(1-damp);\n"
"        real dsc7 = 1 - (1-damp+(0.6f*damp*damp))*expdamp;\n"
"        real r3 = (r*r2);\n"
"        real r5 = (r3*r2);\n"
"        real r7 = (r5*r2);\n"
"        real rr3 = (1-dsc3)/r3;\n"
"        real rr5 = 3*(1-dsc5)/r5;\n"
"        real rr7 = 15*(1-dsc7)/r7;\n"
"\n"
"        scale1 = rr3 - bn1;\n"
"        scale2 = bn2 - rr5;\n"
"        scale3 = bn3 - rr7;\n"
"    }\n"
"    else {\n"
"        scale1 = 0;\n"
"        scale2 = 0;\n"
"        scale3 = 0;\n"
"    }\n"
"    real dDotDelta = scale2*dot(deltaR, atom2.inducedDipole);\n"
"    atom1.field += scale1*atom2.inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom2.inducedDipolePolar);\n"
"    atom1.fieldPolar += scale1*atom2.inducedDipolePolar + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom1.inducedDipole);\n"
"    atom2.field += scale1*atom1.inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = scale2*dot(deltaR, atom1.inducedDipolePolar);\n"
"    atom2.fieldPolar += scale1*atom1.inducedDipolePolar + dDotDelta*deltaR;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    // Compute and store the field gradients for later use.\n"
"    \n"
"    real3 dipole = atom1.inducedDipole;\n"
"    real muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2.fieldGradient[0] -= (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom2.fieldGradient[1] -= (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom2.fieldGradient[2] -= (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom2.fieldGradient[3] -= (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom2.fieldGradient[4] -= (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom2.fieldGradient[5] -= (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom1.inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2.fieldGradientPolar[0] -= (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom2.fieldGradientPolar[1] -= (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom2.fieldGradientPolar[2] -= (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom2.fieldGradientPolar[3] -= (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom2.fieldGradientPolar[4] -= (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom2.fieldGradientPolar[5] -= (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom2.inducedDipole;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1.fieldGradient[0] += (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom1.fieldGradient[1] += (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom1.fieldGradient[2] += (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom1.fieldGradient[3] += (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom1.fieldGradient[4] += (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom1.fieldGradient[5] += (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"\n"
"    dipole = atom2.inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1.fieldGradientPolar[0] += (muDotR*scale3)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*scale2;\n"
"    atom1.fieldGradientPolar[1] += (muDotR*scale3)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*scale2;\n"
"    atom1.fieldGradientPolar[2] += (muDotR*scale3)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*scale2;\n"
"    atom1.fieldGradientPolar[3] += (muDotR*scale3)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*scale2;\n"
"    atom1.fieldGradientPolar[4] += (muDotR*scale3)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*scale2;\n"
"    atom1.fieldGradientPolar[5] += (muDotR*scale3)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*scale2;\n"
"#endif\n"
"}\n"
"#elif defined USE_GK\n"
"__device__ void computeOneInteraction(AtomData& atom1, AtomData& atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    real r2 = dot(deltaR, deltaR);\n"
"    real r = SQRT(r2);\n"
"    if (!isSelfInteraction) {\n"
"        real rI = RECIP(r);\n"
"        real r2I = rI*rI;\n"
"        real rr3 = -rI*r2I;\n"
"        real rr5 = -3*rr3*r2I;\n"
"\n"
"        real dampProd = atom1.damp*atom2.damp;\n"
"        real ratio = (dampProd != 0 ? r/dampProd : 1);\n"
"        float pGamma = (atom1.thole > atom2.thole ? atom2.thole: atom1.thole);\n"
"        real damp = ratio*ratio*ratio*pGamma;\n"
"        real dampExp = (dampProd != 0 ? EXP(-damp) : 0); \n"
"\n"
"        rr3 *= 1-dampExp;\n"
"        rr5 *= 1-(1+damp)*dampExp;\n"
"\n"
"        real dDotDelta = rr5*dot(deltaR, atom2.inducedDipole);\n"
"        atom1.field += rr3*atom2.inducedDipole + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2.inducedDipolePolar);\n"
"        atom1.fieldPolar += rr3*atom2.inducedDipolePolar + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1.inducedDipole);\n"
"        atom2.field += rr3*atom1.inducedDipole + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1.inducedDipolePolar);\n"
"        atom2.fieldPolar += rr3*atom1.inducedDipolePolar + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2.inducedDipoleS);\n"
"        atom1.fieldS += rr3*atom2.inducedDipoleS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom2.inducedDipolePolarS);\n"
"        atom1.fieldPolarS += rr3*atom2.inducedDipolePolarS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1.inducedDipoleS);\n"
"        atom2.fieldS += rr3*atom1.inducedDipoleS + dDotDelta*deltaR;\n"
"        dDotDelta = rr5*dot(deltaR, atom1.inducedDipolePolarS);\n"
"        atom2.fieldPolarS += rr3*atom1.inducedDipolePolarS + dDotDelta*deltaR;\n"
"    }\n"
"\n"
"    real rb2 = atom1.bornRadius*atom2.bornRadius;\n"
"    real expterm = EXP(-r2/(GK_C*rb2));\n"
"    real expc = expterm/GK_C; \n"
"    real gf2 = RECIP(r2+rb2*expterm);\n"
"    real gf = SQRT(gf2);\n"
"    real gf3 = gf2*gf;\n"
"    real gf5 = gf3*gf2;\n"
"    real a10 = -gf3;\n"
"    real expc1 = 1 - expc;\n"
"    real a11 = expc1 * 3 * gf5;\n"
"    real3 gux = GK_FD*make_real3(a10+deltaR.x*deltaR.x*a11, deltaR.x*deltaR.y*a11, deltaR.x*deltaR.z*a11);\n"
"    real3 guy = make_real3(gux.y, GK_FD*(a10+deltaR.y*deltaR.y*a11), GK_FD*deltaR.y*deltaR.z*a11);\n"
"    real3 guz = make_real3(gux.z, guy.z, GK_FD*(a10+deltaR.z*deltaR.z*a11));\n"
" \n"
"    atom1.fieldS += atom2.inducedDipoleS.x*gux+atom2.inducedDipoleS.y*guy+atom2.inducedDipoleS.z*guz;\n"
"    atom2.fieldS += atom1.inducedDipoleS.x*gux+atom1.inducedDipoleS.y*guy+atom1.inducedDipoleS.z*guz;\n"
"    atom1.fieldPolarS += atom2.inducedDipolePolarS.x*gux+atom2.inducedDipolePolarS.y*guy+atom2.inducedDipolePolarS.z*guz;\n"
"    atom2.fieldPolarS += atom1.inducedDipolePolarS.x*gux+atom1.inducedDipolePolarS.y*guy+atom1.inducedDipolePolarS.z*guz;\n"
"}\n"
"#else\n"
"__device__ void computeOneInteraction(AtomData& atom1, AtomData& atom2, real3 deltaR, bool isSelfInteraction) {\n"
"    if (isSelfInteraction)\n"
"        return;\n"
"    real rI = RSQRT(dot(deltaR, deltaR));\n"
"    real r = RECIP(rI);\n"
"    real r2I = rI*rI;\n"
"    real rr3 = -rI*r2I;\n"
"    real rr5 = -3*rr3*r2I;\n"
"    real rr7 = 5*rr5*r2I;\n"
"    real dampProd = atom1.damp*atom2.damp;\n"
"    real ratio = (dampProd != 0 ? r/dampProd : 1);\n"
"    float pGamma = (atom2.thole > atom1.thole ? atom1.thole: atom2.thole);\n"
"    real damp = ratio*ratio*ratio*pGamma;\n"
"    real dampExp = (dampProd != 0 ? EXP(-damp) : 0); \n"
"    rr3 *= 1 - dampExp;\n"
"    rr5 *= 1 - (1+damp)*dampExp;\n"
"    rr7 *= 1 - (1+damp+(0.6f*damp*damp))*dampExp;\n"
"    real dDotDelta = rr5*dot(deltaR, atom2.inducedDipole);\n"
"    atom1.field += rr3*atom2.inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom2.inducedDipolePolar);\n"
"    atom1.fieldPolar += rr3*atom2.inducedDipolePolar + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom1.inducedDipole);\n"
"    atom2.field += rr3*atom1.inducedDipole + dDotDelta*deltaR;\n"
"    dDotDelta = rr5*dot(deltaR, atom1.inducedDipolePolar);\n"
"    atom2.fieldPolar += rr3*atom1.inducedDipolePolar + dDotDelta*deltaR;\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"    // Compute and store the field gradients for later use.\n"
"    \n"
"    real3 dipole = atom1.inducedDipole;\n"
"    real muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2.fieldGradient[0] -= (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom2.fieldGradient[1] -= (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom2.fieldGradient[2] -= (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom2.fieldGradient[3] -= (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom2.fieldGradient[4] -= (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom2.fieldGradient[5] -= (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom1.inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom2.fieldGradientPolar[0] -= (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom2.fieldGradientPolar[1] -= (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom2.fieldGradientPolar[2] -= (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom2.fieldGradientPolar[3] -= (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom2.fieldGradientPolar[4] -= (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom2.fieldGradientPolar[5] -= (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom2.inducedDipole;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1.fieldGradient[0] += (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom1.fieldGradient[1] += (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom1.fieldGradient[2] += (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom1.fieldGradient[3] += (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom1.fieldGradient[4] += (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom1.fieldGradient[5] += (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"\n"
"    dipole = atom2.inducedDipolePolar;\n"
"    muDotR = dipole.x*deltaR.x + dipole.y*deltaR.y + dipole.z*deltaR.z;\n"
"    atom1.fieldGradientPolar[0] += (muDotR*rr7)*deltaR.x*deltaR.x - (2*dipole.x*deltaR.x + muDotR)*rr5;\n"
"    atom1.fieldGradientPolar[1] += (muDotR*rr7)*deltaR.y*deltaR.y - (2*dipole.y*deltaR.y + muDotR)*rr5;\n"
"    atom1.fieldGradientPolar[2] += (muDotR*rr7)*deltaR.z*deltaR.z - (2*dipole.z*deltaR.z + muDotR)*rr5;\n"
"    atom1.fieldGradientPolar[3] += (muDotR*rr7)*deltaR.x*deltaR.y - (dipole.x*deltaR.y + dipole.y*deltaR.x)*rr5;\n"
"    atom1.fieldGradientPolar[4] += (muDotR*rr7)*deltaR.x*deltaR.z - (dipole.x*deltaR.z + dipole.z*deltaR.x)*rr5;\n"
"    atom1.fieldGradientPolar[5] += (muDotR*rr7)*deltaR.y*deltaR.z - (dipole.y*deltaR.z + dipole.z*deltaR.y)*rr5;\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"/**\n"
" * Compute the mutual induced field.\n"
" */\n"
"extern \"C\" __global__ void computeInducedField(\n"
"        unsigned long long* __restrict__ field, unsigned long long* __restrict__ fieldPolar, const real4* __restrict__ posq, const int2* __restrict__ exclusionTiles, \n"
"        const real3* __restrict__ inducedDipole, const real3* __restrict__ inducedDipolePolar, unsigned int startTileIndex, unsigned int numTileIndices,\n"
"#ifdef USE_CUTOFF\n"
"        const int* __restrict__ tiles, const unsigned int* __restrict__ interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, const real4* __restrict__ blockCenter, const unsigned int* __restrict__ interactingAtoms,\n"
"#elif defined USE_GK\n"
"        unsigned long long* __restrict__ fieldS, unsigned long long* __restrict__ fieldPolarS, const real3* __restrict__ inducedDipoleS,\n"
"        const real3* __restrict__ inducedDipolePolarS, const real* __restrict__ bornRadii,\n"
"#endif\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        unsigned long long* __restrict__ fieldGradient, unsigned long long* __restrict__ fieldGradientPolar,\n"
"    #ifdef USE_GK\n"
"        unsigned long long* __restrict__ fieldGradientS, unsigned long long* __restrict__ fieldGradientPolarS,\n"
"    #endif\n"
"#endif\n"
"        const float2* __restrict__ dampingAndThole) {\n"
"    const unsigned int totalWarps = (blockDim.x*gridDim.x)/TILE_SIZE;\n"
"    const unsigned int warp = (blockIdx.x*blockDim.x+threadIdx.x)/TILE_SIZE;\n"
"    const unsigned int tgx = threadIdx.x & (TILE_SIZE-1);\n"
"    const unsigned int tbx = threadIdx.x - tgx;\n"
"    __shared__ AtomData localData[THREAD_BLOCK_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        AtomData data;\n"
"        zeroAtomData(data);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"#ifdef USE_GK\n"
"        loadAtomData(data, atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"        loadAtomData(data, atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[threadIdx.x].pos = data.pos;\n"
"            localData[threadIdx.x].inducedDipole = data.inducedDipole;\n"
"            localData[threadIdx.x].inducedDipolePolar = data.inducedDipolePolar;\n"
"            localData[threadIdx.x].thole = data.thole;\n"
"            localData[threadIdx.x].damp = data.damp;\n"
"#ifdef USE_GK\n"
"            localData[threadIdx.x].inducedDipoleS = data.inducedDipoleS;\n"
"            localData[threadIdx.x].inducedDipolePolarS = data.inducedDipolePolarS;\n"
"            localData[threadIdx.x].bornRadius = data.bornRadius;\n"
"#endif\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+j].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(data, localData[tbx+j], delta, atom1 == atom2);\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"#ifdef USE_GK\n"
"            loadAtomData(localData[threadIdx.x], y*TILE_SIZE+tgx, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            loadAtomData(localData[threadIdx.x], y*TILE_SIZE+tgx, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"            zeroAtomData(localData[threadIdx.x]);\n"
"            unsigned int tj = tgx;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+tj].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = y*TILE_SIZE+j;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(data, localData[tbx+tj], delta, false);\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        SAVE_ATOM_DATA(offset, data)\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            SAVE_ATOM_DATA(offset, localData[threadIdx.x])\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? startTileIndex+warp*(long long)numTileIndices/totalWarps : warp*(long long)numTiles/totalWarps);\n"
"    int end = (int) (numTiles > maxTiles ? startTileIndex+(warp+1)*(long long)numTileIndices/totalWarps : (warp+1)*(long long)numTiles/totalWarps);\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+warp*(long long)numTiles/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*(long long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    __shared__ int atomIndices[THREAD_BLOCK_SIZE];\n"
"    __shared__ volatile int skipTiles[THREAD_BLOCK_SIZE];\n"
"    skipTiles[threadIdx.x] = -1;\n"
"    \n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[threadIdx.x] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[threadIdx.x] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            AtomData data;\n"
"            zeroAtomData(data);\n"
"#ifdef USE_GK\n"
"            loadAtomData(data, atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            loadAtomData(data, atom1, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[threadIdx.x] = j;\n"
"#ifdef USE_GK\n"
"            loadAtomData(localData[threadIdx.x], j, posq, inducedDipole, inducedDipolePolar, dampingAndThole, inducedDipoleS, inducedDipolePolarS, bornRadii);\n"
"#else\n"
"            loadAtomData(localData[threadIdx.x], j, posq, inducedDipole, inducedDipolePolar, dampingAndThole);\n"
"#endif\n"
"            zeroAtomData(localData[threadIdx.x]);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = localData[tbx+tj].pos-data.pos;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                int atom2 = atomIndices[tbx+tj];\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS)\n"
"                    computeOneInteraction(data, localData[tbx+tj], delta, false);\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            unsigned int offset = x*TILE_SIZE + tgx;\n"
"            SAVE_ATOM_DATA(offset, data)\n"
"#ifdef USE_CUTOFF\n"
"            offset = atomIndices[threadIdx.x];\n"
"#else\n"
"            offset = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            SAVE_ATOM_DATA(offset, localData[threadIdx.x])\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void recordInducedDipolesForDIIS(const long long* __restrict__ fixedField, const long long* __restrict__ fixedFieldPolar,\n"
"        const float* __restrict__ polarizability, float2* __restrict__ errors, real* __restrict__ prevErrors, real* __restrict__ matrix,\n"
"        const long long* __restrict__ fixedFieldS, const long long* __restrict__ inducedField, const long long* __restrict__ inducedFieldPolar,\n"
"        const real* __restrict__ inducedDipole, const real* __restrict__ inducedDipolePolar,\n"
"        real* __restrict__ prevDipoles, real* __restrict__ prevDipolesPolar, int iteration, bool recordPrevErrors) {\n"
"    __shared__ real2 buffer[64];\n"
"    const real fieldScale = 1/(real) 0x100000000;\n"
"    real sumErrors = 0;\n"
"    real sumPolarErrors = 0;\n"
"    for (int atom = blockIdx.x*blockDim.x + threadIdx.x; atom < NUM_ATOMS; atom += blockDim.x*gridDim.x) {\n"
"        real scale = polarizability[atom];\n"
"        for (int component = 0; component < 3; component++) {\n"
"            int dipoleIndex = 3*atom+component;\n"
"            int fieldIndex = atom+component*PADDED_NUM_ATOMS;\n"
"            if (iteration >= MAX_PREV_DIIS_DIPOLES) {\n"
"                // We have filled up the buffer for previous dipoles, so shift them all over by one.\n"
"                \n"
"                for (int i = 1; i < MAX_PREV_DIIS_DIPOLES; i++) {\n"
"                    int index1 = dipoleIndex+(i-1)*NUM_ATOMS*3;\n"
"                    int index2 = dipoleIndex+i*NUM_ATOMS*3;\n"
"                    prevDipoles[index1] = prevDipoles[index2];\n"
"                    prevDipolesPolar[index1] = prevDipolesPolar[index2];\n"
"                    if (recordPrevErrors)\n"
"                        prevErrors[index1] = prevErrors[index2];\n"
"                }\n"
"            }\n"
"            \n"
"            // Compute the new dipole, and record it along with the error.\n"
"            \n"
"            real oldDipole = inducedDipole[dipoleIndex];\n"
"            real oldDipolePolar = inducedDipolePolar[dipoleIndex];\n"
"            long long fixedS = (fixedFieldS == NULL ? (long long) 0 : fixedFieldS[fieldIndex]);\n"
"            real newDipole = scale*((fixedField[fieldIndex]+fixedS+inducedField[fieldIndex])*fieldScale);\n"
"            real newDipolePolar = scale*((fixedFieldPolar[fieldIndex]+fixedS+inducedFieldPolar[fieldIndex])*fieldScale);\n"
"            int storePrevIndex = dipoleIndex+min(iteration, MAX_PREV_DIIS_DIPOLES-1)*NUM_ATOMS*3;\n"
"            prevDipoles[storePrevIndex] = newDipole;\n"
"            prevDipolesPolar[storePrevIndex] = newDipolePolar;\n"
"            if (recordPrevErrors)\n"
"                prevErrors[storePrevIndex] = newDipole-oldDipole;\n"
"            sumErrors += (newDipole-oldDipole)*(newDipole-oldDipole);\n"
"            sumPolarErrors += (newDipolePolar-oldDipolePolar)*(newDipolePolar-oldDipolePolar);\n"
"        }\n"
"    }\n"
"    \n"
"    // Sum the errors over threads and store the total for this block.\n"
"    \n"
"    buffer[threadIdx.x] = make_real2(sumErrors, sumPolarErrors);\n"
"    __syncthreads();\n"
"    for (int offset = 1; offset < blockDim.x; offset *= 2) {\n"
"        if (threadIdx.x+offset < blockDim.x && (threadIdx.x&(2*offset-1)) == 0) {\n"
"            buffer[threadIdx.x].x += buffer[threadIdx.x+offset].x;\n"
"            buffer[threadIdx.x].y += buffer[threadIdx.x+offset].y;\n"
"        }\n"
"        __syncthreads();\n"
"    }\n"
"    if (threadIdx.x == 0)\n"
"        errors[blockIdx.x] = make_float2((float) buffer[0].x, (float) buffer[0].y);\n"
"    \n"
"    if (iteration >= MAX_PREV_DIIS_DIPOLES && recordPrevErrors && blockIdx.x == 0) {\n"
"        // Shift over the existing matrix elements.\n"
"        \n"
"        for (int i = 0; i < MAX_PREV_DIIS_DIPOLES-1; i++) {\n"
"            if (threadIdx.x < MAX_PREV_DIIS_DIPOLES-1)\n"
"                matrix[threadIdx.x+i*MAX_PREV_DIIS_DIPOLES] = matrix[(threadIdx.x+1)+(i+1)*MAX_PREV_DIIS_DIPOLES];\n"
"            __syncthreads();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeDIISMatrix(real* __restrict__ prevErrors, int iteration, real* __restrict__ matrix) {\n"
"    __shared__ real sumBuffer[512];\n"
"    int j = min(iteration, MAX_PREV_DIIS_DIPOLES-1);\n"
"    for (int i = blockIdx.x; i <= j; i += gridDim.x) {\n"
"        // All the threads in this thread block work together to compute a single matrix element.\n"
"\n"
"        real sum = 0;\n"
"        for (int index = threadIdx.x; index < NUM_ATOMS*3; index += blockDim.x)\n"
"            sum += prevErrors[index+i*NUM_ATOMS*3]*prevErrors[index+j*NUM_ATOMS*3];\n"
"        sumBuffer[threadIdx.x] = sum;\n"
"        __syncthreads();\n"
"        for (int offset = 1; offset < blockDim.x; offset *= 2) { \n"
"            if (threadIdx.x+offset < blockDim.x && (threadIdx.x&(2*offset-1)) == 0)\n"
"                sumBuffer[threadIdx.x] += sumBuffer[threadIdx.x+offset];\n"
"            __syncthreads();\n"
"        }\n"
"        if (threadIdx.x == 0) {\n"
"            matrix[i+MAX_PREV_DIIS_DIPOLES*j] = sumBuffer[0];\n"
"            if (i != j)\n"
"                matrix[j+MAX_PREV_DIIS_DIPOLES*i] = sumBuffer[0];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void solveDIISMatrix(int iteration, const real* __restrict__ matrix, float* __restrict__ coefficients) {\n"
"    __shared__ real b[MAX_PREV_DIIS_DIPOLES+1][MAX_PREV_DIIS_DIPOLES+1];\n"
"    __shared__ real piv[MAX_PREV_DIIS_DIPOLES+1];\n"
"    __shared__ real x[MAX_PREV_DIIS_DIPOLES+1];\n"
"\n"
"    // On the first iteration we don't need to do any calculation.\n"
"    \n"
"    if (iteration == 0) {\n"
"        if (threadIdx.x == 0)\n"
"            coefficients[0] = 1;\n"
"        return;\n"
"    }\n"
"    \n"
"    // Load the matrix.\n"
"    \n"
"    int numPrev = min(iteration+1, MAX_PREV_DIIS_DIPOLES);\n"
"    int rank = numPrev+1;\n"
"    for (int index = threadIdx.x; index < numPrev*numPrev; index += blockDim.x) {\n"
"        int i = index/numPrev;\n"
"        int j = index-i*numPrev;\n"
"        b[i+1][j+1] = matrix[i*MAX_PREV_DIIS_DIPOLES+j];\n"
"    }\n"
"    for (int i = threadIdx.x; i < rank; i += blockDim.x) {\n"
"        b[i][0] = -1;\n"
"        piv[i] = i;\n"
"    }\n"
"    __syncthreads();\n"
"    \n"
"    // Compute the mean absolute value of the values we just loaded.  We use that for preconditioning it,\n"
"    // which is essential for doing the computation in single precision.\n"
"    \n"
"    if (threadIdx.x == 0) {\n"
"        real mean = 0;\n"
"        for (int i = 0; i < numPrev; i++)\n"
"            for (int j = 0; j < numPrev; j++)\n"
"                mean += fabs(b[i+1][j+1]);\n"
"        mean /= numPrev*numPrev;\n"
"        b[0][0] = 0;\n"
"        for (int i = 1; i < rank; i++)\n"
"            b[0][i] = -mean;\n"
"\n"
"        // Compute the LU decomposition of the matrix.  This code is adapted from JAMA.\n"
"    \n"
"        int pivsign = 1;\n"
"        for (int j = 0; j < rank; j++) {\n"
"            // Apply previous transformations.\n"
"\n"
"            for (int i = 0; i < rank; i++) {\n"
"                // Most of the time is spent in the following dot product.\n"
"\n"
"                int kmax = min(i, j);\n"
"                real s = 0;\n"
"                for (int k = 0; k < kmax; k++)\n"
"                    s += b[i][k] * b[k][j];\n"
"                b[i][j] -= s;\n"
"            }\n"
"\n"
"            // Find pivot and exchange if necessary.\n"
"\n"
"            int p = j;\n"
"            for (int i = j+1; i < rank; i++)\n"
"                if (abs(b[i][j]) > abs(b[p][j]))\n"
"                    p = i;\n"
"            if (p != j) {\n"
"                int k = 0;\n"
"                for (k = 0; k < rank; k++) {\n"
"                    real t = b[p][k];\n"
"                    b[p][k] = b[j][k];\n"
"                    b[j][k] = t;\n"
"                }\n"
"                k = piv[p];\n"
"                piv[p] = piv[j];\n"
"                piv[j] = k;\n"
"                pivsign = -pivsign;\n"
"            }\n"
"\n"
"            // Compute multipliers.\n"
"\n"
"            if ((j < rank) && (b[j][j] != 0))\n"
"                for (int i = j+1; i < rank; i++)\n"
"                    b[i][j] /= b[j][j];\n"
"        }\n"
"        for (int i = 0; i < rank; i++)\n"
"            if (b[i][i] == 0) {\n"
"                // The matrix is singular.\n"
"                \n"
"                for (int j = 0; j < rank-1; j++)\n"
"                    coefficients[j] = 0;\n"
"                coefficients[rank-1] = 1;\n"
"                return;\n"
"            }\n"
"\n"
"        // Solve b*Y = X(piv)\n"
"        \n"
"        for (int i = 0; i < rank; i++) \n"
"            x[i] = (piv[i] == 0 ? -1 : 0);\n"
"        for (int k = 0; k < rank; k++)\n"
"            for (int i = k+1; i < rank; i++)\n"
"                x[i] -= x[k] * b[i][k];\n"
"\n"
"        // Solve U*X = Y;\n"
"        \n"
"        for (int k = rank-1; k >= 0; k--) {\n"
"            x[k] /= b[k][k];\n"
"            for (int i = 0; i < k; i++)\n"
"                x[i] -= x[k] * b[i][k];\n"
"        }\n"
"        \n"
"        // Record the coefficients.\n"
"        \n"
"        real lastCoeff = 1;\n"
"        for (int i = 0; i < rank-1; i++) {\n"
"            real c = x[i+1]*mean;\n"
"            coefficients[i] = c;\n"
"            lastCoeff -= c;\n"
"        }\n"
"        coefficients[rank-1] = lastCoeff;\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void updateInducedFieldByDIIS(real* __restrict__ inducedDipole, real* __restrict__ inducedDipolePolar, \n"
"        const real* __restrict__ prevDipoles, const real* __restrict__ prevDipolesPolar, const float* __restrict__ coefficients, int numPrev) {\n"
"    for (int index = blockIdx.x*blockDim.x + threadIdx.x; index < 3*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        real sum = 0;\n"
"        real sumPolar = 0;\n"
"        for (int i = 0; i < numPrev; i++) {\n"
"            sum += coefficients[i]*prevDipoles[i*3*NUM_ATOMS+index];\n"
"            sumPolar += coefficients[i]*prevDipolesPolar[i*3*NUM_ATOMS+index];\n"
"        }\n"
"        inducedDipole[index] = sum;\n"
"        inducedDipolePolar[index] = sumPolar;\n"
"    }\n"
"}\n"
"#endif // not HIPPO\n"
"\n"
"extern \"C\" __global__ void initExtrapolatedDipoles(real* __restrict__ inducedDipole, real* __restrict__ extrapolatedDipole\n"
"#ifndef HIPPO\n"
"        , real* __restrict__ inducedDipolePolar, real* __restrict__ extrapolatedDipolePolar, long long* __restrict__ inducedDipoleFieldGradient, long long* __restrict__ inducedDipoleFieldGradientPolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , real* __restrict__ inducedDipoleGk, real* __restrict__ inducedDipoleGkPolar, real* __restrict__ extrapolatedDipoleGk, real* __restrict__ extrapolatedDipoleGkPolar,\n"
"        real* __restrict__ inducedDipoleFieldGradientGk, real* __restrict__ inducedDipoleFieldGradientGkPolar\n"
"#endif\n"
"        ) {\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < 3*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        extrapolatedDipole[index] = inducedDipole[index];\n"
"#ifndef HIPPO\n"
"        extrapolatedDipolePolar[index] = inducedDipolePolar[index];\n"
"#endif\n"
"#ifdef USE_GK\n"
"        extrapolatedDipoleGk[index] = inducedDipoleGk[index];\n"
"        extrapolatedDipoleGkPolar[index] = inducedDipoleGkPolar[index];\n"
"#endif\n"
"    }\n"
"#ifndef HIPPO\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < 6*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        inducedDipoleFieldGradient[index] = 0;\n"
"        inducedDipoleFieldGradientPolar[index] = 0;\n"
"#ifdef USE_GK\n"
"        inducedDipoleFieldGradientGk[index] = 0;\n"
"        inducedDipoleFieldGradientGkPolar[index] = 0;\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"extern \"C\" __global__ void iterateExtrapolatedDipoles(int order, real* __restrict__ inducedDipole, real* __restrict__ extrapolatedDipole, long long* __restrict__ inducedDipoleField,\n"
"#ifndef HIPPO\n"
"        real* __restrict__ inducedDipolePolar, real* __restrict__ extrapolatedDipolePolar, long long* __restrict__ inducedDipoleFieldPolar, long long* __restrict__ inducedDipoleFieldGradient,\n"
"        long long* __restrict__ inducedDipoleFieldGradientPolar, real* __restrict__ extrapolatedDipoleFieldGradient, real* __restrict__ extrapolatedDipoleFieldGradientPolar,\n"
"#endif\n"
"#ifdef USE_GK\n"
"        real* __restrict__ inducedDipoleGk, real* __restrict__ inducedDipoleGkPolar, real* __restrict__ extrapolatedDipoleGk, real* __restrict__ extrapolatedDipoleGkPolar,\n"
"        real* __restrict__ inducedDipoleFieldGradientGk, real* __restrict__ inducedDipoleFieldGradientGkPolar, long long* __restrict__ inducedDipoleFieldGk,\n"
"        long long* __restrict__ inducedDipoleFieldGkPolar, real* __restrict__ extrapolatedDipoleFieldGradientGk, real* __restrict__ extrapolatedDipoleFieldGradientGkPolar,\n"
"#endif\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ polarizability\n"
"#else\n"
"        const float* __restrict__ polarizability\n"
"#endif\n"
"    ) {\n"
"    const real fieldScale = 1/(real) 0x100000000;\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < 3*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        int atom = index/3;\n"
"        int component = index-3*atom;\n"
"        int fieldIndex = atom+component*PADDED_NUM_ATOMS;\n"
"        float polar = polarizability[atom];\n"
"        real value = inducedDipoleField[fieldIndex]*fieldScale*polar;\n"
"        inducedDipole[index] = value;\n"
"        extrapolatedDipole[order*3*NUM_ATOMS+index] = value;\n"
"#ifndef HIPPO\n"
"        value = inducedDipoleFieldPolar[fieldIndex]*fieldScale*polar;\n"
"        inducedDipolePolar[index] = value;\n"
"        extrapolatedDipolePolar[order*3*NUM_ATOMS+index] = value;\n"
"#endif\n"
"#ifdef USE_GK\n"
"        value = inducedDipoleFieldGk[fieldIndex]*fieldScale*polar;\n"
"        inducedDipoleGk[index] = value;\n"
"        extrapolatedDipoleGk[order*3*NUM_ATOMS+index] = value;\n"
"        value = inducedDipoleFieldGkPolar[fieldIndex]*fieldScale*polar;\n"
"        inducedDipoleGkPolar[index] = value;\n"
"        extrapolatedDipoleGkPolar[order*3*NUM_ATOMS+index] = value;\n"
"#endif\n"
"    }\n"
"#ifndef HIPPO\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < 6*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        int index2 = (order-1)*6*NUM_ATOMS+index;\n"
"        extrapolatedDipoleFieldGradient[index2] = fieldScale*inducedDipoleFieldGradient[index];\n"
"        extrapolatedDipoleFieldGradientPolar[index2] = fieldScale*inducedDipoleFieldGradientPolar[index];\n"
"#ifdef USE_GK\n"
"        extrapolatedDipoleFieldGradientGk[index2] = fieldScale*inducedDipoleFieldGradientGk[index];\n"
"        extrapolatedDipoleFieldGradientGkPolar[index2] = fieldScale*inducedDipoleFieldGradientGkPolar[index];\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeExtrapolatedDipoles(real* __restrict__ inducedDipole, real* __restrict__ extrapolatedDipole\n"
"#ifndef HIPPO\n"
"        , real* __restrict__ inducedDipolePolar, real* __restrict__ extrapolatedDipolePolar\n"
"#endif\n"
"#ifdef USE_GK\n"
"        , real* __restrict__ inducedDipoleGk, real* __restrict__ inducedDipoleGkPolar, real* __restrict__ extrapolatedDipoleGk, real* __restrict__ extrapolatedDipoleGkPolar\n"
"#endif\n"
"        ) {\n"
"    real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < 3*NUM_ATOMS; index += blockDim.x*gridDim.x) {\n"
"        real sum = 0, sumPolar = 0, sumGk = 0, sumGkPolar = 0;\n"
"        for (int order = 0; order < MAX_EXTRAPOLATION_ORDER; order++) {\n"
"            sum += extrapolatedDipole[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#ifndef HIPPO\n"
"            sumPolar += extrapolatedDipolePolar[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#endif\n"
"#ifdef USE_GK\n"
"            sumGk += extrapolatedDipoleGk[order*3*NUM_ATOMS+index]*coeff[order];\n"
"            sumGkPolar += extrapolatedDipoleGkPolar[order*3*NUM_ATOMS+index]*coeff[order];\n"
"#endif\n"
"        }\n"
"        inducedDipole[index] = sum;\n"
"#ifndef HIPPO\n"
"        inducedDipolePolar[index] = sumPolar;\n"
"#endif\n"
"#ifdef USE_GK\n"
"        inducedDipoleGk[index] = sumGk;\n"
"        inducedDipoleGkPolar[index] = sumGkPolar;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void addExtrapolatedFieldGradientToForce(long long* __restrict__ forceBuffers, real* __restrict__ extrapolatedDipole,\n"
"        real* __restrict__ extrapolatedDipolePolar, real* __restrict__ extrapolatedDipoleFieldGradient, real* __restrict__ extrapolatedDipoleFieldGradientPolar\n"
"#ifdef USE_GK\n"
"        , real* __restrict__ extrapolatedDipoleGk, real* __restrict__ extrapolatedDipoleGkPolar,\n"
"        real* __restrict__ extrapolatedDipoleFieldGradientGk, real* __restrict__ extrapolatedDipoleFieldGradientGkPolar\n"
"#endif\n"
"        ) {\n"
"    real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"    for (int atom = blockIdx.x*blockDim.x+threadIdx.x; atom < NUM_ATOMS; atom += blockDim.x*gridDim.x) {\n"
"        real fx = 0, fy = 0, fz = 0;\n"
"        for (int l = 0; l < MAX_EXTRAPOLATION_ORDER-1; l++) {\n"
"            int index1 = 3*(l*NUM_ATOMS+atom);\n"
"            real dipole[] = {extrapolatedDipole[index1], extrapolatedDipole[index1+1], extrapolatedDipole[index1+2]};\n"
"            real dipolePolar[] = {extrapolatedDipolePolar[index1], extrapolatedDipolePolar[index1+1], extrapolatedDipolePolar[index1+2]};\n"
"#ifdef USE_GK\n"
"            real dipoleGk[] = {extrapolatedDipoleGk[index1], extrapolatedDipoleGk[index1+1], extrapolatedDipoleGk[index1+2]};\n"
"            real dipoleGkPolar[] = {extrapolatedDipoleGkPolar[index1], extrapolatedDipoleGkPolar[index1+1], extrapolatedDipoleGkPolar[index1+2]};\n"
"#endif\n"
"            for (int m = 0; m < MAX_EXTRAPOLATION_ORDER-1-l; m++) {\n"
"                int index2 = 6*(m*NUM_ATOMS+atom);\n"
"                real scale = 0.5f*coeff[l+m+1]*ENERGY_SCALE_FACTOR;\n"
"                real gradient[] = {extrapolatedDipoleFieldGradient[index2], extrapolatedDipoleFieldGradient[index2+1], extrapolatedDipoleFieldGradient[index2+2],\n"
"                                   extrapolatedDipoleFieldGradient[index2+3], extrapolatedDipoleFieldGradient[index2+4], extrapolatedDipoleFieldGradient[index2+5]};\n"
"                real gradientPolar[] = {extrapolatedDipoleFieldGradientPolar[index2], extrapolatedDipoleFieldGradientPolar[index2+1], extrapolatedDipoleFieldGradientPolar[index2+2],\n"
"                                        extrapolatedDipoleFieldGradientPolar[index2+3], extrapolatedDipoleFieldGradientPolar[index2+4], extrapolatedDipoleFieldGradientPolar[index2+5]};\n"
"                fx += scale*(dipole[0]*gradientPolar[0] + dipole[1]*gradientPolar[3] + dipole[2]*gradientPolar[4]);\n"
"                fy += scale*(dipole[0]*gradientPolar[3] + dipole[1]*gradientPolar[1] + dipole[2]*gradientPolar[5]);\n"
"                fz += scale*(dipole[0]*gradientPolar[4] + dipole[1]*gradientPolar[5] + dipole[2]*gradientPolar[2]);\n"
"                fx += scale*(dipolePolar[0]*gradient[0] + dipolePolar[1]*gradient[3] + dipolePolar[2]*gradient[4]);\n"
"                fy += scale*(dipolePolar[0]*gradient[3] + dipolePolar[1]*gradient[1] + dipolePolar[2]*gradient[5]);\n"
"                fz += scale*(dipolePolar[0]*gradient[4] + dipolePolar[1]*gradient[5] + dipolePolar[2]*gradient[2]);\n"
"#ifdef USE_GK\n"
"                real gradientGk[] = {extrapolatedDipoleFieldGradient[index2], extrapolatedDipoleFieldGradient[index2+1], extrapolatedDipoleFieldGradient[index2+2],\n"
"                                   extrapolatedDipoleFieldGradient[index2+3], extrapolatedDipoleFieldGradient[index2+4], extrapolatedDipoleFieldGradient[index2+5]};\n"
"                real gradientGkPolar[] = {extrapolatedDipoleFieldGradientPolar[index2], extrapolatedDipoleFieldGradientPolar[index2+1], extrapolatedDipoleFieldGradientPolar[index2+2],\n"
"                                        extrapolatedDipoleFieldGradientPolar[index2+3], extrapolatedDipoleFieldGradientPolar[index2+4], extrapolatedDipoleFieldGradientPolar[index2+5]};\n"
"                fx += scale*(dipoleGk[0]*gradientGkPolar[0] + dipoleGk[1]*gradientGkPolar[3] + dipoleGk[2]*gradientGkPolar[4]);\n"
"                fy += scale*(dipoleGk[0]*gradientGkPolar[3] + dipoleGk[1]*gradientGkPolar[1] + dipoleGk[2]*gradientGkPolar[5]);\n"
"                fz += scale*(dipoleGk[0]*gradientGkPolar[4] + dipoleGk[1]*gradientGkPolar[5] + dipoleGk[2]*gradientGkPolar[2]);\n"
"                fx += scale*(dipoleGkPolar[0]*gradientGk[0] + dipoleGkPolar[1]*gradientGk[3] + dipoleGkPolar[2]*gradientGk[4]);\n"
"                fy += scale*(dipoleGkPolar[0]*gradientGk[3] + dipoleGkPolar[1]*gradientGk[1] + dipoleGkPolar[2]*gradientGk[5]);\n"
"                fz += scale*(dipoleGkPolar[0]*gradientGk[4] + dipoleGkPolar[1]*gradientGk[5] + dipoleGkPolar[2]*gradientGk[2]);\n"
"#endif\n"
"            }\n"
"        }\n"
"        forceBuffers[atom] += (long long) (fx*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] += (long long) (fy*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS*2] += (long long) (fz*0x100000000);\n"
"    }\n"
"}\n"
"\n"
"#ifdef HIPPO\n"
"extern \"C\" __global__ void computePolarizationEnergy(mixed* __restrict__ energyBuffer, const real3* __restrict__ inducedDipole,\n"
"        const real3* __restrict__ extrapolatedDipole, const real* __restrict__ polarizability) {\n"
"    mixed energy = 0;\n"
"    for (int atom = blockIdx.x*blockDim.x+threadIdx.x; atom < NUM_ATOMS; atom += blockDim.x*gridDim.x)\n"
"        energy -= (ENERGY_SCALE_FACTOR/2)*dot(extrapolatedDipole[atom], inducedDipole[atom])/polarizability[atom];\n"
"    energyBuffer[blockIdx.x*blockDim.x+threadIdx.x] += energy;\n"
"}\n"
"#endif";
const string CudaAmoebaKernelSources::multipolePme = "#define ARRAY(x,y) array[(x)-1+((y)-1)*PME_ORDER]\n"
"\n"
"/**\n"
" * Calculate the spline coefficients for a single atom along a single axis.\n"
" */\n"
"__device__ void computeBSplinePoint(real4* thetai, real w, real* array) {\n"
"    // initialization to get to 2nd order recursion\n"
"\n"
"    ARRAY(2,2) = w;\n"
"    ARRAY(2,1) = 1 - w;\n"
"\n"
"    // perform one pass to get to 3rd order recursion\n"
"\n"
"    ARRAY(3,3) = 0.5f * w * ARRAY(2,2);\n"
"    ARRAY(3,2) = 0.5f * ((1+w)*ARRAY(2,1)+(2-w)*ARRAY(2,2));\n"
"    ARRAY(3,1) = 0.5f * (1-w) * ARRAY(2,1);\n"
"\n"
"    // compute standard B-spline recursion to desired order\n"
"\n"
"    for (int i = 4; i <= PME_ORDER; i++)\n"
"    {\n"
"        int k = i - 1;\n"
"        real denom = RECIP(k);\n"
"        ARRAY(i,i) = denom * w * ARRAY(k,k);\n"
"        for (int j = 1; j <= i-2; j++)\n"
"            ARRAY(i,i-j) = denom * ((w+j)*ARRAY(k,i-j-1)+(i-j-w)*ARRAY(k,i-j));\n"
"        ARRAY(i,1) = denom * (1-w) * ARRAY(k,1);\n"
"    }\n"
"\n"
"    // get coefficients for the B-spline first derivative\n"
"\n"
"    int k = PME_ORDER - 1;\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // get coefficients for the B-spline second derivative\n"
"\n"
"    k = PME_ORDER - 2;\n"
"    ARRAY(k,PME_ORDER-1) = ARRAY(k,PME_ORDER-2);\n"
"    for (int i = PME_ORDER-2; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // get coefficients for the B-spline third derivative\n"
"\n"
"    k = PME_ORDER - 3;\n"
"    ARRAY(k,PME_ORDER-2) = ARRAY(k,PME_ORDER-3);\n"
"    for (int i = PME_ORDER-3; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER-1) = ARRAY(k,PME_ORDER-2);\n"
"    for (int i = PME_ORDER-2; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"    ARRAY(k,PME_ORDER) = ARRAY(k,PME_ORDER-1);\n"
"    for (int i = PME_ORDER-1; i >= 2; i--)\n"
"        ARRAY(k,i) = ARRAY(k,i-1) - ARRAY(k,i);\n"
"    ARRAY(k,1) = -ARRAY(k,1);\n"
"\n"
"    // copy coefficients from temporary to permanent storage\n"
"\n"
"    for (int i = 1; i <= PME_ORDER; i++)\n"
"        thetai[i-1] = make_real4(ARRAY(PME_ORDER,i), ARRAY(PME_ORDER-1,i), ARRAY(PME_ORDER-2,i), ARRAY(PME_ORDER-3,i));\n"
"}\n"
"\n"
"/**\n"
" * Convert the fixed multipoles from Cartesian to fractional coordinates.\n"
" */\n"
"extern \"C\" __global__ void transformMultipolesToFractionalCoordinates(const real* __restrict__ labDipole,\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ labQXX, const real* __restrict__ labQXY, const real* __restrict__ labQXZ, const real* __restrict__ labQYY, const real* __restrict__ labQYZ,\n"
"#else\n"
"        const real* __restrict__ labQuadrupole,\n"
"#endif\n"
"        real* __restrict__ fracDipole, real* __restrict__ fracQuadrupole, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"    // Build matrices for transforming the dipoles and quadrupoles.\n"
"    \n"
"    __shared__ real a[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        a[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        a[0][1] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        a[0][2] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        a[1][0] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        a[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        a[1][2] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        a[2][0] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        a[2][1] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        a[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    int index1[] = {0, 0, 0, 1, 1, 2};\n"
"    int index2[] = {0, 1, 2, 1, 2, 2};\n"
"    __shared__ real b[6][6];\n"
"    if (threadIdx.x < 36) {\n"
"        int i = threadIdx.x/6;\n"
"        int j = threadIdx.x-6*i;\n"
"        b[i][j] = a[index1[i]][index1[j]]*a[index2[i]][index2[j]];\n"
"        if (index1[i] != index2[i])\n"
"            b[i][j] += a[index1[i]][index2[j]]*a[index2[i]][index1[j]];\n"
"    }\n"
"    __syncthreads();\n"
"    \n"
"    // Transform the multipoles.\n"
"    \n"
"    real quadScale[] = {1, 2, 2, 1, 2, 1};\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        for (int j = 0; j < 3; j++) {\n"
"            real dipole = 0;\n"
"            for (int k = 0; k < 3; k++)\n"
"                dipole += a[j][k]*labDipole[3*i+k];\n"
"            fracDipole[3*i+j] = dipole;\n"
"        }\n"
"        for (int j = 0; j < 6; j++) {\n"
"#ifdef HIPPO\n"
"            real quadrupole = quadScale[0]*b[j][0]*labQXX[i] +\n"
"                              quadScale[1]*b[j][1]*labQXY[i] +\n"
"                              quadScale[2]*b[j][2]*labQXZ[i] +\n"
"                              quadScale[3]*b[j][3]*labQYY[i] +\n"
"                              quadScale[4]*b[j][4]*labQYZ[i] -\n"
"                              quadScale[5]*b[j][5]*(labQXX[i]+labQYY[i]);\n"
"#else\n"
"            real quadrupole = 0;\n"
"            for (int k = 0; k < 5; k++)\n"
"                quadrupole += quadScale[k]*b[j][k]*labQuadrupole[5*i+k];\n"
"            quadrupole -= quadScale[5]*b[j][5]*(labQuadrupole[5*i]+labQuadrupole[5*i+3]);\n"
"#endif\n"
"            fracQuadrupole[6*i+j] = quadrupole;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Convert the potential from fractional to Cartesian coordinates.\n"
" */\n"
"extern \"C\" __global__ void transformPotentialToCartesianCoordinates(const real* __restrict__ fphi, real* __restrict__ cphi, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"    // Build matrices for transforming the potential.\n"
"\n"
"    __shared__ real a[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        a[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        a[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        a[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        a[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        a[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        a[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        a[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        a[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        a[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    int index1[] = {0, 1, 2, 0, 0, 1};\n"
"    int index2[] = {0, 1, 2, 1, 2, 2};\n"
"    __shared__ real b[6][6];\n"
"    if (threadIdx.x < 36) {\n"
"        int i = threadIdx.x/6;\n"
"        int j = threadIdx.x-6*i;\n"
"        b[i][j] = a[index1[i]][index1[j]]*a[index2[i]][index2[j]];\n"
"        if (index1[j] != index2[j])\n"
"            b[i][j] += (i < 3 ? b[i][j] : a[index1[i]][index2[j]]*a[index2[i]][index1[j]]);\n"
"    }\n"
"    __syncthreads();\n"
"\n"
"    // Transform the potential.\n"
"    \n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        cphi[10*i] = fphi[i];\n"
"        cphi[10*i+1] = a[0][0]*fphi[i+NUM_ATOMS*1] + a[0][1]*fphi[i+NUM_ATOMS*2] + a[0][2]*fphi[i+NUM_ATOMS*3];\n"
"        cphi[10*i+2] = a[1][0]*fphi[i+NUM_ATOMS*1] + a[1][1]*fphi[i+NUM_ATOMS*2] + a[1][2]*fphi[i+NUM_ATOMS*3];\n"
"        cphi[10*i+3] = a[2][0]*fphi[i+NUM_ATOMS*1] + a[2][1]*fphi[i+NUM_ATOMS*2] + a[2][2]*fphi[i+NUM_ATOMS*3];\n"
"        for (int j = 0; j < 6; j++) {\n"
"            cphi[10*i+4+j] = 0;\n"
"            for (int k = 0; k < 6; k++)\n"
"                cphi[10*i+4+j] += b[j][k]*fphi[i+NUM_ATOMS*(4+k)];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void gridSpreadFixedMultipoles(const real4* __restrict__ posq, const real* __restrict__ fracDipole,\n"
"        const real* __restrict__ fracQuadrupole,\n"
"#ifdef HIPPO\n"
"        real* __restrict__ pmeGrid, const real* __restrict__ coreCharge, const real* __restrict__ valenceCharge,\n"
"#else\n"
"        real2* __restrict__ pmeGrid,\n"
"#endif\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    __shared__ real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*threadIdx.x];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    \n"
"    for (int m = blockIdx.x*blockDim.x+threadIdx.x; m < NUM_ATOMS; m += blockDim.x*gridDim.x) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"#ifdef HIPPO\n"
"        real atomCharge = coreCharge[m]+valenceCharge[m];\n"
"#else\n"
"        real atomCharge = pos.w;\n"
"#endif\n"
"        real atomDipoleX = fracDipole[m*3];\n"
"        real atomDipoleY = fracDipole[m*3+1];\n"
"        real atomDipoleZ = fracDipole[m*3+2];\n"
"        real atomQuadrupoleXX = fracQuadrupole[m*6];\n"
"        real atomQuadrupoleXY = fracQuadrupole[m*6+1];\n"
"        real atomQuadrupoleXZ = fracQuadrupole[m*6+2];\n"
"        real atomQuadrupoleYY = fracQuadrupole[m*6+3];\n"
"        real atomQuadrupoleYZ = fracQuadrupole[m*6+4];\n"
"        real atomQuadrupoleZZ = fracQuadrupole[m*6+5];\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"        \n"
"        // Spread the charge from this atom onto each grid point.\n"
"         \n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = igrid1+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"            real4 t = theta1[ix];\n"
"            \n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = igrid2+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = xbase + ybase*GRID_SIZE_Z;\n"
"                real4 u = theta2[iy];\n"
"                real term0 = atomCharge*t.x*u.x + atomDipoleY*t.x*u.y + atomQuadrupoleYY*t.x*u.z + atomDipoleX*t.y*u.x + atomQuadrupoleXY*t.y*u.y + atomQuadrupoleXX*t.z*u.x;\n"
"                real term1 = atomDipoleZ*t.x*u.x + atomQuadrupoleYZ*t.x*u.y + atomQuadrupoleXZ*t.y*u.x;\n"
"                real term2 = atomQuadrupoleZZ*t.x*u.x;\n"
"                \n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = igrid3+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = ybase + zindex;\n"
"                    real4 v = theta3[iz];\n"
"                    real add = term0*v.x + term1*v.y + term2*v.z;\n"
"#ifdef HIPPO\n"
"    #ifdef USE_DOUBLE_PRECISION\n"
"                unsigned long long * ulonglong_p = (unsigned long long *) pmeGrid;\n"
"                atomicAdd(&ulonglong_p[index],  static_cast<unsigned long long>((long long) (add*0x100000000)));\n"
"    #else\n"
"                atomicAdd(&pmeGrid[index], add);\n"
"    #endif\n"
"#else\n"
"    #ifdef USE_DOUBLE_PRECISION\n"
"                unsigned long long * ulonglong_p = (unsigned long long *) pmeGrid;\n"
"                atomicAdd(&ulonglong_p[2*index],  static_cast<unsigned long long>((long long) (add*0x100000000)));\n"
"    #else\n"
"                atomicAdd(&pmeGrid[index].x, add);\n"
"    #endif\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void gridSpreadInducedDipoles(const real4* __restrict__ posq, const real3* __restrict__ inducedDipole,\n"
"#ifdef HIPPO\n"
"        real* __restrict__ pmeGrid,\n"
"#else\n"
"        const real3* __restrict__ inducedDipolePolar, real2* __restrict__ pmeGrid,\n"
"#endif\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    __shared__ real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*threadIdx.x];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    __shared__ real cartToFrac[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        cartToFrac[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        cartToFrac[0][1] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        cartToFrac[0][2] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        cartToFrac[1][0] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        cartToFrac[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        cartToFrac[1][2] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        cartToFrac[2][0] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        cartToFrac[2][1] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        cartToFrac[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    \n"
"    for (int m = blockIdx.x*blockDim.x+threadIdx.x; m < NUM_ATOMS; m += blockDim.x*gridDim.x) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"        real3 cinducedDipole = inducedDipole[m];\n"
"        real3 finducedDipole = make_real3(cinducedDipole.x*cartToFrac[0][0] + cinducedDipole.y*cartToFrac[0][1] + cinducedDipole.z*cartToFrac[0][2],\n"
"                                          cinducedDipole.x*cartToFrac[1][0] + cinducedDipole.y*cartToFrac[1][1] + cinducedDipole.z*cartToFrac[1][2],\n"
"                                          cinducedDipole.x*cartToFrac[2][0] + cinducedDipole.y*cartToFrac[2][1] + cinducedDipole.z*cartToFrac[2][2]);\n"
"#ifndef HIPPO\n"
"        real3 cinducedDipolePolar = inducedDipolePolar[m];\n"
"        real3 finducedDipolePolar = make_real3(cinducedDipolePolar.x*cartToFrac[0][0] + cinducedDipolePolar.y*cartToFrac[0][1] + cinducedDipolePolar.z*cartToFrac[0][2],\n"
"                                               cinducedDipolePolar.x*cartToFrac[1][0] + cinducedDipolePolar.y*cartToFrac[1][1] + cinducedDipolePolar.z*cartToFrac[1][2],\n"
"                                               cinducedDipolePolar.x*cartToFrac[2][0] + cinducedDipolePolar.y*cartToFrac[2][1] + cinducedDipolePolar.z*cartToFrac[2][2]);\n"
"#endif\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"        \n"
"        // Spread the charge from this atom onto each grid point.\n"
"         \n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = igrid1+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"            real4 t = theta1[ix];\n"
"            \n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = igrid2+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = xbase + ybase*GRID_SIZE_Z;\n"
"                real4 u = theta2[iy];\n"
"                real term01 = finducedDipole.y*t.x*u.y + finducedDipole.x*t.y*u.x;\n"
"                real term11 = finducedDipole.z*t.x*u.x;\n"
"#ifndef HIPPO\n"
"                real term02 = finducedDipolePolar.y*t.x*u.y + finducedDipolePolar.x*t.y*u.x;\n"
"                real term12 = finducedDipolePolar.z*t.x*u.x;\n"
"#endif                \n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = igrid3+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = ybase + zindex;\n"
"                    real4 v = theta3[iz];\n"
"\n"
"                    real add1 = term01*v.x + term11*v.y;\n"
"#ifdef HIPPO\n"
"    #ifdef USE_DOUBLE_PRECISION\n"
"                    unsigned long long * ulonglong_p = (unsigned long long *) pmeGrid;\n"
"                    atomicAdd(&ulonglong_p[index],  static_cast<unsigned long long>((long long) (add1*0x100000000)));\n"
"    #else\n"
"                    atomicAdd(&pmeGrid[index], add1);\n"
"    #endif\n"
"#else\n"
"                    real add2 = term02*v.x + term12*v.y;\n"
"    #ifdef USE_DOUBLE_PRECISION\n"
"                    unsigned long long * ulonglong_p = (unsigned long long *) pmeGrid;\n"
"                    atomicAdd(&ulonglong_p[2*index],  static_cast<unsigned long long>((long long) (add1*0x100000000)));\n"
"                    atomicAdd(&ulonglong_p[2*index+1],  static_cast<unsigned long long>((long long) (add2*0x100000000)));\n"
"    #else\n"
"                    atomicAdd(&pmeGrid[index].x, add1);\n"
"                    atomicAdd(&pmeGrid[index].y, add2);\n"
"    #endif\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * In double precision, we have to use fixed point to accumulate the grid values, so convert them to floating point.\n"
" */\n"
"extern \"C\" __global__ void finishSpreadCharge(long long* __restrict__ pmeGrid) {\n"
"    real* floatGrid = (real*) pmeGrid;\n"
"#ifdef HIPPO\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#else\n"
"    const unsigned int gridSize = 2*GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#endif\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < gridSize; index += blockDim.x*gridDim.x)\n"
"        floatGrid[index] = scale*pmeGrid[index];\n"
"}\n"
"\n"
"extern \"C\" __global__ void reciprocalConvolution(real2* __restrict__ pmeGrid, const real* __restrict__ pmeBsplineModuliX,\n"
"        const real* __restrict__ pmeBsplineModuliY, const real* __restrict__ pmeBsplineModuliZ, real4 periodicBoxSize,\n"
"        real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"#ifdef HIPPO\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"#else\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"#endif\n"
"    real expFactor = M_PI*M_PI/(EWALD_ALPHA*EWALD_ALPHA);\n"
"    real scaleFactor = RECIP(M_PI*periodicBoxSize.x*periodicBoxSize.y*periodicBoxSize.z);\n"
"    for (int index = blockIdx.x*blockDim.x+threadIdx.x; index < gridSize; index += blockDim.x*gridDim.x) {\n"
"#ifdef HIPPO\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"        int ky = remainder/(GRID_SIZE_Z/2+1);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z/2+1);\n"
"#else\n"
"        int kx = index/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = index-kx*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        int ky = remainder/GRID_SIZE_Z;\n"
"        int kz = remainder-ky*GRID_SIZE_Z;\n"
"#endif\n"
"        if (kx == 0 && ky == 0 && kz == 0) {\n"
"            pmeGrid[index] = make_real2(0, 0);\n"
"            continue;\n"
"        }\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"        real2 grid = pmeGrid[index];\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = scaleFactor*EXP(-expFactor*m2)/denom;\n"
"        pmeGrid[index] = make_real2(grid.x*eterm, grid.y*eterm);\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeFixedPotentialFromGrid(\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ pmeGrid,\n"
"#else\n"
"        const real2* __restrict__ pmeGrid,\n"
"#endif\n"
"        real* __restrict__ phi, long long* __restrict__ fieldBuffers,\n"
"#ifndef HIPPO\n"
"        long long* __restrict__ fieldPolarBuffers,\n"
"#endif\n"
"        const real4* __restrict__ posq, const real* __restrict__ labDipole, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    __shared__ real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*threadIdx.x];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    __shared__ real fracToCart[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    \n"
"    for (int m = blockIdx.x*blockDim.x+threadIdx.x; m < NUM_ATOMS; m += blockDim.x*gridDim.x) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"\n"
"        // Compute the potential from this grid point.\n"
"\n"
"        real tuv000 = 0;\n"
"        real tuv001 = 0;\n"
"        real tuv010 = 0;\n"
"        real tuv100 = 0;\n"
"        real tuv200 = 0;\n"
"        real tuv020 = 0;\n"
"        real tuv002 = 0;\n"
"        real tuv110 = 0;\n"
"        real tuv101 = 0;\n"
"        real tuv011 = 0;\n"
"        real tuv300 = 0;\n"
"        real tuv030 = 0;\n"
"        real tuv003 = 0;\n"
"        real tuv210 = 0;\n"
"        real tuv201 = 0;\n"
"        real tuv120 = 0;\n"
"        real tuv021 = 0;\n"
"        real tuv102 = 0;\n"
"        real tuv012 = 0;\n"
"        real tuv111 = 0;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int i = igrid1+ix-(igrid1+ix >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            real4 v = theta1[ix];\n"
"            real tu00 = 0;\n"
"            real tu10 = 0;\n"
"            real tu01 = 0;\n"
"            real tu20 = 0;\n"
"            real tu11 = 0;\n"
"            real tu02 = 0;\n"
"            real tu30 = 0;\n"
"            real tu21 = 0;\n"
"            real tu12 = 0;\n"
"            real tu03 = 0;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int j = igrid2+iy-(igrid2+iy >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                real4 u = theta2[iy];\n"
"                real4 t = make_real4(0, 0, 0, 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int k = igrid3+iz-(igrid3+iz >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int gridIndex = i*GRID_SIZE_Y*GRID_SIZE_Z + j*GRID_SIZE_Z + k;\n"
"#ifdef HIPPO\n"
"                    real tq = pmeGrid[gridIndex];\n"
"#else\n"
"                    real tq = pmeGrid[gridIndex].x;\n"
"#endif\n"
"                    real4 tadd = theta3[iz];\n"
"                    t.x += tq*tadd.x;\n"
"                    t.y += tq*tadd.y;\n"
"                    t.z += tq*tadd.z;\n"
"                    t.w += tq*tadd.w;\n"
"                }\n"
"                tu00 += u.x*t.x;\n"
"                tu10 += u.y*t.x;\n"
"                tu01 += u.x*t.y;\n"
"                tu20 += u.z*t.x;\n"
"                tu11 += u.y*t.y;\n"
"                tu02 += u.x*t.z;\n"
"                tu30 += u.w*t.x;\n"
"                tu21 += u.z*t.y;\n"
"                tu12 += u.y*t.z;\n"
"                tu03 += u.x*t.w;\n"
"            }\n"
"            tuv000 += v.x*tu00;\n"
"            tuv100 += v.y*tu00;\n"
"            tuv010 += v.x*tu10;\n"
"            tuv001 += v.x*tu01;\n"
"            tuv200 += v.z*tu00;\n"
"            tuv020 += v.x*tu20;\n"
"            tuv002 += v.x*tu02;\n"
"            tuv110 += v.y*tu10;\n"
"            tuv101 += v.y*tu01;\n"
"            tuv011 += v.x*tu11;\n"
"            tuv300 += v.w*tu00;\n"
"            tuv030 += v.x*tu30;\n"
"            tuv003 += v.x*tu03;\n"
"            tuv210 += v.z*tu10;\n"
"            tuv201 += v.z*tu01;\n"
"            tuv120 += v.y*tu20;\n"
"            tuv021 += v.x*tu21;\n"
"            tuv102 += v.y*tu02;\n"
"            tuv012 += v.x*tu12;\n"
"            tuv111 += v.y*tu11;\n"
"        }\n"
"        phi[m] = tuv000;\n"
"        phi[m+NUM_ATOMS] = tuv100;\n"
"        phi[m+NUM_ATOMS*2] = tuv010;\n"
"        phi[m+NUM_ATOMS*3] = tuv001;\n"
"        phi[m+NUM_ATOMS*4] = tuv200;\n"
"        phi[m+NUM_ATOMS*5] = tuv020;\n"
"        phi[m+NUM_ATOMS*6] = tuv002;\n"
"        phi[m+NUM_ATOMS*7] = tuv110;\n"
"        phi[m+NUM_ATOMS*8] = tuv101;\n"
"        phi[m+NUM_ATOMS*9] = tuv011;\n"
"        phi[m+NUM_ATOMS*10] = tuv300;\n"
"        phi[m+NUM_ATOMS*11] = tuv030;\n"
"        phi[m+NUM_ATOMS*12] = tuv003;\n"
"        phi[m+NUM_ATOMS*13] = tuv210;\n"
"        phi[m+NUM_ATOMS*14] = tuv201;\n"
"        phi[m+NUM_ATOMS*15] = tuv120;\n"
"        phi[m+NUM_ATOMS*16] = tuv021;\n"
"        phi[m+NUM_ATOMS*17] = tuv102;\n"
"        phi[m+NUM_ATOMS*18] = tuv012;\n"
"        phi[m+NUM_ATOMS*19] = tuv111;\n"
"        real dipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"        long long fieldx = (long long) ((dipoleScale*labDipole[m*3]-tuv100*fracToCart[0][0]-tuv010*fracToCart[0][1]-tuv001*fracToCart[0][2])*0x100000000);\n"
"        long long fieldy = (long long) ((dipoleScale*labDipole[m*3+1]-tuv100*fracToCart[1][0]-tuv010*fracToCart[1][1]-tuv001*fracToCart[1][2])*0x100000000);\n"
"        long long fieldz = (long long) ((dipoleScale*labDipole[m*3+2]-tuv100*fracToCart[2][0]-tuv010*fracToCart[2][1]-tuv001*fracToCart[2][2])*0x100000000);\n"
"        fieldBuffers[m] = fieldx;\n"
"        fieldBuffers[m+PADDED_NUM_ATOMS] = fieldy;\n"
"        fieldBuffers[m+2*PADDED_NUM_ATOMS] = fieldz;\n"
"#ifndef HIPPO\n"
"        fieldPolarBuffers[m] = fieldx;\n"
"        fieldPolarBuffers[m+PADDED_NUM_ATOMS] = fieldy;\n"
"        fieldPolarBuffers[m+2*PADDED_NUM_ATOMS] = fieldz;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeInducedPotentialFromGrid(\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ pmeGrid, real* __restrict__ extrapolatedPhi, int order,\n"
"#else\n"
"        const real2* __restrict__ pmeGrid, real* __restrict__ phid, real* __restrict__ phip,\n"
"#endif\n"
"        real* __restrict__ phidp, const real4* __restrict__ posq,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real3 recipBoxVecX,\n"
"        real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"#if __CUDA_ARCH__ < 500\n"
"    real array[PME_ORDER*PME_ORDER];\n"
"#else\n"
"    // We have shared memory to spare, and putting the workspace array there reduces the load on L2 cache.\n"
"    __shared__ real sharedArray[PME_ORDER*PME_ORDER*64];\n"
"    real* array = &sharedArray[PME_ORDER*PME_ORDER*threadIdx.x];\n"
"#endif\n"
"    real4 theta1[PME_ORDER];\n"
"    real4 theta2[PME_ORDER];\n"
"    real4 theta3[PME_ORDER];\n"
"    \n"
"    for (int m = blockIdx.x*blockDim.x+threadIdx.x; m < NUM_ATOMS; m += blockDim.x*gridDim.x) {\n"
"        real4 pos = posq[m];\n"
"        pos -= periodicBoxVecZ*floor(pos.z*recipBoxVecZ.z+0.5f);\n"
"        pos -= periodicBoxVecY*floor(pos.y*recipBoxVecY.z+0.5f);\n"
"        pos -= periodicBoxVecX*floor(pos.x*recipBoxVecX.z+0.5f);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real w = pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x;\n"
"        real fr = GRID_SIZE_X*(w-(int)(w+0.5f)+0.5f);\n"
"        int ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid1 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta1, w, array);\n"
"        w = pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y;\n"
"        fr = GRID_SIZE_Y*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid2 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta2, w, array);\n"
"        w = pos.z*recipBoxVecZ.z;\n"
"        fr = GRID_SIZE_Z*(w-(int)(w+0.5f)+0.5f);\n"
"        ifr = (int) floor(fr);\n"
"        w = fr - ifr;\n"
"        int igrid3 = ifr-PME_ORDER+1;\n"
"        computeBSplinePoint(theta3, w, array);\n"
"        igrid1 += (igrid1 < 0 ? GRID_SIZE_X : 0);\n"
"        igrid2 += (igrid2 < 0 ? GRID_SIZE_Y : 0);\n"
"        igrid3 += (igrid3 < 0 ? GRID_SIZE_Z : 0);\n"
"\n"
"        // Compute the potential from this grid point.\n"
"\n"
"#ifndef HIPPO\n"
"        real tuv100_1 = 0;\n"
"        real tuv010_1 = 0;\n"
"        real tuv001_1 = 0;\n"
"        real tuv200_1 = 0;\n"
"        real tuv020_1 = 0;\n"
"        real tuv002_1 = 0;\n"
"        real tuv110_1 = 0;\n"
"        real tuv101_1 = 0;\n"
"        real tuv011_1 = 0;\n"
"        real tuv100_2 = 0;\n"
"        real tuv010_2 = 0;\n"
"        real tuv001_2 = 0;\n"
"        real tuv200_2 = 0;\n"
"        real tuv020_2 = 0;\n"
"        real tuv002_2 = 0;\n"
"        real tuv110_2 = 0;\n"
"        real tuv101_2 = 0;\n"
"        real tuv011_2 = 0;\n"
"#endif\n"
"        real tuv000 = 0;\n"
"        real tuv001 = 0;\n"
"        real tuv010 = 0;\n"
"        real tuv100 = 0;\n"
"        real tuv200 = 0;\n"
"        real tuv020 = 0;\n"
"        real tuv002 = 0;\n"
"        real tuv110 = 0;\n"
"        real tuv101 = 0;\n"
"        real tuv011 = 0;\n"
"        real tuv300 = 0;\n"
"        real tuv030 = 0;\n"
"        real tuv003 = 0;\n"
"        real tuv210 = 0;\n"
"        real tuv201 = 0;\n"
"        real tuv120 = 0;\n"
"        real tuv021 = 0;\n"
"        real tuv102 = 0;\n"
"        real tuv012 = 0;\n"
"        real tuv111 = 0;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int i = igrid1+ix-(igrid1+ix >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            real4 v = theta1[ix];\n"
"#ifndef HIPPO\n"
"            real tu00_1 = 0;\n"
"            real tu01_1 = 0;\n"
"            real tu10_1 = 0;\n"
"            real tu20_1 = 0;\n"
"            real tu11_1 = 0;\n"
"            real tu02_1 = 0;\n"
"            real tu00_2 = 0;\n"
"            real tu01_2 = 0;\n"
"            real tu10_2 = 0;\n"
"            real tu20_2 = 0;\n"
"            real tu11_2 = 0;\n"
"            real tu02_2 = 0;\n"
"#endif\n"
"            real tu00 = 0;\n"
"            real tu10 = 0;\n"
"            real tu01 = 0;\n"
"            real tu20 = 0;\n"
"            real tu11 = 0;\n"
"            real tu02 = 0;\n"
"            real tu30 = 0;\n"
"            real tu21 = 0;\n"
"            real tu12 = 0;\n"
"            real tu03 = 0;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int j = igrid2+iy-(igrid2+iy >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                real4 u = theta2[iy];\n"
"#ifdef HIPPO\n"
"                real t0 = 0;\n"
"                real t1 = 0;\n"
"                real t2 = 0;\n"
"#else\n"
"                real t0_1 = 0;\n"
"                real t1_1 = 0;\n"
"                real t2_1 = 0;\n"
"                real t0_2 = 0;\n"
"                real t1_2 = 0;\n"
"                real t2_2 = 0;\n"
"#endif\n"
"                real t3 = 0;\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int k = igrid3+iz-(igrid3+iz >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int gridIndex = i*GRID_SIZE_Y*GRID_SIZE_Z + j*GRID_SIZE_Z + k;\n"
"                    real4 tadd = theta3[iz];\n"
"#ifdef HIPPO\n"
"                    real tq = pmeGrid[gridIndex];\n"
"                    t0 += tq*tadd.x;\n"
"                    t1 += tq*tadd.y;\n"
"                    t2 += tq*tadd.z;\n"
"                    t3 += tq*tadd.w;\n"
"#else\n"
"                    real2 tq = pmeGrid[gridIndex];\n"
"                    t0_1 += tq.x*tadd.x;\n"
"                    t1_1 += tq.x*tadd.y;\n"
"                    t2_1 += tq.x*tadd.z;\n"
"                    t0_2 += tq.y*tadd.x;\n"
"                    t1_2 += tq.y*tadd.y;\n"
"                    t2_2 += tq.y*tadd.z;\n"
"                    t3 += (tq.x+tq.y)*tadd.w;\n"
"#endif\n"
"                }\n"
"#ifndef HIPPO\n"
"                tu00_1 += u.x*t0_1;\n"
"                tu10_1 += u.y*t0_1;\n"
"                tu01_1 += u.x*t1_1;\n"
"                tu20_1 += u.z*t0_1;\n"
"                tu11_1 += u.y*t1_1;\n"
"                tu02_1 += u.x*t2_1;\n"
"                tu00_2 += u.x*t0_2;\n"
"                tu10_2 += u.y*t0_2;\n"
"                tu01_2 += u.x*t1_2;\n"
"                tu20_2 += u.z*t0_2;\n"
"                tu11_2 += u.y*t1_2;\n"
"                tu02_2 += u.x*t2_2;\n"
"                real t0 = t0_1 + t0_2;\n"
"                real t1 = t1_1 + t1_2;\n"
"                real t2 = t2_1 + t2_2;\n"
"#endif\n"
"                tu00 += u.x*t0;\n"
"                tu10 += u.y*t0;\n"
"                tu01 += u.x*t1;\n"
"                tu20 += u.z*t0;\n"
"                tu11 += u.y*t1;\n"
"                tu02 += u.x*t2;\n"
"                tu30 += u.w*t0;\n"
"                tu21 += u.z*t1;\n"
"                tu12 += u.y*t2;\n"
"                tu03 += u.x*t3;\n"
"            }\n"
"#ifndef HIPPO\n"
"            tuv100_1 += v.y*tu00_1;\n"
"            tuv010_1 += v.x*tu10_1;\n"
"            tuv001_1 += v.x*tu01_1;\n"
"            tuv200_1 += v.z*tu00_1;\n"
"            tuv020_1 += v.x*tu20_1;\n"
"            tuv002_1 += v.x*tu02_1;\n"
"            tuv110_1 += v.y*tu10_1;\n"
"            tuv101_1 += v.y*tu01_1;\n"
"            tuv011_1 += v.x*tu11_1;\n"
"            tuv100_2 += v.y*tu00_2;\n"
"            tuv010_2 += v.x*tu10_2;\n"
"            tuv001_2 += v.x*tu01_2;\n"
"            tuv200_2 += v.z*tu00_2;\n"
"            tuv020_2 += v.x*tu20_2;\n"
"            tuv002_2 += v.x*tu02_2;\n"
"            tuv110_2 += v.y*tu10_2;\n"
"            tuv101_2 += v.y*tu01_2;\n"
"            tuv011_2 += v.x*tu11_2;\n"
"#endif\n"
"            tuv000 += v.x*tu00;\n"
"            tuv100 += v.y*tu00;\n"
"            tuv010 += v.x*tu10;\n"
"            tuv001 += v.x*tu01;\n"
"            tuv200 += v.z*tu00;\n"
"            tuv020 += v.x*tu20;\n"
"            tuv002 += v.x*tu02;\n"
"            tuv110 += v.y*tu10;\n"
"            tuv101 += v.y*tu01;\n"
"            tuv011 += v.x*tu11;\n"
"            tuv300 += v.w*tu00;\n"
"            tuv030 += v.x*tu30;\n"
"            tuv003 += v.x*tu03;\n"
"            tuv210 += v.z*tu10;\n"
"            tuv201 += v.z*tu01;\n"
"            tuv120 += v.y*tu20;\n"
"            tuv021 += v.x*tu21;\n"
"            tuv102 += v.y*tu02;\n"
"            tuv012 += v.x*tu12;\n"
"            tuv111 += v.y*tu11;\n"
"        }\n"
"#ifndef HIPPO\n"
"        phid[m]   = 0;\n"
"        phid[m+NUM_ATOMS] = tuv100_1;\n"
"        phid[m+NUM_ATOMS*2] = tuv010_1;\n"
"        phid[m+NUM_ATOMS*3] = tuv001_1;\n"
"        phid[m+NUM_ATOMS*4] = tuv200_1;\n"
"        phid[m+NUM_ATOMS*5] = tuv020_1;\n"
"        phid[m+NUM_ATOMS*6] = tuv002_1;\n"
"        phid[m+NUM_ATOMS*7] = tuv110_1;\n"
"        phid[m+NUM_ATOMS*8] = tuv101_1;\n"
"        phid[m+NUM_ATOMS*9] = tuv011_1;\n"
"\n"
"        phip[m]   = 0;\n"
"        phip[m+NUM_ATOMS] = tuv100_2;\n"
"        phip[m+NUM_ATOMS*2] = tuv010_2;\n"
"        phip[m+NUM_ATOMS*3] = tuv001_2;\n"
"        phip[m+NUM_ATOMS*4] = tuv200_2;\n"
"        phip[m+NUM_ATOMS*5] = tuv020_2;\n"
"        phip[m+NUM_ATOMS*6] = tuv002_2;\n"
"        phip[m+NUM_ATOMS*7] = tuv110_2;\n"
"        phip[m+NUM_ATOMS*8] = tuv101_2;\n"
"        phip[m+NUM_ATOMS*9] = tuv011_2;\n"
"#endif\n"
"        phidp[m] = tuv000;\n"
"        phidp[m+NUM_ATOMS*1] = tuv100;\n"
"        phidp[m+NUM_ATOMS*2] = tuv010;\n"
"        phidp[m+NUM_ATOMS*3] = tuv001;\n"
"        phidp[m+NUM_ATOMS*4] = tuv200;\n"
"        phidp[m+NUM_ATOMS*5] = tuv020;\n"
"        phidp[m+NUM_ATOMS*6] = tuv002;\n"
"        phidp[m+NUM_ATOMS*7] = tuv110;\n"
"        phidp[m+NUM_ATOMS*8] = tuv101;\n"
"        phidp[m+NUM_ATOMS*9] = tuv011;\n"
"        phidp[m+NUM_ATOMS*10] = tuv300;\n"
"        phidp[m+NUM_ATOMS*11] = tuv030;\n"
"        phidp[m+NUM_ATOMS*12] = tuv003;\n"
"        phidp[m+NUM_ATOMS*13] = tuv210;\n"
"        phidp[m+NUM_ATOMS*14] = tuv201;\n"
"        phidp[m+NUM_ATOMS*15] = tuv120;\n"
"        phidp[m+NUM_ATOMS*16] = tuv021;\n"
"        phidp[m+NUM_ATOMS*17] = tuv102;\n"
"        phidp[m+NUM_ATOMS*18] = tuv012;\n"
"        phidp[m+NUM_ATOMS*19] = tuv111;\n"
"#ifdef HIPPO\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m] = tuv000;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*1] = tuv100;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*2] = tuv010;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*3] = tuv001;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*4] = tuv200;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*5] = tuv020;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*6] = tuv002;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*7] = tuv110;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*8] = tuv101;\n"
"        extrapolatedPhi[10*NUM_ATOMS*order+m+NUM_ATOMS*9] = tuv011;\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeFixedMultipoleForceAndEnergy(real4* __restrict__ posq, unsigned long long* __restrict__ forceBuffers,\n"
"        long long* __restrict__ torqueBuffers, mixed* __restrict__ energyBuffer, const real* __restrict__ labDipole,\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ coreCharge, const real* __restrict__ valenceCharge, const real* __restrict__ labQXX,\n"
"        const real* __restrict__ labQXY, const real* __restrict__ labQXZ, const real* __restrict__ labQYY, const real* __restrict__ labQYZ,\n"
"#else\n"
"        const real* __restrict__ labQuadrupole,\n"
"#endif\n"
"        const real* __restrict__ fracDipole, const real* __restrict__ fracQuadrupole,\n"
"        const real* __restrict__ phi, const real* __restrict__ cphi_global, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"    real multipole[10];\n"
"    const int deriv1[] = {1, 4, 7, 8, 10, 15, 17, 13, 14, 19};\n"
"    const int deriv2[] = {2, 7, 5, 9, 13, 11, 18, 15, 19, 16};\n"
"    const int deriv3[] = {3, 8, 9, 6, 14, 16, 12, 19, 17, 18};\n"
"    mixed energy = 0;\n"
"    __shared__ real fracToCart[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        // Compute the torque.\n"
"\n"
"        multipole[1] = labDipole[i*3];\n"
"        multipole[2] = labDipole[i*3+1];\n"
"        multipole[3] = labDipole[i*3+2];\n"
"#ifdef HIPPO\n"
"        multipole[0] = coreCharge[i]+valenceCharge[i];\n"
"        multipole[4] = labQXX[i];\n"
"        multipole[5] = labQYY[i];\n"
"        multipole[7] = 2*labQXY[i];\n"
"        multipole[8] = 2*labQXZ[i];\n"
"        multipole[9] = 2*labQYZ[i];\n"
"#else\n"
"        multipole[0] = posq[i].w;\n"
"        multipole[4] = labQuadrupole[i*5];\n"
"        multipole[5] = labQuadrupole[i*5+3];\n"
"        multipole[7] = 2*labQuadrupole[i*5+1];\n"
"        multipole[8] = 2*labQuadrupole[i*5+2];\n"
"        multipole[9] = 2*labQuadrupole[i*5+4];\n"
"#endif\n"
"        multipole[6] = -(multipole[4]+multipole[5]);\n"
"\n"
"        const real* cphi = &cphi_global[10*i];\n"
"\n"
"        torqueBuffers[i] = (long long) (EPSILON_FACTOR*(multipole[3]*cphi[2] - multipole[2]*cphi[3]\n"
"                      + 2*(multipole[6]-multipole[5])*cphi[9]\n"
"                      + multipole[8]*cphi[7] + multipole[9]*cphi[5]\n"
"                      - multipole[7]*cphi[8] - multipole[9]*cphi[6])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] = (long long) (EPSILON_FACTOR*(multipole[1]*cphi[3] - multipole[3]*cphi[1]\n"
"                      + 2*(multipole[4]-multipole[6])*cphi[8]\n"
"                      + multipole[7]*cphi[9] + multipole[8]*cphi[6]\n"
"                      - multipole[8]*cphi[4] - multipole[9]*cphi[7])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] = (long long) (EPSILON_FACTOR*(multipole[2]*cphi[1] - multipole[1]*cphi[2]\n"
"                      + 2*(multipole[5]-multipole[4])*cphi[7]\n"
"                      + multipole[7]*cphi[4] + multipole[9]*cphi[8]\n"
"                      - multipole[7]*cphi[5] - multipole[8]*cphi[9])*0x100000000);\n"
"\n"
"        // Compute the force and energy.\n"
"\n"
"        multipole[1] = fracDipole[i*3];\n"
"        multipole[2] = fracDipole[i*3+1];\n"
"        multipole[3] = fracDipole[i*3+2];\n"
"        multipole[4] = fracQuadrupole[i*6];\n"
"        multipole[5] = fracQuadrupole[i*6+3];\n"
"        multipole[6] = fracQuadrupole[i*6+5];\n"
"        multipole[7] = fracQuadrupole[i*6+1];\n"
"        multipole[8] = fracQuadrupole[i*6+2];\n"
"        multipole[9] = fracQuadrupole[i*6+4];\n"
"\n"
"        real3 f = make_real3(0);\n"
"        for (int k = 0; k < 10; k++) {\n"
"            energy += multipole[k]*phi[i+NUM_ATOMS*k];\n"
"            f.x += multipole[k]*phi[i+NUM_ATOMS*deriv1[k]];\n"
"            f.y += multipole[k]*phi[i+NUM_ATOMS*deriv2[k]];\n"
"            f.z += multipole[k]*phi[i+NUM_ATOMS*deriv3[k]];\n"
"        }\n"
"        f = make_real3(EPSILON_FACTOR*(f.x*fracToCart[0][0] + f.y*fracToCart[0][1] + f.z*fracToCart[0][2]),\n"
"                       EPSILON_FACTOR*(f.x*fracToCart[1][0] + f.y*fracToCart[1][1] + f.z*fracToCart[1][2]),\n"
"                       EPSILON_FACTOR*(f.x*fracToCart[2][0] + f.y*fracToCart[2][1] + f.z*fracToCart[2][2]));\n"
"        forceBuffers[i] -= static_cast<unsigned long long>((long long) (f.x*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS] -= static_cast<unsigned long long>((long long) (f.y*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS*2] -= static_cast<unsigned long long>((long long) (f.z*0x100000000));\n"
"    }\n"
"    energyBuffer[blockIdx.x*blockDim.x+threadIdx.x] += 0.5f*EPSILON_FACTOR*energy;\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeInducedDipoleForceAndEnergy(real4* __restrict__ posq, unsigned long long* __restrict__ forceBuffers,\n"
"        long long* __restrict__ torqueBuffers, mixed* __restrict__ energyBuffer, const real* __restrict__ labDipole,\n"
"#ifdef HIPPO\n"
"        const real* __restrict__ coreCharge, const real* __restrict__ valenceCharge, const real* __restrict__ extrapolatedDipole,\n"
"        const real* __restrict__ extrapolatedPhi, const real* __restrict__ labQXX, const real* __restrict__ labQXY,\n"
"        const real* __restrict__ labQXZ, const real* __restrict__ labQYY, const real* __restrict__ labQYZ,\n"
"#else\n"
"        const real* __restrict__ labQuadrupole,\n"
"#endif\n"
"        const real* __restrict__ fracDipole, const real* __restrict__ fracQuadrupole, const real3* __restrict__ inducedDipole_global,\n"
"#ifndef HIPPO\n"
"        const real3* __restrict__ inducedDipolePolar_global,\n"
"#endif\n"
"        const real* __restrict__ phi,\n"
"#ifndef HIPPO\n"
"        const real* __restrict__ phid, const real* __restrict__ phip,\n"
"#endif\n"
"        const real* __restrict__ phidp, const real* __restrict__ cphi_global, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"    real multipole[10];\n"
"    real cinducedDipole[3], inducedDipole[3];\n"
"    real cinducedDipolePolar[3], inducedDipolePolar[3];\n"
"    const int deriv1[] = {1, 4, 7, 8, 10, 15, 17, 13, 14, 19};\n"
"    const int deriv2[] = {2, 7, 5, 9, 13, 11, 18, 15, 19, 16};\n"
"    const int deriv3[] = {3, 8, 9, 6, 14, 16, 12, 19, 17, 18};\n"
"#ifdef HIPPO\n"
"    const real coeff[] = {EXTRAPOLATION_COEFFICIENTS_SUM};\n"
"#endif\n"
"    mixed energy = 0;\n"
"    __shared__ real fracToCart[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        // Compute the torque.\n"
"\n"
"        multipole[1] = labDipole[i*3];\n"
"        multipole[2] = labDipole[i*3+1];\n"
"        multipole[3] = labDipole[i*3+2];\n"
"#ifdef HIPPO\n"
"        multipole[0] = coreCharge[i]+valenceCharge[i];\n"
"        multipole[4] = labQXX[i];\n"
"        multipole[5] = labQYY[i];\n"
"        multipole[7] = 2*labQXY[i];\n"
"        multipole[8] = 2*labQXZ[i];\n"
"        multipole[9] = 2*labQYZ[i];\n"
"        const real scale = EPSILON_FACTOR;\n"
"#else\n"
"        multipole[0] = posq[i].w;\n"
"        multipole[4] = labQuadrupole[i*5];\n"
"        multipole[5] = labQuadrupole[i*5+3];\n"
"        multipole[7] = 2*labQuadrupole[i*5+1];\n"
"        multipole[8] = 2*labQuadrupole[i*5+2];\n"
"        multipole[9] = 2*labQuadrupole[i*5+4];\n"
"        const real scale = EPSILON_FACTOR/2;\n"
"#endif\n"
"        multipole[6] = -(multipole[4]+multipole[5]);\n"
"        const real* cphi = &cphi_global[10*i];\n"
" \n"
"        torqueBuffers[i] += (long long) (scale*(multipole[3]*cphi[2] - multipole[2]*cphi[3]\n"
"                      + 2*(multipole[6]-multipole[5])*cphi[9]\n"
"                      + multipole[8]*cphi[7] + multipole[9]*cphi[5]\n"
"                      - multipole[7]*cphi[8] - multipole[9]*cphi[6])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] += (long long) (scale*(multipole[1]*cphi[3] - multipole[3]*cphi[1]\n"
"                      + 2*(multipole[4]-multipole[6])*cphi[8]\n"
"                      + multipole[7]*cphi[9] + multipole[8]*cphi[6]\n"
"                      - multipole[8]*cphi[4] - multipole[9]*cphi[7])*0x100000000);\n"
"\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] += (long long) (scale*(multipole[2]*cphi[1] - multipole[1]*cphi[2]\n"
"                      + 2*(multipole[5]-multipole[4])*cphi[7]\n"
"                      + multipole[7]*cphi[4] + multipole[9]*cphi[8]\n"
"                      - multipole[7]*cphi[5] - multipole[8]*cphi[9])*0x100000000);\n"
"\n"
"        // Compute the force and energy.\n"
"\n"
"        multipole[1] = fracDipole[i*3];\n"
"        multipole[2] = fracDipole[i*3+1];\n"
"        multipole[3] = fracDipole[i*3+2];\n"
"        multipole[4] = fracQuadrupole[i*6];\n"
"        multipole[5] = fracQuadrupole[i*6+3];\n"
"        multipole[6] = fracQuadrupole[i*6+5];\n"
"        multipole[7] = fracQuadrupole[i*6+1];\n"
"        multipole[8] = fracQuadrupole[i*6+2];\n"
"        multipole[9] = fracQuadrupole[i*6+4];\n"
"\n"
"        cinducedDipole[0] = inducedDipole_global[i].x;\n"
"        cinducedDipole[1] = inducedDipole_global[i].y;\n"
"        cinducedDipole[2] = inducedDipole_global[i].z;\n"
"#ifndef HIPPO\n"
"        cinducedDipolePolar[0] = inducedDipolePolar_global[i].x;\n"
"        cinducedDipolePolar[1] = inducedDipolePolar_global[i].y;\n"
"        cinducedDipolePolar[2] = inducedDipolePolar_global[i].z;\n"
"#endif\n"
"        \n"
"        // Multiply the dipoles by cartToFrac, which is just the transpose of fracToCart.\n"
"        \n"
"        inducedDipole[0] = cinducedDipole[0]*fracToCart[0][0] + cinducedDipole[1]*fracToCart[1][0] + cinducedDipole[2]*fracToCart[2][0];\n"
"        inducedDipole[1] = cinducedDipole[0]*fracToCart[0][1] + cinducedDipole[1]*fracToCart[1][1] + cinducedDipole[2]*fracToCart[2][1];\n"
"        inducedDipole[2] = cinducedDipole[0]*fracToCart[0][2] + cinducedDipole[1]*fracToCart[1][2] + cinducedDipole[2]*fracToCart[2][2];\n"
"#ifndef HIPPO\n"
"        inducedDipolePolar[0] = cinducedDipolePolar[0]*fracToCart[0][0] + cinducedDipolePolar[1]*fracToCart[1][0] + cinducedDipolePolar[2]*fracToCart[2][0];\n"
"        inducedDipolePolar[1] = cinducedDipolePolar[0]*fracToCart[0][1] + cinducedDipolePolar[1]*fracToCart[1][1] + cinducedDipolePolar[2]*fracToCart[2][1];\n"
"        inducedDipolePolar[2] = cinducedDipolePolar[0]*fracToCart[0][2] + cinducedDipolePolar[1]*fracToCart[1][2] + cinducedDipolePolar[2]*fracToCart[2][2];\n"
"        energy += (inducedDipole[0]+inducedDipolePolar[0])*phi[i+NUM_ATOMS];\n"
"        energy += (inducedDipole[1]+inducedDipolePolar[1])*phi[i+NUM_ATOMS*2];\n"
"        energy += (inducedDipole[2]+inducedDipolePolar[2])*phi[i+NUM_ATOMS*3];\n"
"#endif\n"
"        real3 f = make_real3(0, 0, 0);\n"
"        for (int k = 0; k < 3; k++) {\n"
"            int j1 = deriv1[k+1];\n"
"            int j2 = deriv2[k+1];\n"
"            int j3 = deriv3[k+1];\n"
"#ifdef HIPPO\n"
"            f.x += inducedDipole[k]*phi[i+NUM_ATOMS*j1];\n"
"            f.y += inducedDipole[k]*phi[i+NUM_ATOMS*j2];\n"
"            f.z += inducedDipole[k]*phi[i+NUM_ATOMS*j3];\n"
"#else\n"
"            f.x += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j1];\n"
"            f.y += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j2];\n"
"            f.z += (inducedDipole[k]+inducedDipolePolar[k])*phi[i+NUM_ATOMS*j3];\n"
"#endif\n"
"#ifdef MUTUAL_POLARIZATION\n"
"            f.x += (inducedDipole[k]*phip[i+NUM_ATOMS*j1] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j1]);\n"
"            f.y += (inducedDipole[k]*phip[i+NUM_ATOMS*j2] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j2]);\n"
"            f.z += (inducedDipole[k]*phip[i+NUM_ATOMS*j3] + inducedDipolePolar[k]*phid[i+NUM_ATOMS*j3]);\n"
"#endif\n"
"        }\n"
"\n"
"        for (int k = 0; k < 10; k++) {\n"
"            f.x += multipole[k]*phidp[i+NUM_ATOMS*deriv1[k]];\n"
"            f.y += multipole[k]*phidp[i+NUM_ATOMS*deriv2[k]];\n"
"            f.z += multipole[k]*phidp[i+NUM_ATOMS*deriv3[k]];\n"
"        }\n"
"\n"
"#ifdef HIPPO\n"
"        // Account for dipole response terms in the OPT method\n"
"\n"
"        for (int j = 0; j < MAX_EXTRAPOLATION_ORDER-1; j++) {\n"
"            for (int m = 0; m < MAX_EXTRAPOLATION_ORDER-1-j; m++) {\n"
"                real3 optDipole = make_real3(\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][0] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][0] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][0],\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][1] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][1] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][1],\n"
"                        extrapolatedDipole[3*NUM_ATOMS*m+3*i]*fracToCart[0][2] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+1]*fracToCart[1][2] + extrapolatedDipole[3*NUM_ATOMS*m+3*i+2]*fracToCart[2][2]);\n"
"                real3 h = make_real3(\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv1[3]],\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv2[3]],\n"
"                        optDipole.x*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[1]] + optDipole.y*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[2]] + optDipole.z*extrapolatedPhi[10*NUM_ATOMS*j+i+NUM_ATOMS*deriv3[3]]);\n"
"                f += coeff[j+m+1]*h;\n"
"            }\n"
"        }\n"
"#endif\n"
"        f = make_real3(scale*(f.x*fracToCart[0][0] + f.y*fracToCart[0][1] + f.z*fracToCart[0][2]),\n"
"                       scale*(f.x*fracToCart[1][0] + f.y*fracToCart[1][1] + f.z*fracToCart[1][2]),\n"
"                       scale*(f.x*fracToCart[2][0] + f.y*fracToCart[2][1] + f.z*fracToCart[2][2]));\n"
"        forceBuffers[i] -= static_cast<unsigned long long>((long long) (f.x*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS] -= static_cast<unsigned long long>((long long) (f.y*0x100000000));\n"
"        forceBuffers[i+PADDED_NUM_ATOMS*2] -= static_cast<unsigned long long>((long long) (f.z*0x100000000));\n"
"    }\n"
"#ifndef HIPPO\n"
"    energyBuffer[blockIdx.x*blockDim.x+threadIdx.x] += 0.25f*EPSILON_FACTOR*energy;\n"
"#endif\n"
"}\n"
"\n"
"#ifdef HIPPO\n"
"extern \"C\" __global__ void recordInducedFieldDipoles(const real* __restrict__ phidp, long long* __restrict__ inducedField,\n"
"        const real3* __restrict__ inducedDipole, real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ) {\n"
"    __shared__ real fracToCart[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    real selfDipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        inducedField[i] -= (long long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[0][0] + phidp[i+NUM_ATOMS*2]*fracToCart[0][1] + phidp[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipole[i].x));\n"
"        inducedField[i+PADDED_NUM_ATOMS] -= (long long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[1][0] + phidp[i+NUM_ATOMS*2]*fracToCart[1][1] + phidp[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipole[i].y));\n"
"        inducedField[i+PADDED_NUM_ATOMS*2] -= (long long) (0x100000000*(phidp[i+NUM_ATOMS]*fracToCart[2][0] + phidp[i+NUM_ATOMS*2]*fracToCart[2][1] + phidp[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipole[i].z));\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void calculateSelfEnergyAndTorque(long long* __restrict__ torqueBuffers, mixed* __restrict__ energyBuffer,\n"
"        const real3* __restrict__ labDipole, const real* __restrict__ coreCharge, const real* __restrict__ valenceCharge,\n"
"        const real* __restrict__ c6, const real3* __restrict__ inducedDipole, const real* __restrict__ labQXX, const real* __restrict__ labQXY,\n"
"        const real* __restrict__ labQXZ, const real* __restrict__ labQYY, const real* __restrict__ labQYZ) {\n"
"    const real torqueScale = 4*EPSILON_FACTOR*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/(3*SQRT_PI);\n"
"    real cii = 0;\n"
"    real dii = 0;\n"
"    real qii = 0;\n"
"    real c6ii = 0;\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        real charge = coreCharge[i]+valenceCharge[i];\n"
"        real3 dipole = labDipole[i];\n"
"        real3 induced = inducedDipole[i];\n"
"        real qXX = labQXX[i];\n"
"        real qXY = labQXY[i];\n"
"        real qXZ = labQXZ[i];\n"
"        real qYY = labQYY[i];\n"
"        real qYZ = labQYZ[i];\n"
"        real qZZ = -qXX-qYY;\n"
"        real c6i = c6[i];\n"
"        cii += charge*charge;\n"
"        dii += dot(dipole, dipole);\n"
"        qii += qXX*qXX + qYY*qYY + qZZ*qZZ + 2*(qXY*qXY + qXZ*qXZ + qYZ*qYZ);\n"
"        c6ii += c6i*c6i;\n"
"        real3 torque = torqueScale*cross(dipole, induced);\n"
"        torqueBuffers[i] += (long long) (torque.x*0x100000000);\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS] += (long long) (torque.y*0x100000000);\n"
"        torqueBuffers[i+PADDED_NUM_ATOMS*2] += (long long) (torque.z*0x100000000);\n"
"    }\n"
"    real term = 2*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fterm = -EPSILON_FACTOR*EWALD_ALPHA/SQRT_PI;\n"
"    real alpha3 = DISPERSION_EWALD_ALPHA*DISPERSION_EWALD_ALPHA*DISPERSION_EWALD_ALPHA;\n"
"    energyBuffer[blockIdx.x*blockDim.x+threadIdx.x] += fterm*(cii + term*(dii/3+2*term*qii/5)) + alpha3*alpha3*c6ii/12;\n"
"}\n"
"#else\n"
"extern \"C\" __global__ void recordInducedFieldDipoles(const real* __restrict__ phid, real* const __restrict__ phip, long long* __restrict__ inducedField,\n"
"        long long* __restrict__ inducedFieldPolar, const real3* __restrict__ inducedDipole, const real3* __restrict__ inducedDipolePolar,\n"
"        real3 recipBoxVecX, real3 recipBoxVecY, real3 recipBoxVecZ\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        , unsigned long long* __restrict__ fieldGradient, unsigned long long* __restrict__ fieldGradientPolar\n"
"#endif\n"
"        ) {\n"
"    __shared__ real fracToCart[3][3];\n"
"    if (threadIdx.x == 0) {\n"
"        fracToCart[0][0] = GRID_SIZE_X*recipBoxVecX.x;\n"
"        fracToCart[1][0] = GRID_SIZE_X*recipBoxVecY.x;\n"
"        fracToCart[2][0] = GRID_SIZE_X*recipBoxVecZ.x;\n"
"        fracToCart[0][1] = GRID_SIZE_Y*recipBoxVecX.y;\n"
"        fracToCart[1][1] = GRID_SIZE_Y*recipBoxVecY.y;\n"
"        fracToCart[2][1] = GRID_SIZE_Y*recipBoxVecZ.y;\n"
"        fracToCart[0][2] = GRID_SIZE_Z*recipBoxVecX.z;\n"
"        fracToCart[1][2] = GRID_SIZE_Z*recipBoxVecY.z;\n"
"        fracToCart[2][2] = GRID_SIZE_Z*recipBoxVecZ.z;\n"
"    }\n"
"    __syncthreads();\n"
"    real selfDipoleScale = (4/(real) 3)*(EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA)/SQRT_PI;\n"
"    for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < NUM_ATOMS; i += blockDim.x*gridDim.x) {\n"
"        inducedField[i] -= (long long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[0][0] + phid[i+NUM_ATOMS*2]*fracToCart[0][1] + phid[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipole[i].x));\n"
"        inducedField[i+PADDED_NUM_ATOMS] -= (long long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[1][0] + phid[i+NUM_ATOMS*2]*fracToCart[1][1] + phid[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipole[i].y));\n"
"        inducedField[i+PADDED_NUM_ATOMS*2] -= (long long) (0x100000000*(phid[i+NUM_ATOMS]*fracToCart[2][0] + phid[i+NUM_ATOMS*2]*fracToCart[2][1] + phid[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipole[i].z));\n"
"        inducedFieldPolar[i] -= (long long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[0][0] + phip[i+NUM_ATOMS*2]*fracToCart[0][1] + phip[i+NUM_ATOMS*3]*fracToCart[0][2] - selfDipoleScale*inducedDipolePolar[i].x));\n"
"        inducedFieldPolar[i+PADDED_NUM_ATOMS] -= (long long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[1][0] + phip[i+NUM_ATOMS*2]*fracToCart[1][1] + phip[i+NUM_ATOMS*3]*fracToCart[1][2] - selfDipoleScale*inducedDipolePolar[i].y));\n"
"        inducedFieldPolar[i+PADDED_NUM_ATOMS*2] -= (long long) (0x100000000*(phip[i+NUM_ATOMS]*fracToCart[2][0] + phip[i+NUM_ATOMS*2]*fracToCart[2][1] + phip[i+NUM_ATOMS*3]*fracToCart[2][2] - selfDipoleScale*inducedDipolePolar[i].z));\n"
"#ifdef EXTRAPOLATED_POLARIZATION\n"
"        // Compute and store the field gradients for later use.\n"
"\n"
"        real EmatD[3][3] = {\n"
"            {phid[i+NUM_ATOMS*4], phid[i+NUM_ATOMS*7], phid[i+NUM_ATOMS*8]},\n"
"            {phid[i+NUM_ATOMS*7], phid[i+NUM_ATOMS*5], phid[i+NUM_ATOMS*9]},\n"
"            {phid[i+NUM_ATOMS*8], phid[i+NUM_ATOMS*9], phid[i+NUM_ATOMS*6]}\n"
"        };\n"
"        real Exx = 0, Eyy = 0, Ezz = 0, Exy = 0, Exz = 0, Eyz = 0;\n"
"        for (int k = 0; k < 3; ++k) {\n"
"            for (int l = 0; l < 3; ++l) {\n"
"                Exx += fracToCart[0][k] * EmatD[k][l] * fracToCart[0][l];\n"
"                Eyy += fracToCart[1][k] * EmatD[k][l] * fracToCart[1][l];\n"
"                Ezz += fracToCart[2][k] * EmatD[k][l] * fracToCart[2][l];\n"
"                Exy += fracToCart[0][k] * EmatD[k][l] * fracToCart[1][l];\n"
"                Exz += fracToCart[0][k] * EmatD[k][l] * fracToCart[2][l];\n"
"                Eyz += fracToCart[1][k] * EmatD[k][l] * fracToCart[2][l];\n"
"            }\n"
"        }\n"
"        atomicAdd(&fieldGradient[6*i+0], static_cast<unsigned long long>((long long) (-Exx*0x100000000)));\n"
"        atomicAdd(&fieldGradient[6*i+1], static_cast<unsigned long long>((long long) (-Eyy*0x100000000)));\n"
"        atomicAdd(&fieldGradient[6*i+2], static_cast<unsigned long long>((long long) (-Ezz*0x100000000)));\n"
"        atomicAdd(&fieldGradient[6*i+3], static_cast<unsigned long long>((long long) (-Exy*0x100000000)));\n"
"        atomicAdd(&fieldGradient[6*i+4], static_cast<unsigned long long>((long long) (-Exz*0x100000000)));\n"
"        atomicAdd(&fieldGradient[6*i+5], static_cast<unsigned long long>((long long) (-Eyz*0x100000000)));\n"
"\n"
"        real EmatP[3][3] = {\n"
"            {phip[i+NUM_ATOMS*4], phip[i+NUM_ATOMS*7], phip[i+NUM_ATOMS*8]},\n"
"            {phip[i+NUM_ATOMS*7], phip[i+NUM_ATOMS*5], phip[i+NUM_ATOMS*9]},\n"
"            {phip[i+NUM_ATOMS*8], phip[i+NUM_ATOMS*9], phip[i+NUM_ATOMS*6]}\n"
"        };\n"
"        Exx = 0; Eyy = 0; Ezz = 0; Exy = 0; Exz = 0; Eyz = 0;\n"
"        for (int k = 0; k < 3; ++k) {\n"
"            for (int l = 0; l < 3; ++l) {\n"
"                Exx += fracToCart[0][k] * EmatP[k][l] * fracToCart[0][l];\n"
"                Eyy += fracToCart[1][k] * EmatP[k][l] * fracToCart[1][l];\n"
"                Ezz += fracToCart[2][k] * EmatP[k][l] * fracToCart[2][l];\n"
"                Exy += fracToCart[0][k] * EmatP[k][l] * fracToCart[1][l];\n"
"                Exz += fracToCart[0][k] * EmatP[k][l] * fracToCart[2][l];\n"
"                Eyz += fracToCart[1][k] * EmatP[k][l] * fracToCart[2][l];\n"
"            }\n"
"        }\n"
"        atomicAdd(&fieldGradientPolar[6*i+0], static_cast<unsigned long long>((long long) (-Exx*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*i+1], static_cast<unsigned long long>((long long) (-Eyy*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*i+2], static_cast<unsigned long long>((long long) (-Ezz*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*i+3], static_cast<unsigned long long>((long long) (-Exy*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*i+4], static_cast<unsigned long long>((long long) (-Exz*0x100000000)));\n"
"        atomicAdd(&fieldGradientPolar[6*i+5], static_cast<unsigned long long>((long long) (-Eyz*0x100000000)));\n"
"#endif\n"
"    }\n"
"}\n"
"#endif";
