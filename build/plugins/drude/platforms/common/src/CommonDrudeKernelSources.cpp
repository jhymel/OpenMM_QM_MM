/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CommonDrudeKernelSources.h"

using namespace OpenMM;
using namespace std;

const string CommonDrudeKernelSources::drudeLangevin = "/**\n"
" * Perform the first step of Langevin integration.\n"
" */\n"
"\n"
"KERNEL void integrateDrudeLangevinPart1(GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL const int* RESTRICT normalParticles, GLOBAL const int2* RESTRICT pairParticles, GLOBAL const mixed2* RESTRICT dt, mixed vscale, mixed fscale,\n"
"        mixed noisescale, mixed vscaleDrude, mixed fscaleDrude, mixed noisescaleDrude, GLOBAL const float4* RESTRICT random, unsigned int randomIndex) {\n"
"    mixed stepSize = dt[0].y;\n"
"    \n"
"    // Update normal particles.\n"
"\n"
"    for (int i = GLOBAL_ID; i < NUM_NORMAL_PARTICLES; i += GLOBAL_SIZE) {\n"
"        int index = normalParticles[i];\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0) {\n"
"            mixed sqrtInvMass = SQRT(velocity.w);\n"
"            float4 rand = random[randomIndex+index];\n"
"            velocity.x = vscale*velocity.x + fscale*velocity.w*force[index] + noisescale*sqrtInvMass*rand.x;\n"
"            velocity.y = vscale*velocity.y + fscale*velocity.w*force[index+PADDED_NUM_ATOMS] + noisescale*sqrtInvMass*rand.y;\n"
"            velocity.z = vscale*velocity.z + fscale*velocity.w*force[index+PADDED_NUM_ATOMS*2] + noisescale*sqrtInvMass*rand.z;\n"
"            velm[index] = velocity;\n"
"            posDelta[index] = make_mixed4(stepSize*velocity.x, stepSize*velocity.y, stepSize*velocity.z, 0);\n"
"        }\n"
"    }\n"
"    \n"
"    // Update Drude particle pairs.\n"
"    \n"
"    randomIndex += NUM_NORMAL_PARTICLES;\n"
"    for (int i = GLOBAL_ID; i < NUM_PAIRS; i += GLOBAL_SIZE) {\n"
"        int2 particles = pairParticles[i];\n"
"        mixed4 velocity1 = velm[particles.x];\n"
"        mixed4 velocity2 = velm[particles.y];\n"
"        mixed mass1 = RECIP(velocity1.w);\n"
"        mixed mass2 = RECIP(velocity2.w);\n"
"        mixed invTotalMass = RECIP(mass1+mass2);\n"
"        mixed invReducedMass = (mass1+mass2)*velocity1.w*velocity2.w;\n"
"        mixed mass1fract = invTotalMass*mass1;\n"
"        mixed mass2fract = invTotalMass*mass2;\n"
"        mixed sqrtInvTotalMass = SQRT(invTotalMass);\n"
"        mixed sqrtInvReducedMass = SQRT(invReducedMass);\n"
"        mixed4 cmVel = velocity1*mass1fract+velocity2*mass2fract;\n"
"        mixed4 relVel = velocity2-velocity1;\n"
"        mixed3 force1 = make_mixed3(force[particles.x], force[particles.x+PADDED_NUM_ATOMS], force[particles.x+PADDED_NUM_ATOMS*2]);\n"
"        mixed3 force2 = make_mixed3(force[particles.y], force[particles.y+PADDED_NUM_ATOMS], force[particles.y+PADDED_NUM_ATOMS*2]);\n"
"        mixed3 cmForce = force1+force2;\n"
"        mixed3 relForce = force2*mass1fract - force1*mass2fract;\n"
"        float4 rand1 = random[randomIndex+2*i];\n"
"        float4 rand2 = random[randomIndex+2*i+1];\n"
"        cmVel.x = vscale*cmVel.x + fscale*invTotalMass*cmForce.x + noisescale*sqrtInvTotalMass*rand1.x;\n"
"        cmVel.y = vscale*cmVel.y + fscale*invTotalMass*cmForce.y + noisescale*sqrtInvTotalMass*rand1.y;\n"
"        cmVel.z = vscale*cmVel.z + fscale*invTotalMass*cmForce.z + noisescale*sqrtInvTotalMass*rand1.z;\n"
"        relVel.x = vscaleDrude*relVel.x + fscaleDrude*invReducedMass*relForce.x + noisescaleDrude*sqrtInvReducedMass*rand2.x;\n"
"        relVel.y = vscaleDrude*relVel.y + fscaleDrude*invReducedMass*relForce.y + noisescaleDrude*sqrtInvReducedMass*rand2.y;\n"
"        relVel.z = vscaleDrude*relVel.z + fscaleDrude*invReducedMass*relForce.z + noisescaleDrude*sqrtInvReducedMass*rand2.z;\n"
"        velocity1.x = cmVel.x-relVel.x*mass2fract;\n"
"        velocity1.y = cmVel.y-relVel.y*mass2fract;\n"
"        velocity1.z = cmVel.z-relVel.z*mass2fract;\n"
"        velocity2.x = cmVel.x+relVel.x*mass1fract;\n"
"        velocity2.y = cmVel.y+relVel.y*mass1fract;\n"
"        velocity2.z = cmVel.z+relVel.z*mass1fract;\n"
"        velm[particles.x] = velocity1;\n"
"        velm[particles.y] = velocity2;\n"
"        posDelta[particles.x] = make_mixed4(stepSize*velocity1.x, stepSize*velocity1.y, stepSize*velocity1.z, 0);\n"
"        posDelta[particles.y] = make_mixed4(stepSize*velocity2.x, stepSize*velocity2.y, stepSize*velocity2.z, 0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Langevin integration.\n"
" */\n"
"\n"
"KERNEL void integrateDrudeLangevinPart2(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, GLOBAL const mixed4* RESTRICT posDelta, GLOBAL mixed4* RESTRICT velm, GLOBAL const mixed2* RESTRICT dt) {\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    double invStepSize = 1.0/dt[0].y;\n"
"#else\n"
"    float invStepSize = 1.0f/dt[0].y;\n"
"#endif\n"
"    int index = GLOBAL_ID;\n"
"    while (index < NUM_ATOMS) {\n"
"        mixed4 vel = velm[index];\n"
"        if (vel.w != 0) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            mixed4 delta = posDelta[index];\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"            vel.x = (mixed) (invStepSize*delta.x);\n"
"            vel.y = (mixed) (invStepSize*delta.y);\n"
"            vel.z = (mixed) (invStepSize*delta.z);\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"            velm[index] = vel;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Apply hard wall constraints\n"
" */\n"
"KERNEL void applyHardWallConstraints(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, GLOBAL mixed4* RESTRICT velm,\n"
"        GLOBAL const int2* RESTRICT pairParticles, GLOBAL const mixed2* RESTRICT dt, mixed maxDrudeDistance, mixed hardwallscaleDrude) {\n"
"    mixed stepSize = dt[0].y;\n"
"    for (int i = GLOBAL_ID; i < NUM_PAIRS; i += GLOBAL_SIZE) {\n"
"        int2 particles = pairParticles[i];\n"
"#ifdef USE_MIXED_PRECISION\n"
"        real4 posReal1 = posq[particles.x];\n"
"        real4 posReal2 = posq[particles.y];\n"
"        real4 posCorr1 = posqCorrection[particles.x];\n"
"        real4 posCorr2 = posqCorrection[particles.y];\n"
"        mixed4 pos1 = make_mixed4(posReal1.x+(mixed)posCorr1.x, posReal1.y+(mixed)posCorr1.y, posReal1.z+(mixed)posCorr1.z, posReal1.w);\n"
"        mixed4 pos2 = make_mixed4(posReal2.x+(mixed)posCorr2.x, posReal2.y+(mixed)posCorr2.y, posReal2.z+(mixed)posCorr2.z, posReal2.w);\n"
"#else\n"
"        mixed4 pos1 = posq[particles.x];\n"
"        mixed4 pos2 = posq[particles.y];\n"
"#endif\n"
"        mixed4 delta = pos1-pos2;\n"
"        mixed r = SQRT(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"        mixed rInv = RECIP(r);\n"
"        if (rInv*maxDrudeDistance < 1) {\n"
"            // The constraint has been violated, so make the inter-particle distance \"bounce\"\n"
"            // off the hard wall.\n"
"\n"
"            mixed4 bondDir = delta*rInv;\n"
"            mixed4 vel1 = velm[particles.x];\n"
"            mixed4 vel2 = velm[particles.y];\n"
"            mixed mass1 = RECIP(vel1.w);\n"
"            mixed mass2 = RECIP(vel2.w);\n"
"            mixed deltaR = r-maxDrudeDistance;\n"
"            mixed deltaT = stepSize;\n"
"            mixed dotvr1 = vel1.x*bondDir.x + vel1.y*bondDir.y + vel1.z*bondDir.z;\n"
"            mixed4 vb1 = bondDir*dotvr1;\n"
"            mixed4 vp1 = vel1-vb1;\n"
"            if (vel2.w == 0) {\n"
"                // The parent particle is massless, so move only the Drude particle.\n"
"\n"
"                if (dotvr1 != 0)\n"
"                    deltaT = deltaR/fabs(dotvr1);\n"
"                if (deltaT > stepSize)\n"
"                    deltaT = stepSize;\n"
"                dotvr1 = -dotvr1*hardwallscaleDrude/(fabs(dotvr1)*SQRT(mass1));\n"
"                mixed dr = -deltaR + deltaT*dotvr1;\n"
"                pos1.x += bondDir.x*dr;\n"
"                pos1.y += bondDir.y*dr;\n"
"                pos1.z += bondDir.z*dr;\n"
"#ifdef USE_MIXED_PRECISION\n"
"                posq[particles.x] = make_real4((real) pos1.x, (real) pos1.y, (real) pos1.z, (real) pos1.w);\n"
"                posqCorrection[particles.x] = make_real4(pos1.x-(real) pos1.x, pos1.y-(real) pos1.y, pos1.z-(real) pos1.z, 0);\n"
"#else\n"
"                posq[particles.x] = pos1;\n"
"#endif\n"
"                vel1.x = vp1.x + bondDir.x*dotvr1;\n"
"                vel1.y = vp1.y + bondDir.y*dotvr1;\n"
"                vel1.z = vp1.z + bondDir.z*dotvr1;\n"
"                velm[particles.x] = vel1;\n"
"            }\n"
"            else {\n"
"                // Move both particles.\n"
"\n"
"                mixed invTotalMass = RECIP(mass1+mass2);\n"
"                mixed dotvr2 = vel2.x*bondDir.x + vel2.y*bondDir.y + vel2.z*bondDir.z;\n"
"                mixed4 vb2 = bondDir*dotvr2;\n"
"                mixed4 vp2 = vel2-vb2;\n"
"                mixed vbCMass = (mass1*dotvr1 + mass2*dotvr2)*invTotalMass;\n"
"                dotvr1 -= vbCMass;\n"
"                dotvr2 -= vbCMass;\n"
"                if (dotvr1 != dotvr2)\n"
"                    deltaT = deltaR/fabs(dotvr1-dotvr2);\n"
"                if (deltaT > stepSize)\n"
"                    deltaT = stepSize;\n"
"                mixed vBond = hardwallscaleDrude/SQRT(mass1);\n"
"                dotvr1 = -dotvr1*vBond*mass2*invTotalMass/fabs(dotvr1);\n"
"                dotvr2 = -dotvr2*vBond*mass1*invTotalMass/fabs(dotvr2);\n"
"                mixed dr1 = -deltaR*mass2*invTotalMass + deltaT*dotvr1;\n"
"                mixed dr2 = deltaR*mass1*invTotalMass + deltaT*dotvr2;\n"
"                dotvr1 += vbCMass;\n"
"                dotvr2 += vbCMass;\n"
"                pos1.x += bondDir.x*dr1;\n"
"                pos1.y += bondDir.y*dr1;\n"
"                pos1.z += bondDir.z*dr1;\n"
"                pos2.x += bondDir.x*dr2;\n"
"                pos2.y += bondDir.y*dr2;\n"
"                pos2.z += bondDir.z*dr2;\n"
"#ifdef USE_MIXED_PRECISION\n"
"                posq[particles.x] = make_real4((real) pos1.x, (real) pos1.y, (real) pos1.z, (real) pos1.w);\n"
"                posq[particles.y] = make_real4((real) pos2.x, (real) pos2.y, (real) pos2.z, (real) pos2.w);\n"
"                posqCorrection[particles.x] = make_real4(pos1.x-(real) pos1.x, pos1.y-(real) pos1.y, pos1.z-(real) pos1.z, 0);\n"
"                posqCorrection[particles.y] = make_real4(pos2.x-(real) pos2.x, pos2.y-(real) pos2.y, pos2.z-(real) pos2.z, 0);\n"
"#else\n"
"                posq[particles.x] = pos1;\n"
"                posq[particles.y] = pos2;\n"
"#endif\n"
"                vel1.x = vp1.x + bondDir.x*dotvr1;\n"
"                vel1.y = vp1.y + bondDir.y*dotvr1;\n"
"                vel1.z = vp1.z + bondDir.z*dotvr1;\n"
"                vel2.x = vp2.x + bondDir.x*dotvr2;\n"
"                vel2.y = vp2.y + bondDir.y*dotvr2;\n"
"                vel2.z = vp2.z + bondDir.z*dotvr2;\n"
"                velm[particles.x] = vel1;\n"
"                velm[particles.y] = vel2;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonDrudeKernelSources::drudePairForce = "float2 drudeParams = PARAMS[index];\n"
"real3 force1 = make_real3(0);\n"
"real3 force2 = make_real3(0);\n"
"real3 force3 = make_real3(0);\n"
"real3 force4 = make_real3(0);\n"
"\n"
"// First pair.\n"
"\n"
"real3 delta = make_real3(pos1.x-pos3.x, pos1.y-pos3.y, pos1.z-pos3.z);\n"
"real rInv = RSQRT(dot(delta, delta));\n"
"real r = RECIP(rInv);\n"
"real u = drudeParams.x*r;\n"
"real screening = 1-(1+0.5f*u)*EXP(-u);\n"
"real pairEnergy = drudeParams.y*screening*rInv;\n"
"energy += pairEnergy;\n"
"real3 f = delta*(drudeParams.y*rInv*rInv*(screening*rInv-0.5f*(1+u)*EXP(-u)*drudeParams.x));\n"
"force1 += f;\n"
"force3 -= f;\n"
"\n"
"// Second pair.\n"
"\n"
"delta = make_real3(pos1.x-pos4.x, pos1.y-pos4.y, pos1.z-pos4.z);\n"
"rInv = RSQRT(dot(delta, delta));\n"
"r = RECIP(rInv);\n"
"u = drudeParams.x*r;\n"
"screening = 1-(1+0.5f*u)*EXP(-u);\n"
"pairEnergy = -drudeParams.y*screening*rInv;\n"
"energy += pairEnergy;\n"
"f = delta*(-drudeParams.y*rInv*rInv*(screening*rInv-0.5f*(1+u)*EXP(-u)*drudeParams.x));\n"
"force1 += f;\n"
"force4 -= f;\n"
"\n"
"// Third pair.\n"
"\n"
"delta = make_real3(pos2.x-pos3.x, pos2.y-pos3.y, pos2.z-pos3.z);\n"
"rInv = RSQRT(dot(delta, delta));\n"
"r = RECIP(rInv);\n"
"u = drudeParams.x*r;\n"
"screening = 1-(1+0.5f*u)*EXP(-u);\n"
"pairEnergy = -drudeParams.y*screening*rInv;\n"
"energy += pairEnergy;\n"
"f = delta*(-drudeParams.y*rInv*rInv*(screening*rInv-0.5f*(1+u)*EXP(-u)*drudeParams.x));\n"
"force2 += f;\n"
"force3 -= f;\n"
"\n"
"// Fourth pair.\n"
"\n"
"delta = make_real3(pos2.x-pos4.x, pos2.y-pos4.y, pos2.z-pos4.z);\n"
"rInv = RSQRT(dot(delta, delta));\n"
"r = RECIP(rInv);\n"
"u = drudeParams.x*r;\n"
"screening = 1-(1+0.5f*u)*EXP(-u);\n"
"pairEnergy = drudeParams.y*screening*rInv;\n"
"energy += pairEnergy;\n"
"f = delta*(drudeParams.y*rInv*rInv*(screening*rInv-0.5f*(1+u)*EXP(-u)*drudeParams.x));\n"
"force2 += f;\n"
"force4 -= f;\n"
"";
const string CommonDrudeKernelSources::drudeParticleForce = "real3 delta = make_real3(pos1.x-pos2.x, pos1.y-pos2.y, pos1.z-pos2.z);\n"
"real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"float4 drudeParams = PARAMS[index];\n"
"float k1 = drudeParams.x;\n"
"float k2 = drudeParams.y;\n"
"float k3 = drudeParams.z;\n"
"\n"
"// Compute the isotropic force.\n"
"\n"
"energy += 0.5f*k3*r2;\n"
"real3 force1 = -delta*k3;\n"
"real3 force2 = delta*k3;\n"
"real3 force3 = make_real3(0);\n"
"real3 force4 = make_real3(0);\n"
"real3 force5 = make_real3(0);\n"
"\n"
"// Compute the first anisotropic force.\n"
"\n"
"if (k1 != 0) {\n"
"    real3 dir = make_real3(pos2.x-pos3.x, pos2.y-pos3.y, pos2.z-pos3.z);\n"
"    real invDist = RSQRT(dot(dir, dir));\n"
"    dir *= invDist;\n"
"    real rprime = dot(dir, delta);\n"
"    energy += 0.5f*k1*rprime*rprime;\n"
"    real3 f1 = dir*(k1*rprime); \n"
"    real3 f2 = (delta-dir*rprime)*(k1*rprime*invDist);\n"
"    force1 -= f1;\n"
"    force2 += f1-f2;\n"
"    force3 += f2;\n"
"}\n"
"\n"
"// Compute the second anisotropic force.\n"
"\n"
"if (k2 != 0) {\n"
"    real3 dir = make_real3(pos4.x-pos5.x, pos4.y-pos5.y, pos4.z-pos5.z);\n"
"    real invDist = RSQRT(dot(dir, dir));\n"
"    dir *= invDist;\n"
"    real rprime = dot(dir, delta);\n"
"    energy += 0.5f*k2*rprime*rprime;\n"
"    real3 f1 = dir*(k2*rprime);\n"
"    real3 f2 = (delta-dir*rprime)*(k2*rprime*invDist);\n"
"    force1 -= f1;\n"
"    force2 += f1;\n"
"    force4 -= f2;\n"
"    force5 += f2;\n"
"}\n"
"";
