/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "OpenCLKernelSources.h"

using namespace OpenMM;
using namespace std;

const string OpenCLKernelSources::common = "/**\n"
" * This file contains OpenCL definitions for the macros and functions needed for the\n"
" * common compute framework.\n"
" */\n"
"\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"#define KERNEL __kernel\n"
"#define DEVICE\n"
"#define LOCAL __local\n"
"#define LOCAL_ARG __local\n"
"#define GLOBAL __global\n"
"#define RESTRICT restrict\n"
"#define LOCAL_ID get_local_id(0)\n"
"#define LOCAL_SIZE get_local_size(0)\n"
"#define GLOBAL_ID get_global_id(0)\n"
"#define GLOBAL_SIZE get_global_size(0)\n"
"#define GROUP_ID get_group_id(0)\n"
"#define NUM_GROUPS get_num_groups(0)\n"
"#define SYNC_THREADS barrier(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);\n"
"#define MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);\n"
"#define ATOMIC_ADD(dest, value) atom_add(dest, value)\n"
"\n"
"typedef long mm_long;\n"
"typedef unsigned long mm_ulong;\n"
"\n"
"#define make_short2(x...) ((short2) (x))\n"
"#define make_short3(x...) ((short3) (x))\n"
"#define make_short4(x...) ((short4) (x))\n"
"#define make_int2(x...) ((int2) (x))\n"
"#define make_int3(x...) ((int3) (x))\n"
"#define make_int4(x...) ((int4) (x))\n"
"#define make_float2(x...) ((float2) (x))\n"
"#define make_float3(x...) ((float3) (x))\n"
"#define make_float4(x...) ((float4) (x))\n"
"#define make_double2(x...) ((double2) (x))\n"
"#define make_double3(x...) ((double3) (x))\n"
"#define make_double4(x...) ((double4) (x))\n"
"\n"
"#define trimTo3(v) (v).xyz\n"
"\n"
"// OpenCL has overloaded versions of standard math functions for single and double\n"
"// precision arguments.  CUDA has separate functions.  To allow them to be called\n"
"// consistently, we define the \"single precision\" functions to just be synonyms\n"
"// for the standard ones.\n"
"\n"
"#define sqrtf(x) sqrt(x)\n"
"#define rsqrtf(x) rsqrt(x)\n"
"#define expf(x) exp(x)\n"
"#define logf(x) log(x)\n"
"#define powf(x) pow(x)\n"
"#define cosf(x) cos(x)\n"
"#define sinf(x) sin(x)\n"
"#define tanf(x) tan(x)\n"
"#define acosf(x) acos(x)\n"
"#define asinf(x) asin(x)\n"
"#define atanf(x) atan(x)\n"
"#define atan2f(x, y) atan2(x, y)\n"
"";
const string OpenCLKernelSources::compact = "/* Code for CUDA stream compaction. Roughly based on:\n"
"    Billeter M, Olsson O, Assarsson U. Efficient Stream Compaction on Wide SIMD Many-Core Architectures.\n"
"        High Performance Graphics 2009.\n"
"\n"
"    Notes:\n"
"        - paper recommends 128 threads/block, so this is hard coded.\n"
"        - I only implement the prefix-sum based compact primitive, and not the POPC one, as that is more\n"
"          complicated and performs poorly on current hardware\n"
"        - I only implement the scattered- and staged-write variant of phase III as it they have reasonable\n"
"          performance across most of the tested workloads in the paper. The selective variant is not\n"
"          implemented.\n"
"        - The prefix sum of per-block element counts (phase II) is not done in a particularly efficient\n"
"          manner. It is, however, done in a very easy to program manner, and integrated into the top of\n"
"          phase III, reducing the number of kernel invocations required. If one wanted to use existing code,\n"
"          it'd be easy to take the CUDA SDK scanLargeArray sample, and do a prefix sum over dgBlockCounts in\n"
"          a phase II kernel. You could also adapt the existing prescan128 to take an initial value, and scan\n"
"          dgBlockCounts in stages.\n"
"\n"
"  Date:         23 Aug 2009\n"
"  Author:       CUDA version by Imran Haque (ihaque@cs.stanford.edu), converted to OpenCL by Peter Eastman\n"
"  Affiliation:  Stanford University\n"
"  License:      Public Domain\n"
"*/\n"
"\n"
"// Phase 1: Count valid elements per thread block\n"
"// Hard-code 128 thd/blk\n"
"unsigned int sumReduce128(__local unsigned int* arr) {\n"
"    // Parallel reduce element counts\n"
"    // Assumes 128 thd/block\n"
"    int thread = get_local_id(0);\n"
"    if (thread < 64) arr[thread] += arr[thread+64];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"    if (thread < 32) {\n"
"        arr[thread] += arr[thread+32];\n"
"        if (thread < 16) arr[thread] += arr[thread+16];\n"
"        if (thread < 8) arr[thread] += arr[thread+8];\n"
"        if (thread < 4) arr[thread] += arr[thread+4];\n"
"        if (thread < 2) arr[thread] += arr[thread+2];\n"
"        if (thread < 1) arr[thread] += arr[thread+1];\n"
"    }\n"
"#else\n"
"    if (thread < 32) arr[thread] += arr[thread+32];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 16) arr[thread] += arr[thread+16];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 8) arr[thread] += arr[thread+8];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 4) arr[thread] += arr[thread+4];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 2) arr[thread] += arr[thread+2];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 1) arr[thread] += arr[thread+1];\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return arr[0];\n"
"}\n"
"\n"
"__kernel void countElts(__global unsigned int* restrict dgBlockCounts, __global const unsigned int* restrict dgValid, const unsigned int len, __local unsigned int* restrict dsCount) {\n"
"    dsCount[get_local_id(0)] = 0;\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub && dgValid[base+get_local_id(0)])\n"
"            dsCount[get_local_id(0)]++;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    unsigned int blockCount = sumReduce128(dsCount);\n"
"    if (get_local_id(0) == 0) dgBlockCounts[get_group_id(0)] = blockCount;\n"
"    return;\n"
"}\n"
"\n"
"// Phase 2/3: Move valid elements using SIMD compaction (phase 2 is done implicitly at top of __global__ method)\n"
"// Exclusive prefix scan over 128 elements\n"
"// Assumes 128 threads\n"
"// Taken from cuda SDK \"scan\" sample for naive scan, with small modifications\n"
"int exclusivePrescan128(__local const unsigned int* in, __local unsigned int* outAndTemp) {\n"
"    const int n=128;\n"
"    //TODO: this temp storage could be reduced since we write to shared memory in out anyway, and n is hardcoded\n"
"    //__shared__ int temp[2*n];\n"
"    __local unsigned int* temp = outAndTemp;\n"
"    int pout = 1, pin = 0;\n"
"\n"
"    // load input into temp\n"
"    // This is exclusive scan, so shift right by one and set first elt to 0\n"
"    int thread = get_local_id(0);\n"
"    temp[pout*n + get_local_id(0)] = (get_local_id(0) > 0) ? in[get_local_id(0)-1] : 0;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    for (int offset = 1; offset < n; offset *= 2)\n"
"    {\n"
"        pout = 1 - pout; // swap double buffer indices\n"
"        pin  = 1 - pout;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        temp[pout*n+get_local_id(0)] = temp[pin*n+get_local_id(0)];\n"
"        if (get_local_id(0) >= offset)\n"
"            temp[pout*n+get_local_id(0)] += temp[pin*n+get_local_id(0) - offset];\n"
"    }\n"
"\n"
"    //out[get_local_id(0)] = temp[pout*n+get_local_id(0)]; // write output\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return outAndTemp[127]+in[127]; // Return sum of all elements\n"
"}\n"
"\n"
"int compactSIMDPrefixSum(__local const unsigned int* dsData, __local const unsigned int* dsValid, __local unsigned int* dsCompact, __local unsigned int* dsLocalIndex) {\n"
"    int numValid = exclusivePrescan128(dsValid,dsLocalIndex);\n"
"    int thread = get_local_id(0);\n"
"    if (dsValid[get_local_id(0)]) dsCompact[dsLocalIndex[get_local_id(0)]] = dsData[get_local_id(0)];\n"
"    return numValid;\n"
"}\n"
"\n"
"__kernel void moveValidElementsStaged(__global const unsigned int* restrict dgData, __global unsigned int* restrict dgCompact, __global const unsigned int* restrict dgValid,\n"
"            __global const unsigned int* restrict dgBlockCounts, unsigned int len, __global unsigned int* restrict dNumValidElements,\n"
"            __local unsigned int* restrict inBlock, __local unsigned int* restrict validBlock, __local unsigned int* restrict compactBlock) {\n"
"    __local unsigned int dsLocalIndex[256];\n"
"    int blockOutOffset=0;\n"
"    // Sum up the blockCounts before us to find our offset\n"
"    // This is totally inefficient - lots of repeated work b/w blocks, and uneven balancing.\n"
"    // Paper implements this as a prefix sum kernel in phase II\n"
"    // May still be faster than an extra kernel invocation?\n"
"    int thread = get_local_id(0);\n"
"    for (int base = 0; base < get_group_id(0); base += get_local_size(0)) {\n"
"        // Load up the count of valid elements for each block before us in batches of 128\n"
"        if ((base + get_local_id(0)) < get_group_id(0)) {\n"
"            validBlock[get_local_id(0)] = dgBlockCounts[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        // Parallel reduce these counts\n"
"        // Accumulate in the final offset variable\n"
"        blockOutOffset += sumReduce128(validBlock);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub) {\n"
"            validBlock[get_local_id(0)] = dgValid[base+get_local_id(0)];\n"
"            inBlock[get_local_id(0)] = dgData[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        int numValidBlock = compactSIMDPrefixSum(inBlock,validBlock,compactBlock,dsLocalIndex);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < numValidBlock) {\n"
"            dgCompact[blockOutOffset + get_local_id(0)] = compactBlock[get_local_id(0)];\n"
"        }\n"
"        blockOutOffset += numValidBlock;\n"
"    }\n"
"    if (get_group_id(0) == (get_num_groups(0)-1) && get_local_id(0) == 0) {\n"
"        *dNumValidElements = blockOutOffset;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::fft = "real2 multiplyComplex(real2 c1, real2 c2) {\n"
"    return (real2) (c1.x*c2.x-c1.y*c2.y, c1.x*c2.y+c1.y*c2.x);\n"
"}\n"
"\n"
"/**\n"
" * Load a value from the half-complex grid produces by a real-to-complex transform.\n"
" */\n"
"real2 loadComplexValue(__global const real2* restrict in, int x, int y, int z) {\n"
"    const int inputZSize = ZSIZE/2+1;\n"
"    if (z < inputZSize)\n"
"        return in[x*YSIZE*inputZSize+y*inputZSize+z];\n"
"    int xp = (x == 0 ? 0 : XSIZE-x);\n"
"    int yp = (y == 0 ? 0 : YSIZE-y);\n"
"    real2 value = in[xp*YSIZE*inputZSize+yp*inputZSize+(ZSIZE-z)];\n"
"    return (real2) (value.x, -value.y);\n"
"}\n"
"\n"
"/**\n"
" * Perform a 1D FFT on each row along one axis.\n"
" */\n"
"\n"
"__kernel void execFFT(__global const INPUT_TYPE* restrict in, __global OUTPUT_TYPE* restrict out, __local real2* restrict w,\n"
"        __local real2* restrict data0, __local real2* restrict data1) {\n"
"    for (int i = get_local_id(0); i < ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(-(SIGN)*i*2*M_PI/ZSIZE), sin(-(SIGN)*i*2*M_PI/ZSIZE));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    for (int baseIndex = get_group_id(0)*BLOCKS_PER_GROUP; baseIndex < XSIZE*YSIZE; baseIndex += get_num_groups(0)*BLOCKS_PER_GROUP) {\n"
"        int index = baseIndex+get_local_id(0)/ZSIZE;\n"
"        int x = index/YSIZE;\n"
"        int y = index-x*YSIZE;\n"
"#if OUTPUT_IS_PACKED\n"
"        if (x < XSIZE/2+1) {\n"
"#endif\n"
"#if LOOP_REQUIRED\n"
"        for (int z = get_local_id(0); z < ZSIZE; z += get_local_size(0))\n"
"    #if INPUT_IS_REAL\n"
"            data0[z] = (real2) (in[x*(YSIZE*ZSIZE)+y*ZSIZE+z], 0);\n"
"    #elif INPUT_IS_PACKED\n"
"            data0[z] = loadComplexValue(in, x, y, z);\n"
"    #else\n"
"            data0[z] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+z];\n"
"    #endif\n"
"#else\n"
"        if (index < XSIZE*YSIZE)\n"
"    #if INPUT_IS_REAL\n"
"            data0[get_local_id(0)] = (real2) (in[x*(YSIZE*ZSIZE)+y*ZSIZE+get_local_id(0)%ZSIZE], 0);\n"
"    #elif INPUT_IS_PACKED\n"
"            data0[get_local_id(0)] = loadComplexValue(in, x, y, get_local_id(0)%ZSIZE);\n"
"    #else\n"
"            data0[get_local_id(0)] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+get_local_id(0)%ZSIZE];\n"
"    #endif\n"
"#endif\n"
"#if OUTPUT_IS_PACKED\n"
"        }\n"
"#endif\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        COMPUTE_FFT\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::fftR2C = "/**\n"
" * Combine the two halves of a real grid into a complex grid that is half as large.\n"
" */\n"
"__kernel void packForwardData(__global const real* restrict in, __global real2* restrict out) {\n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"#if PACKED_AXIS == 0\n"
"        real2 value = (real2) (in[2*x*YSIZE*ZSIZE+y*ZSIZE+z], in[(2*x+1)*YSIZE*ZSIZE+y*ZSIZE+z]);\n"
"#elif PACKED_AXIS == 1\n"
"        real2 value = (real2) (in[x*YSIZE*ZSIZE+2*y*ZSIZE+z], in[x*YSIZE*ZSIZE+(2*y+1)*ZSIZE+z]);\n"
"#else\n"
"        real2 value = (real2) (in[x*YSIZE*ZSIZE+y*ZSIZE+2*z], in[x*YSIZE*ZSIZE+y*ZSIZE+(2*z+1)]);\n"
"#endif\n"
"        out[index] = value;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Split the transformed data back into a full sized, symmetric grid.\n"
" */\n"
"__kernel void unpackForwardData(__global const real2* restrict in, __global real2* restrict out, __local real2* restrict w) {\n"
"    // Compute the phase factors.\n"
"    \n"
"#if PACKED_AXIS == 0\n"
"    for (int i = get_local_id(0); i < PACKED_XSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/XSIZE), cos(i*2*M_PI/XSIZE));\n"
"#elif PACKED_AXIS == 1\n"
"    for (int i = get_local_id(0); i < PACKED_YSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/YSIZE), cos(i*2*M_PI/YSIZE));\n"
"#else\n"
"    for (int i = get_local_id(0); i < PACKED_ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/ZSIZE), cos(i*2*M_PI/ZSIZE));\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Transform the data.\n"
"    \n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    const int outputZSize = ZSIZE/2+1;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        int xp = (x == 0 ? 0 : PACKED_XSIZE-x);\n"
"        int yp = (y == 0 ? 0 : PACKED_YSIZE-y);\n"
"        int zp = (z == 0 ? 0 : PACKED_ZSIZE-z);\n"
"        real2 z1 = in[x*PACKED_YSIZE*PACKED_ZSIZE+y*PACKED_ZSIZE+z];\n"
"        real2 z2 = in[xp*PACKED_YSIZE*PACKED_ZSIZE+yp*PACKED_ZSIZE+zp];\n"
"#if PACKED_AXIS == 0\n"
"        real2 wfac = w[x];\n"
"#elif PACKED_AXIS == 1\n"
"        real2 wfac = w[y];\n"
"#else\n"
"        real2 wfac = w[z];\n"
"#endif\n"
"        real2 output = (real2) ((z1.x+z2.x - wfac.x*(z1.x-z2.x) + wfac.y*(z1.y+z2.y))/2, (z1.y-z2.y - wfac.y*(z1.x-z2.x) - wfac.x*(z1.y+z2.y))/2);\n"
"        if (z < outputZSize)\n"
"            out[x*YSIZE*outputZSize+y*outputZSize+z] = output;\n"
"        xp = (x == 0 ? 0 : XSIZE-x);\n"
"        yp = (y == 0 ? 0 : YSIZE-y);\n"
"        zp = (z == 0 ? 0 : ZSIZE-z);\n"
"        if (zp < outputZSize) {\n"
"#if PACKED_AXIS == 0\n"
"            if (x == 0)\n"
"                out[PACKED_XSIZE*YSIZE*outputZSize+yp*outputZSize+zp] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#elif PACKED_AXIS == 1\n"
"            if (y == 0)\n"
"                out[xp*YSIZE*outputZSize+PACKED_YSIZE*outputZSize+zp] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#else\n"
"            if (z == 0)\n"
"                out[xp*YSIZE*outputZSize+yp*outputZSize+PACKED_ZSIZE] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#endif\n"
"            else\n"
"                out[xp*YSIZE*outputZSize+yp*outputZSize+zp] = (real2) (output.x, -output.y);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Load a value from the half-complex grid produced by a real-to-complex transform.\n"
" */\n"
"real2 loadComplexValue(__global const real2* restrict in, int x, int y, int z) {\n"
"    const int inputZSize = ZSIZE/2+1;\n"
"    if (z < inputZSize)\n"
"        return in[x*YSIZE*inputZSize+y*inputZSize+z];\n"
"    int xp = (x == 0 ? 0 : XSIZE-x);\n"
"    int yp = (y == 0 ? 0 : YSIZE-y);\n"
"    real2 value = in[xp*YSIZE*inputZSize+yp*inputZSize+(ZSIZE-z)];\n"
"    return (real2) (value.x, -value.y);\n"
"}\n"
"\n"
"/**\n"
" * Repack the symmetric complex grid into one half as large in preparation for doing an inverse complex-to-real transform.\n"
" */\n"
"__kernel void packBackwardData(__global const real2* restrict in, __global real2* restrict out, __local real2* restrict w) {\n"
"    // Compute the phase factors.\n"
"    \n"
"#if PACKED_AXIS == 0\n"
"    for (int i = get_local_id(0); i < PACKED_XSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/XSIZE), sin(i*2*M_PI/XSIZE));\n"
"#elif PACKED_AXIS == 1\n"
"    for (int i = get_local_id(0); i < PACKED_YSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/YSIZE), sin(i*2*M_PI/YSIZE));\n"
"#else\n"
"    for (int i = get_local_id(0); i < PACKED_ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/ZSIZE), sin(i*2*M_PI/ZSIZE));\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Transform the data.\n"
"    \n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        int xp = (x == 0 ? 0 : PACKED_XSIZE-x);\n"
"        int yp = (y == 0 ? 0 : PACKED_YSIZE-y);\n"
"        int zp = (z == 0 ? 0 : PACKED_ZSIZE-z);\n"
"        real2 z1 = loadComplexValue(in, x, y, z);\n"
"#if PACKED_AXIS == 0\n"
"        real2 wfac = w[x];\n"
"        real2 z2 = loadComplexValue(in, PACKED_XSIZE-x, yp, zp);\n"
"#elif PACKED_AXIS == 1\n"
"        real2 wfac = w[y];\n"
"        real2 z2 = loadComplexValue(in, xp, PACKED_YSIZE-y, zp);\n"
"#else\n"
"        real2 wfac = w[z];\n"
"        real2 z2 = loadComplexValue(in, xp, yp, PACKED_ZSIZE-z);\n"
"#endif\n"
"        real2 even = (real2) ((z1.x+z2.x)/2, (z1.y-z2.y)/2);\n"
"        real2 odd = (real2) ((z1.x-z2.x)/2, (z1.y+z2.y)/2);\n"
"        odd = (real2) (odd.x*wfac.x-odd.y*wfac.y, odd.y*wfac.x+odd.x*wfac.y);\n"
"        out[x*PACKED_YSIZE*PACKED_ZSIZE+y*PACKED_ZSIZE+z] = (real2) (even.x-odd.y, even.y+odd.x);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Split the data back into a full sized, real grid after an inverse transform.\n"
" */\n"
"__kernel void unpackBackwardData(__global const real2* restrict in, __global real* restrict out) {\n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        real2 value = 2*in[index];\n"
"#if PACKED_AXIS == 0\n"
"        out[2*x*YSIZE*ZSIZE+y*ZSIZE+z] = value.x;\n"
"        out[(2*x+1)*YSIZE*ZSIZE+y*ZSIZE+z] = value.y;\n"
"#elif PACKED_AXIS == 1\n"
"        out[x*YSIZE*ZSIZE+2*y*ZSIZE+z] = value.x;\n"
"        out[x*YSIZE*ZSIZE+(2*y+1)*ZSIZE+z] = value.y;\n"
"#else\n"
"        out[x*YSIZE*ZSIZE+y*ZSIZE+2*z] = value.x;\n"
"        out[x*YSIZE*ZSIZE+y*ZSIZE+(2*z+1)] = value.y;\n"
"#endif\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::findInteractingBlocks = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global const real4* restrict posq, __global real4* restrict blockCenter, __global real4* restrict blockBoundingBox, __global int* restrict rebuildNeighborList,\n"
"        __global real2* restrict sortedBlocks) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        real4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        real4 center = 0.5f*(maxPos+minPos);\n"
"        center.w = 0;\n"
"        for (int i = base; i < last; i++) {\n"
"            pos = posq[i];\n"
"            real4 delta = posq[i]-center;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            center.w = max(center.w, delta.x*delta.x+delta.y*delta.y+delta.z*delta.z);\n"
"        }\n"
"        center.w = sqrt(center.w);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = center;\n"
"        sortedBlocks[index] = (real2) (blockSize.x+blockSize.y+blockSize.z, index);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        rebuildNeighborList[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Sort the data about bounding boxes so it can be accessed more efficiently in the next kernel.\n"
" */\n"
"__kernel void sortBoxData(__global const real2* restrict sortedBlock, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockBoundingBox, __global real4* restrict sortedBlockCenter,\n"
"        __global real4* restrict sortedBlockBoundingBox, __global const real4* restrict posq, __global const real4* restrict oldPositions,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict rebuildNeighborList, int forceRebuild) {\n"
"    for (int i = get_global_id(0); i < NUM_BLOCKS; i += get_global_size(0)) {\n"
"        int index = (int) sortedBlock[i].y;\n"
"        sortedBlockCenter[i] = blockCenter[index];\n"
"        sortedBlockBoundingBox[i] = blockBoundingBox[index];\n"
"    }\n"
"    \n"
"    // Also check whether any atom has moved enough so that we really need to rebuild the neighbor list.\n"
"\n"
"    bool rebuild = forceRebuild;\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        real4 delta = oldPositions[i]-posq[i];\n"
"        if (delta.x*delta.x + delta.y*delta.y + delta.z*delta.z > 0.25f*PADDING*PADDING)\n"
"            rebuild = true;\n"
"    }\n"
"    if (rebuild) {\n"
"        rebuildNeighborList[0] = 1;\n"
"        interactionCount[0] = 0;\n"
"    }\n"
"}\n"
"\n"
"#if SIMD_WIDTH <= 32\n"
"\n"
"#define BUFFER_SIZE 256\n"
"\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"\n"
"    const int indexInWarp = get_local_id(0)%32;\n"
"    const int warpStart = get_local_id(0)-indexInWarp;\n"
"    const int totalWarps = get_global_size(0)/32;\n"
"    const int warpIndex = get_global_id(0)/32;\n"
"    const int warpMask = (1<<indexInWarp)-1;\n"
"    __local int workgroupBuffer[BUFFER_SIZE*(GROUP_SIZE/32)];\n"
"    __local int warpExclusions[MAX_EXCLUSIONS*(GROUP_SIZE/32)];\n"
"    __local real3 posBuffer[GROUP_SIZE];\n"
"    __local volatile int workgroupTileIndex[GROUP_SIZE/32];\n"
"    __local bool includeBlockFlags[GROUP_SIZE];\n"
"    __local volatile short2 atomCountBuffer[GROUP_SIZE];\n"
"    __local int* buffer = workgroupBuffer+BUFFER_SIZE*(warpStart/32);\n"
"    __local int* exclusionsForX = warpExclusions+MAX_EXCLUSIONS*(warpStart/32);\n"
"    __local volatile int* tileStartIndex = workgroupTileIndex+(warpStart/32);\n"
"\n"
"    // Loop over blocks.\n"
"\n"
"    for (int block1 = startBlockIndex+warpIndex; block1 < startBlockIndex+numBlocks; block1 += totalWarps) {\n"
"        // Load data for this block.  Note that all threads in a warp are processing the same block.\n"
"        \n"
"        real2 sortedKey = sortedBlocks[block1];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[block1];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[block1];\n"
"        int neighborsInBuffer = 0;\n"
"        real3 pos1 = posq[x*TILE_SIZE+indexInWarp].xyz;\n"
"#ifdef USE_PERIODIC\n"
"        const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                         0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                         0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[get_local_id(0)] = pos1;\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = indexInWarp; j < numExclusions; j += 32)\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        if (MAX_EXCLUSIONS > 32)\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        else\n"
"            SYNC_WARPS;\n"
"        \n"
"        // Loop over atom blocks to search for neighbors.  The threads in a warp compare block1 against 32\n"
"        // other blocks in parallel.\n"
"\n"
"        for (int block2Base = block1+1; block2Base < NUM_BLOCKS; block2Base += 32) {\n"
"            int block2 = block2Base+indexInWarp;\n"
"            bool includeBlock2 = (block2 < NUM_BLOCKS);\n"
"            if (includeBlock2) {\n"
"                real4 blockCenterY = sortedBlockCenter[block2];\n"
"                real4 blockSizeY = sortedBlockBoundingBox[block2];\n"
"                real4 blockDelta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(blockDelta)\n"
"#endif\n"
"                includeBlock2 &= (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z < (PADDED_CUTOFF+blockCenterX.w+blockCenterY.w)*(PADDED_CUTOFF+blockCenterX.w+blockCenterY.w));\n"
"                blockDelta.x = max((real) 0, fabs(blockDelta.x)-blockSizeX.x-blockSizeY.x);\n"
"                blockDelta.y = max((real) 0, fabs(blockDelta.y)-blockSizeX.y-blockSizeY.y);\n"
"                blockDelta.z = max((real) 0, fabs(blockDelta.z)-blockSizeX.z-blockSizeY.z);\n"
"                includeBlock2 &= (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z < PADDED_CUTOFF_SQUARED);\n"
"#ifdef TRICLINIC\n"
"                // The calculation to find the nearest periodic copy is only guaranteed to work if the nearest copy is less than half a box width away.\n"
"                // If there's any possibility we might have missed it, do a detailed check.\n"
"\n"
"                if (periodicBoxSize.z/2-blockSizeX.z-blockSizeY.z < PADDED_CUTOFF || periodicBoxSize.y/2-blockSizeX.y-blockSizeY.y < PADDED_CUTOFF)\n"
"                    includeBlock2 = true;\n"
"#endif\n"
"                if (includeBlock2) {\n"
"                    int y = (int) sortedBlocks[block2].y;\n"
"                    for (int k = 0; k < numExclusions; k++)\n"
"                        includeBlock2 &= (exclusionsForX[k] != y);\n"
"                }\n"
"            }\n"
"            \n"
"            // Loop over any blocks we identified as potentially containing neighbors.\n"
"            \n"
"            includeBlockFlags[get_local_id(0)] = includeBlock2;\n"
"            SYNC_WARPS;\n"
"            for (int i = 0; i < TILE_SIZE; i++) {\n"
"                while (i < TILE_SIZE && !includeBlockFlags[warpStart+i])\n"
"                    i++;\n"
"                if (i < TILE_SIZE) {\n"
"                    int y = (int) sortedBlocks[block2Base+i].y;\n"
"\n"
"                    // Check each atom in block Y for interactions.\n"
"\n"
"                    int atom2 = y*TILE_SIZE+indexInWarp;\n"
"                    real3 pos2 = posq[atom2].xyz;\n"
"#ifdef USE_PERIODIC\n"
"                    if (singlePeriodicCopy)\n"
"                        APPLY_PERIODIC_TO_POS_WITH_CENTER(pos2, blockCenterX)\n"
"#endif\n"
"                    bool interacts = false;\n"
"                    if (atom2 < NUM_ATOMS) {\n"
"#ifdef USE_PERIODIC\n"
"                        if (!singlePeriodicCopy) {\n"
"                            for (int j = 0; j < TILE_SIZE; j++) {\n"
"                                real3 delta = pos2-posBuffer[warpStart+j];\n"
"                                APPLY_PERIODIC_TO_DELTA(delta)\n"
"                                interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                            }\n"
"                        }\n"
"                        else {\n"
"#endif\n"
"                            for (int j = 0; j < TILE_SIZE; j++) {\n"
"                                real3 delta = pos2-posBuffer[warpStart+j];\n"
"                                interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                            }\n"
"#ifdef USE_PERIODIC\n"
"                        }\n"
"#endif\n"
"                    }\n"
"                    \n"
"                    // Do a prefix sum to compact the list of atoms.\n"
"\n"
"                    atomCountBuffer[get_local_id(0)].x = (interacts ? 1 : 0);\n"
"                    SYNC_WARPS;\n"
"                    int whichBuffer = 0;\n"
"                    for (int offset = 1; offset < TILE_SIZE; offset *= 2) {\n"
"                        if (whichBuffer == 0)\n"
"                            atomCountBuffer[get_local_id(0)].y = (indexInWarp < offset ? atomCountBuffer[get_local_id(0)].x : atomCountBuffer[get_local_id(0)].x+atomCountBuffer[get_local_id(0)-offset].x);\n"
"                        else\n"
"                            atomCountBuffer[get_local_id(0)].x = (indexInWarp < offset ? atomCountBuffer[get_local_id(0)].y : atomCountBuffer[get_local_id(0)].y+atomCountBuffer[get_local_id(0)-offset].y);\n"
"                        whichBuffer = 1-whichBuffer;\n"
"                        SYNC_WARPS;\n"
"                    }\n"
"                    \n"
"                    // Add any interacting atoms to the buffer.\n"
"\n"
"                    if (interacts)\n"
"                        buffer[neighborsInBuffer+atomCountBuffer[get_local_id(0)].y-1] = atom2;\n"
"                    neighborsInBuffer += atomCountBuffer[warpStart+TILE_SIZE-1].y;\n"
"                    if (neighborsInBuffer > BUFFER_SIZE-TILE_SIZE) {\n"
"                        // Store the new tiles to memory.\n"
"\n"
"                        int tilesToStore = neighborsInBuffer/TILE_SIZE;\n"
"                        if (indexInWarp == 0)\n"
"                            *tileStartIndex = atom_add(interactionCount, tilesToStore);\n"
"                        SYNC_WARPS;\n"
"                        int newTileStartIndex = *tileStartIndex;\n"
"                        if (newTileStartIndex+tilesToStore <= maxTiles) {\n"
"                            if (indexInWarp < tilesToStore)\n"
"                                interactingTiles[newTileStartIndex+indexInWarp] = x;\n"
"                            for (int j = 0; j < tilesToStore; j++)\n"
"                                interactingAtoms[(newTileStartIndex+j)*TILE_SIZE+indexInWarp] = buffer[indexInWarp+j*TILE_SIZE];\n"
"                        }\n"
"                        if (indexInWarp+TILE_SIZE*tilesToStore < BUFFER_SIZE)\n"
"                            buffer[indexInWarp] = buffer[indexInWarp+TILE_SIZE*tilesToStore];\n"
"                        neighborsInBuffer -= TILE_SIZE*tilesToStore;\n"
"                   }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // If we have a partially filled buffer,  store it to memory.\n"
"        \n"
"        if (neighborsInBuffer > 0) {\n"
"            int tilesToStore = (neighborsInBuffer+TILE_SIZE-1)/TILE_SIZE;\n"
"            if (indexInWarp == 0)\n"
"                *tileStartIndex = atom_add(interactionCount, tilesToStore);\n"
"            SYNC_WARPS;\n"
"            int newTileStartIndex = *tileStartIndex;\n"
"            if (newTileStartIndex+tilesToStore <= maxTiles) {\n"
"                if (indexInWarp < tilesToStore)\n"
"                    interactingTiles[newTileStartIndex+indexInWarp] = x;\n"
"                for (int j = 0; j < tilesToStore; j++)\n"
"                    interactingAtoms[(newTileStartIndex+j)*TILE_SIZE+indexInWarp] = (indexInWarp+j*TILE_SIZE < neighborsInBuffer ? buffer[indexInWarp+j*TILE_SIZE] : NUM_ATOMS);\n"
"            }\n"
"        }\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"\n"
"#else\n"
"// This is the old implementation of finding interacting blocks.  It is quite a bit more complicated,\n"
"// and slower on most GPUs.  On AMD, however, it is faster, so we keep it around to use there.\n"
"\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"#define WARP_SIZE 32\n"
"#define INVALID -1\n"
"\n"
"/**\n"
" * Perform a parallel prefix sum over an array.  The input values are all assumed to be 0 or 1.\n"
" */\n"
"void prefixSum(__local int* sum, __local int2* temp) {\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        temp[i].x = sum[i];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    int whichBuffer = 0;\n"
"    for (int offset = 1; offset < BUFFER_SIZE; offset *= 2) {\n"
"        if (whichBuffer == 0)\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"                temp[i].y = (i < offset ? temp[i].x : temp[i].x+temp[i-offset].x);\n"
"        else\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"                temp[i].x = (i < offset ? temp[i].y : temp[i].y+temp[i-offset].y);\n"
"        whichBuffer = 1-whichBuffer;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (whichBuffer == 0)\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            sum[i] = temp[i].x;\n"
"    else\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            sum[i] = temp[i].y;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks, identifies interactions\n"
" * in them, and writes the result to global memory.\n"
" */\n"
"void storeInteractionData(int x, __local int* buffer, __local int* sum, __local int2* temp, __local int* atoms, __local int* numAtoms,\n"
"            __local int* baseIndex, __global unsigned int* interactionCount, __global int* interactingTiles, __global unsigned int* interactingAtoms, real4 periodicBoxSize,\n"
"            real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, __global const real4* posq, __local real4* posBuffer,\n"
"            real4 blockCenterX, real4 blockSizeX, unsigned int maxTiles, bool finish) {\n"
"    const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"    if (get_local_id(0) < TILE_SIZE) {\n"
"        real4 pos = posq[x*TILE_SIZE+get_local_id(0)];\n"
"#ifdef USE_PERIODIC\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[get_local_id(0)] = pos;\n"
"    }\n"
"    \n"
"    // The buffer is full, so we need to compact it and write out results.  Start by doing a parallel prefix sum.\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        sum[i] = (buffer[i] == INVALID ? 0 : 1);\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    prefixSum(sum, temp);\n"
"    int numValid = sum[BUFFER_SIZE-1];\n"
"\n"
"    // Compact the buffer.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        if (buffer[i] != INVALID)\n"
"            temp[sum[i]-1].x = buffer[i];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        buffer[i] = temp[i].x;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Loop over the tiles and find specific interactions in them.\n"
"\n"
"    const int indexInWarp = get_local_id(0)%WARP_SIZE;\n"
"    for (int base = 0; base < numValid; base += BUFFER_SIZE/WARP_SIZE) {\n"
"        for (int i = get_local_id(0)/WARP_SIZE; i < BUFFER_SIZE/WARP_SIZE && base+i < numValid; i += GROUP_SIZE/WARP_SIZE) {\n"
"            // Check each atom in block Y for interactions.\n"
"            \n"
"            real4 pos = posq[buffer[base+i]*TILE_SIZE+indexInWarp];\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"#endif\n"
"            bool interacts = false;\n"
"#ifdef USE_PERIODIC\n"
"            if (!singlePeriodicCopy) {\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"                    interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"            }\n"
"            else {\n"
"#endif\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"#ifdef USE_PERIODIC\n"
"            }\n"
"#endif\n"
"            sum[i*WARP_SIZE+indexInWarp] = (interacts ? 1 : 0);\n"
"        }\n"
"        for (int i = numValid-base+get_local_id(0)/WARP_SIZE; i < BUFFER_SIZE/WARP_SIZE; i += GROUP_SIZE/WARP_SIZE)\n"
"            sum[i*WARP_SIZE+indexInWarp] = 0;\n"
"\n"
"        // Compact the list of atoms.\n"
"\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        prefixSum(sum, temp);\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            if (sum[i] != (i == 0 ? 0 : sum[i-1]))\n"
"                atoms[*numAtoms+sum[i]-1] = buffer[base+i/WARP_SIZE]*TILE_SIZE+indexInWarp;\n"
"\n"
"        // Store them to global memory.\n"
"\n"
"        int atomsToStore = *numAtoms+sum[BUFFER_SIZE-1];\n"
"        bool storePartialTile = (finish && base >= numValid-BUFFER_SIZE/WARP_SIZE);\n"
"        int tilesToStore = (storePartialTile ? (atomsToStore+TILE_SIZE-1)/TILE_SIZE : atomsToStore/TILE_SIZE);\n"
"        if (tilesToStore > 0) {\n"
"            if (get_local_id(0) == 0)\n"
"                *baseIndex = atom_add(interactionCount, tilesToStore);\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) == 0)\n"
"                *numAtoms = atomsToStore-tilesToStore*TILE_SIZE;\n"
"            if (*baseIndex+tilesToStore <= maxTiles) {\n"
"                if (get_local_id(0) < tilesToStore)\n"
"                    interactingTiles[*baseIndex+get_local_id(0)] = x;\n"
"                for (int i = get_local_id(0); i < tilesToStore*TILE_SIZE; i += get_local_size(0))\n"
"                    interactingAtoms[*baseIndex*TILE_SIZE+i] = (i < atomsToStore ? atoms[i] : NUM_ATOMS);\n"
"            }\n"
"        }\n"
"        else {\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) == 0)\n"
"                *numAtoms += sum[BUFFER_SIZE-1];\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < *numAtoms && !storePartialTile)\n"
"            atoms[get_local_id(0)] = atoms[tilesToStore*TILE_SIZE+get_local_id(0)];\n"
"    }\n"
"\n"
"    if (numValid == 0 && *numAtoms > 0 && finish) {\n"
"        // We didn't have any more tiles to process, but there were some atoms left over from a\n"
"        // previous call to this function.  Save them now.\n"
"\n"
"        if (get_local_id(0) == 0)\n"
"            *baseIndex = atom_add(interactionCount, 1);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (*baseIndex < maxTiles) {\n"
"            if (get_local_id(0) == 0)\n"
"                interactingTiles[*baseIndex] = x;\n"
"            if (get_local_id(0) < TILE_SIZE)\n"
"                interactingAtoms[*baseIndex*TILE_SIZE+get_local_id(0)] = (get_local_id(0) < *numAtoms ? atoms[get_local_id(0)] : NUM_ATOMS);\n"
"        }\n"
"    }\n"
"\n"
"    // Reset the buffer for processing more tiles.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        buffer[i] = INVALID;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"    __local int buffer[BUFFER_SIZE];\n"
"    __local int sum[BUFFER_SIZE];\n"
"    __local int2 temp[BUFFER_SIZE];\n"
"    __local int atoms[BUFFER_SIZE+TILE_SIZE];\n"
"    __local real4 posBuffer[TILE_SIZE];\n"
"    __local int exclusionsForX[MAX_EXCLUSIONS];\n"
"    __local int bufferFull;\n"
"    __local int globalIndex;\n"
"    __local int numAtoms;\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)interactionCount)[sizeof(unsigned int)+1] = 0;\n"
"#endif\n"
"\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"\n"
"    int valuesInBuffer = 0;\n"
"    if (get_local_id(0) == 0)\n"
"        bufferFull = false;\n"
"    for (int i = 0; i < BUFFER_GROUPS; ++i)\n"
"        buffer[i*GROUP_SIZE+get_local_id(0)] = INVALID;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    // Loop over blocks sorted by size.\n"
"    \n"
"    for (int i = startBlockIndex+get_group_id(0); i < startBlockIndex+numBlocks; i += get_num_groups(0)) {\n"
"        if (get_local_id(0) == get_local_size(0)-1)\n"
"            numAtoms = 0;\n"
"        real2 sortedKey = sortedBlocks[i];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[i];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[i];\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = get_local_id(0); j < numExclusions; j += get_local_size(0))\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        \n"
"        // Compare it to other blocks after this one in sorted order.\n"
"\n"
"        for (int base = i+1; base < NUM_BLOCKS; base += get_local_size(0)) {\n"
"            int j = base+get_local_id(0);\n"
"            real2 sortedKey2 = (j < NUM_BLOCKS ? sortedBlocks[j] : (real2) 0);\n"
"            real4 blockCenterY = (j < NUM_BLOCKS ? sortedBlockCenter[j] : (real4) 0);\n"
"            real4 blockSizeY = (j < NUM_BLOCKS ? sortedBlockBoundingBox[j] : (real4) 0);\n"
"            int y = (int) sortedKey2.y;\n"
"            real4 delta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            delta.x = max((real) 0, fabs(delta.x)-blockSizeX.x-blockSizeY.x);\n"
"            delta.y = max((real) 0, fabs(delta.y)-blockSizeX.y-blockSizeY.y);\n"
"            delta.z = max((real) 0, fabs(delta.z)-blockSizeX.z-blockSizeY.z);\n"
"            bool hasExclusions = false;\n"
"            for (int k = 0; k < numExclusions; k++)\n"
"                hasExclusions |= (exclusionsForX[k] == y);\n"
"            if (j < NUM_BLOCKS && delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED && !hasExclusions) {\n"
"                // Add this tile to the buffer.\n"
"\n"
"                int bufferIndex = valuesInBuffer*GROUP_SIZE+get_local_id(0);\n"
"                buffer[bufferIndex] = y;\n"
"                valuesInBuffer++;\n"
"                if (!bufferFull && valuesInBuffer == BUFFER_GROUPS)\n"
"                    bufferFull = true;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (bufferFull) {\n"
"                storeInteractionData(x, buffer, sum, temp, atoms, &numAtoms, &globalIndex, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, posBuffer, blockCenterX, blockSizeX, maxTiles, false);\n"
"                valuesInBuffer = 0;\n"
"                if (get_local_id(0) == 0)\n"
"                    bufferFull = false;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        storeInteractionData(x, buffer, sum, temp, atoms, &numAtoms, &globalIndex, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, posBuffer, blockCenterX, blockSizeX, maxTiles, true);\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"\n"
"#endif\n"
"\n"
"";
const string OpenCLKernelSources::findInteractingBlocks_cpu = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global const real4* restrict posq, __global real4* restrict blockCenter, __global real4* restrict blockBoundingBox, __global int* restrict rebuildNeighborList,\n"
"        __global real2* restrict sortedBlocks) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        real4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        sortedBlocks[index] = (real2) (blockSize.x+blockSize.y+blockSize.z, index);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        rebuildNeighborList[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Sort the data about bounding boxes so it can be accessed more efficiently in the next kernel.\n"
" */\n"
"__kernel void sortBoxData(__global const real2* restrict sortedBlock, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockBoundingBox, __global real4* restrict sortedBlockCenter,\n"
"        __global real4* restrict sortedBlockBoundingBox, __global const real4* restrict posq, __global const real4* restrict oldPositions,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict rebuildNeighborList, int forceRebuild) {\n"
"    for (int i = get_global_id(0); i < NUM_BLOCKS; i += get_global_size(0)) {\n"
"        int index = (int) sortedBlock[i].y;\n"
"        sortedBlockCenter[i] = blockCenter[index];\n"
"        sortedBlockBoundingBox[i] = blockBoundingBox[index];\n"
"    }\n"
"    \n"
"    // Also check whether any atom has moved enough so that we really need to rebuild the neighbor list.\n"
"\n"
"    bool rebuild = forceRebuild;\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        real4 delta = oldPositions[i]-posq[i];\n"
"        if (delta.x*delta.x + delta.y*delta.y + delta.z*delta.z > 0.25f*PADDING*PADDING)\n"
"            rebuild = true;\n"
"    }\n"
"    if (rebuild) {\n"
"        rebuildNeighborList[0] = 1;\n"
"        interactionCount[0] = 0;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks and writes them\n"
" * to global memory.\n"
" */\n"
"void storeInteractionData(int x, int* buffer, int* atoms, int* numAtoms, int numValid, __global unsigned int* interactionCount,\n"
"            __global int* interactingTiles, __global unsigned int* interactingAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX,\n"
"            real4 periodicBoxVecY, real4 periodicBoxVecZ, __global const real4* posq, real4 blockCenterX, real4 blockSizeX, unsigned int maxTiles, bool finish) {\n"
"    real4 posBuffer[TILE_SIZE];\n"
"    const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"    for (int i = 0; i < TILE_SIZE; i++) {\n"
"        real4 pos = posq[x*TILE_SIZE+i];\n"
"#ifdef USE_PERIODIC\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[i] = pos;\n"
"    }\n"
"\n"
"    // Loop over the tiles and find specific interactions in them.\n"
"\n"
"    for (int tile = 0; tile < numValid; tile++) {\n"
"        for (int indexInTile = 0; indexInTile < TILE_SIZE; indexInTile++) {\n"
"            // Check each atom in block Y for interactions.\n"
"            \n"
"            int atom = buffer[tile]*TILE_SIZE+indexInTile;\n"
"            real4 pos = posq[atom];\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy)\n"
"		APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"#endif\n"
"            bool interacts = false;\n"
"#ifdef USE_PERIODIC\n"
"            if (!singlePeriodicCopy) {\n"
"                for (int j = 0; j < TILE_SIZE && !interacts; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"                    interacts = (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"            }\n"
"            else {\n"
"#endif\n"
"                for (int j = 0; j < TILE_SIZE && !interacts; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    interacts = (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"#ifdef USE_PERIODIC\n"
"            }\n"
"#endif\n"
"            if (interacts)\n"
"                atoms[(*numAtoms)++] = atom;\n"
"            if (*numAtoms == BUFFER_SIZE) {\n"
"                // The atoms buffer is full, so store it to global memory.\n"
"                \n"
"                int tilesToStore = BUFFER_SIZE/TILE_SIZE;\n"
"                int baseIndex = atom_add(interactionCount, tilesToStore);\n"
"                if (baseIndex+tilesToStore <= maxTiles) {\n"
"                    for (int i = 0; i < tilesToStore; i++) {\n"
"                        interactingTiles[baseIndex+i] = x;\n"
"                        for (int j = 0; j < TILE_SIZE; j++)\n"
"                            interactingAtoms[(baseIndex+i)*TILE_SIZE+j] = atoms[i*TILE_SIZE+j];\n"
"                    }\n"
"                }\n"
"                *numAtoms = 0;\n"
"            }\n"
"        }\n"
"    }\n"
"    \n"
"    if (*numAtoms > 0 && finish) {\n"
"        // There are some leftover atoms, so save them now.\n"
"        \n"
"        int tilesToStore = (*numAtoms+TILE_SIZE-1)/TILE_SIZE;\n"
"        int baseIndex = atom_add(interactionCount, tilesToStore);\n"
"        if (baseIndex+tilesToStore <= maxTiles) {\n"
"            for (int i = 0; i < tilesToStore; i++) {\n"
"                interactingTiles[baseIndex+i] = x;\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    int index = i*TILE_SIZE+j;\n"
"                    interactingAtoms[(baseIndex+i)*TILE_SIZE+j] = (index < *numAtoms ? atoms[index] : NUM_ATOMS);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"    int buffer[BUFFER_SIZE];\n"
"    int atoms[BUFFER_SIZE];\n"
"    int exclusionsForX[MAX_EXCLUSIONS];\n"
"    int valuesInBuffer;\n"
"    int numAtoms;\n"
"    \n"
"    // Loop over blocks sorted by size.\n"
"    \n"
"    for (int i = startBlockIndex+get_group_id(0); i < startBlockIndex+numBlocks; i += get_num_groups(0)) {\n"
"        valuesInBuffer = 0;\n"
"        numAtoms = 0;\n"
"        real2 sortedKey = sortedBlocks[i];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[i];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[i];\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = 0; j < numExclusions; j++)\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        \n"
"        // Compare it to other blocks after this one in sorted order.\n"
"        \n"
"        for (int j = i+1; j < NUM_BLOCKS; j++) {\n"
"            real2 sortedKey2 = sortedBlocks[j];\n"
"            int y = (int) sortedKey2.y;\n"
"            bool hasExclusions = false;\n"
"            for (int k = 0; k < numExclusions; k++)\n"
"                hasExclusions |= (exclusionsForX[k] == y);\n"
"            if (hasExclusions)\n"
"                continue;\n"
"            real4 blockCenterY = sortedBlockCenter[j];\n"
"            real4 blockSizeY = sortedBlockBoundingBox[j];\n"
"            real4 delta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            delta.x = max((real) 0, fabs(delta.x)-blockSizeX.x-blockSizeY.x);\n"
"            delta.y = max((real) 0, fabs(delta.y)-blockSizeX.y-blockSizeY.y);\n"
"            delta.z = max((real) 0, fabs(delta.z)-blockSizeX.z-blockSizeY.z);\n"
"            if (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED) {\n"
"                // Add this tile to the buffer.\n"
"\n"
"                buffer[valuesInBuffer++] = y;\n"
"                if (valuesInBuffer == BUFFER_SIZE) {\n"
"                    storeInteractionData(x, buffer, atoms, &numAtoms, valuesInBuffer, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, blockCenterX, blockSizeX, maxTiles, false);\n"
"                    valuesInBuffer = 0;\n"
"                }\n"
"            }\n"
"        }\n"
"        storeInteractionData(x, buffer, atoms, &numAtoms, valuesInBuffer, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, blockCenterX, blockSizeX, maxTiles, true);\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define WARPS_PER_GROUP (FORCE_WORK_GROUP_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    real padding;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"__kernel void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global real4* restrict forceBuffers,\n"
"#endif\n"
"        __global mixed* restrict energyBuffer, __global const real4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const int2* restrict exclusionTiles, unsigned int startTileIndex, unsigned long numTileIndices\n"
"#ifdef USE_CUTOFF\n"
"        , __global const int* restrict tiles, __global const unsigned int* restrict interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockSize, __global const int* restrict interactingAtoms\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    const unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"    const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"    const unsigned int tbx = get_local_id(0) - tgx;\n"
"    const unsigned int localAtomIndex = get_local_id(0);\n"
"    mixed energy = 0;\n"
"    INIT_DERIVATIVES\n"
"    __local AtomData localData[FORCE_WORK_GROUP_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"\n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real4 force = 0;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"        const bool hasExclusions = true;\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[localAtomIndex].x = posq1.x;\n"
"            localData[localAtomIndex].y = posq1.y;\n"
"            localData[localAtomIndex].z = posq1.z;\n"
"            localData[localAtomIndex].q = posq1.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                real invR = RSQRT(r2);\n"
"                real r = r2*invR;\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                real dEdR = 0;\n"
"#else\n"
"                real4 dEdR1 = (real4) 0;\n"
"                real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                real tempEnergy = 0;\n"
"                const real interactionScale = 0.5f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += 0.5f*tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = tempPosq.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            localData[localAtomIndex].fx = 0;\n"
"            localData[localAtomIndex].fy = 0;\n"
"            localData[localAtomIndex].fz = 0;\n"
"            SYNC_WARPS;\n"
"#ifdef USE_EXCLUSIONS\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"                real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+tj;\n"
"#ifdef USE_SYMMETRIC\n"
"                    real dEdR = 0;\n"
"#else\n"
"                    real4 dEdR1 = (real4) 0;\n"
"                    real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                    real tempEnergy = 0;\n"
"                    const real interactionScale = 1.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                    delta.xyz *= dEdR;\n"
"                    force.xyz -= delta.xyz;\n"
"                    localData[tbx+tj].fx += delta.x;\n"
"                    localData[tbx+tj].fy += delta.y;\n"
"                    localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                    force.xyz -= dEdR1.xyz;\n"
"                    localData[tbx+tj].fx += dEdR2.x;\n"
"                    localData[tbx+tj].fy += dEdR2.y;\n"
"                    localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        atom_add(&forceBuffers[offset], (long) (force.x*0x100000000));\n"
"        atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"        atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (localData[get_local_id(0)].fx*0x100000000));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0x100000000));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0x100000000));\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        forceBuffers[offset1].xyz += force.xyz;\n"
"        if (x != y)\n"
"            forceBuffers[offset2] += (real4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"#endif\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(long)numTiles/totalWarps);\n"
"#else\n"
"    int pos = (int) (startTileIndex+warp*numTileIndices/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*numTileIndices/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    __local int atomIndices[FORCE_WORK_GROUP_SIZE];\n"
"    __local volatile int skipTiles[FORCE_WORK_GROUP_SIZE];\n"
"    skipTiles[get_local_id(0)] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        const bool hasExclusions = false;\n"
"        real4 force = 0;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"\n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= MAX_CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[get_local_id(0)] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[get_local_id(0)] = end;\n"
"            skipBase += TILE_SIZE;\n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            real4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[get_local_id(0)] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                real4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                localData[localAtomIndex].fx = 0;\n"
"                localData[localAtomIndex].fy = 0;\n"
"                localData[localAtomIndex].fz = 0;\n"
"            }\n"
"            else {\n"
"                localData[localAtomIndex].x = 0;\n"
"                localData[localAtomIndex].y = 0;\n"
"                localData[localAtomIndex].z = 0;\n"
"                CLEAR_LOCAL_PARAMETERS\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[localAtomIndex], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[tbx+tj].fx += delta.x;\n"
"                        localData[tbx+tj].fy += delta.y;\n"
"                        localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[tbx+tj].fx += dEdR2.x;\n"
"                        localData[tbx+tj].fy += dEdR2.y;\n"
"                        localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[tbx+tj].fx += delta.x;\n"
"                        localData[tbx+tj].fy += delta.y;\n"
"                        localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[tbx+tj].fx += dEdR2.x;\n"
"                        localData[tbx+tj].fy += dEdR2.y;\n"
"                        localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[get_local_id(0)];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"            atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"            atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                atom_add(&forceBuffers[atom2], (long) (localData[get_local_id(0)].fx*0x100000000));\n"
"                atom_add(&forceBuffers[atom2+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0x100000000));\n"
"                atom_add(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0x100000000));\n"
"            }\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"            forceBuffers[offset1].xyz += force.xyz;\n"
"            if (atom2 < PADDED_NUM_ATOMS)\n"
"                forceBuffers[offset2] += (real4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"#endif\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"#ifdef INCLUDE_ENERGY\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"#endif\n"
"    SAVE_DERIVATIVES\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded_cpu = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"\n"
"__kernel void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global real4* restrict forceBuffers,\n"
"#endif\n"
"        __global mixed* restrict energyBuffer, __global const real4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const int2* restrict exclusionTiles, unsigned int startTileIndex, unsigned long numTileIndices\n"
"#ifdef USE_CUTOFF\n"
"        , __global const int* restrict tiles, __global const unsigned int* restrict interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockSize, __global const int* restrict interactingAtoms\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    mixed energy = 0;\n"
"    INIT_DERIVATIVES\n"
"    __local AtomData localData[TILE_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"\n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+get_group_id(0)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(get_group_id(0)+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = tempPosq.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"        }\n"
"        const bool hasExclusions = true;\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 0.5f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += 0.5f*tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                        force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                localData[tgx].fx = 0;\n"
"                localData[tgx].fy = 0;\n"
"                localData[tgx].fz = 0;\n"
"            }\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[j].fx += delta.x;\n"
"                        localData[j].fy += delta.y;\n"
"                        localData[j].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[j].fx += dEdR2.x;\n"
"                        localData[j].fy += dEdR2.y;\n"
"                        localData[j].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"               // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = y*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset], (long) (localData[tgx].fx*0x100000000));\n"
"                atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[tgx].fy*0x100000000));\n"
"                atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[tgx].fz*0x100000000));\n"
"#else\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                real4 f = forceBuffers[offset];\n"
"                f.x += localData[tgx].fx;\n"
"                f.y += localData[tgx].fy;\n"
"                f.z += localData[tgx].fz;\n"
"                forceBuffers[offset] = f;\n"
"#endif\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? (unsigned int) (startTileIndex+get_group_id(0)*(long)numTileIndices/get_num_groups(0)) : get_group_id(0)*(long)numTiles/get_num_groups(0));\n"
"    int end = (int) (numTiles > maxTiles ? (unsigned int) (startTileIndex+(get_group_id(0)+1)*(long)numTileIndices/get_num_groups(0)) : (get_group_id(0)+1)*(long)numTiles/get_num_groups(0));\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+get_group_id(0)*(long)numTiles/get_num_groups(0));\n"
"    int end = (int) (startTileIndex+(get_group_id(0)+1)*(long)numTiles/get_num_groups(0));\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    __local int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        const bool hasExclusions = false;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"\n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= MAX_CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    real4 tempPosq = posq[j];\n"
"                    localData[localAtomIndex].x = tempPosq.x;\n"
"                    localData[localAtomIndex].y = tempPosq.y;\n"
"                    localData[localAtomIndex].z = tempPosq.z;\n"
"                    localData[localAtomIndex].q = tempPosq.w;\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                    localData[localAtomIndex].fx = 0;\n"
"                    localData[localAtomIndex].fy = 0;\n"
"                    localData[localAtomIndex].fz = 0;\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[tgx], blockCenterX)\n"
"                }\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                        real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"                        if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"#ifdef USE_SYMMETRIC\n"
"                            real dEdR = 0;\n"
"#else\n"
"                            real4 dEdR1 = (real4) 0;\n"
"                            real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                            bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"#else\n"
"                            force.xyz -= dEdR1.xyz;\n"
"                            localData[j].fx += dEdR2.x;\n"
"                            localData[j].fy += dEdR2.y;\n"
"                            localData[j].fz += dEdR2.z;\n"
"#endif\n"
"                        }\n"
"                    }\n"
"\n"
"                   // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                        real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"#ifdef USE_SYMMETRIC\n"
"                            real dEdR = 0;\n"
"#else\n"
"                            real4 dEdR1 = (real4) 0;\n"
"                            real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                            bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"#else\n"
"                            force.xyz -= dEdR1.xyz;\n"
"                            localData[j].fx += dEdR2.x;\n"
"                            localData[j].fy += dEdR2.y;\n"
"                            localData[j].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom2], (long) (localData[tgx].fx*0x100000000));\n"
"                    atom_add(&forceBuffers[atom2+PADDED_NUM_ATOMS], (long) (localData[tgx].fy*0x100000000));\n"
"                    atom_add(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (long) (localData[tgx].fz*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom2 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    real4 f = forceBuffers[offset];\n"
"                    f.x += localData[tgx].fx;\n"
"                    f.y += localData[tgx].fy;\n"
"                    f.z += localData[tgx].fz;\n"
"                    forceBuffers[offset] = f;\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"    SAVE_DERIVATIVES\n"
"}\n"
"";
const string OpenCLKernelSources::sort = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"\n"
"KEY_TYPE getValue(DATA_TYPE value) {\n"
"    return SORT_KEY;\n"
"}\n"
"\n"
"/**\n"
" * Sort a list that is short enough to entirely fit in local memory.  This is executed as\n"
" * a single thread block.\n"
" */\n"
"__kernel void sortShortList(__global DATA_TYPE* restrict data, uint length, __local DATA_TYPE* dataBuffer) {\n"
"    // Load the data into local memory.\n"
"    \n"
"    for (int index = get_local_id(0); index < length; index += get_local_size(0))\n"
"        dataBuffer[index] = data[index];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Perform a bitonic sort in local memory.\n"
"\n"
"    for (unsigned int k = 2; k < 2*length; k *= 2) {\n"
"        for (unsigned int j = k/2; j > 0; j /= 2) {\n"
"            for (unsigned int i = get_local_id(0); i < length; i += get_local_size(0)) {\n"
"                int ixj = i^j;\n"
"                if (ixj > i && ixj < length) {\n"
"                    DATA_TYPE value1 = dataBuffer[i];\n"
"                    DATA_TYPE value2 = dataBuffer[ixj];\n"
"                    bool ascending = ((i&k) == 0);\n"
"                    for (unsigned int mask = k*2; mask < 2*length; mask *= 2)\n"
"                        ascending = ((i&mask) == 0 ? !ascending : ascending);\n"
"                    KEY_TYPE lowKey  = (ascending ? getValue(value1) : getValue(value2));\n"
"                    KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                    if (lowKey > highKey) {\n"
"                        dataBuffer[i] = value2;\n"
"                        dataBuffer[ixj] = value1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"    }\n"
"\n"
"    // Write the data back to global memory.\n"
"\n"
"    for (int index = get_local_id(0); index < length; index += get_local_size(0))\n"
"        data[index] = dataBuffer[index];\n"
"}\n"
"\n"
"/**\n"
" * An alternate kernel for sorting short lists.  In this version every thread does a full\n"
" * scan through the data to select the destination for one element.  This involves more\n"
" * work, but also parallelizes much better.\n"
" */\n"
"__kernel void sortShortList2(__global const DATA_TYPE* restrict dataIn, __global DATA_TYPE* restrict dataOut, int length) {\n"
"    __local DATA_TYPE dataBuffer[64];\n"
"    DATA_TYPE value = dataIn[get_global_id(0) < length ? get_global_id(0) : 0];\n"
"    KEY_TYPE key = getValue(value);\n"
"    int count = 0;\n"
"    for (int blockStart = 0; blockStart < length; blockStart += get_local_size(0)) {\n"
"        int numInBlock = min((int) get_local_size(0), length-blockStart);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < numInBlock)\n"
"            dataBuffer[get_local_id(0)] = dataIn[blockStart+get_local_id(0)];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (int i = 0; i < numInBlock; i++) {\n"
"            KEY_TYPE otherKey = getValue(dataBuffer[i]);\n"
"            if (otherKey < key || (otherKey == key && blockStart+i < get_global_id(0)))\n"
"                count++;\n"
"        }\n"
"    }\n"
"    if (get_global_id(0) < length)\n"
"        dataOut[count] = value;\n"
"}\n"
"\n"
"/**\n"
" * Calculate the minimum and maximum value in the array to be sorted.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeRange(__global const DATA_TYPE* restrict data, uint length, __global KEY_TYPE* restrict range, __local KEY_TYPE* restrict minBuffer,\n"
"        __local KEY_TYPE* restrict maxBuffer, uint numBuckets, __global uint* restrict bucketOffset) {\n"
"#if UNIFORM\n"
"    KEY_TYPE minimum = MAX_KEY;\n"
"    KEY_TYPE maximum = MIN_KEY;\n"
"\n"
"    // Each thread calculates the range of a subset of values.\n"
"\n"
"    for (uint index = get_local_id(0); index < length; index += get_local_size(0)) {\n"
"        KEY_TYPE value = getValue(data[index]);\n"
"        minimum = min(minimum, value);\n"
"        maximum = max(maximum, value);\n"
"    }\n"
"\n"
"    // Now reduce them.\n"
"\n"
"    minBuffer[get_local_id(0)] = minimum;\n"
"    maxBuffer[get_local_id(0)] = maximum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"        if (get_local_id(0)+step < get_local_size(0) && get_local_id(0)%(2*step) == 0) {\n"
"            minBuffer[get_local_id(0)] = min(minBuffer[get_local_id(0)], minBuffer[get_local_id(0)+step]);\n"
"            maxBuffer[get_local_id(0)] = max(maxBuffer[get_local_id(0)], maxBuffer[get_local_id(0)+step]);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    minimum = minBuffer[0];\n"
"    maximum = maxBuffer[0];\n"
"    if (get_local_id(0) == 0) {\n"
"        range[0] = minimum;\n"
"        range[1] = maximum;\n"
"    }\n"
"#endif\n"
"\n"
"    // Clear the bucket counters in preparation for the next kernel.\n"
"\n"
"    for (uint index = get_local_id(0); index < numBuckets; index += get_local_size(0))\n"
"        bucketOffset[index] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Assign elements to buckets.  This version is optimized for uniformly distributed data.\n"
" */\n"
"__kernel void assignElementsToBuckets(__global const DATA_TYPE* restrict data, uint length, uint numBuckets, __global const KEY_TYPE* restrict range,\n"
"        __global uint* restrict bucketOffset, __global uint* restrict bucketOfElement, __global uint* restrict offsetInBucket) {\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)bucketOffset)[sizeof(int)*numBuckets+1] = 0;\n"
"#endif\n"
"    float minValue = (float) (range[0]);\n"
"    float maxValue = (float) (range[1]);\n"
"    float bucketWidth = (maxValue-minValue)/numBuckets;\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        float key = (float) getValue(data[index]);\n"
"        uint bucketIndex = min((uint) ((key-minValue)/bucketWidth), numBuckets-1);\n"
"        offsetInBucket[index] = atom_inc(&bucketOffset[bucketIndex]);\n"
"        bucketOfElement[index] = bucketIndex;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Assign elements to buckets.  This version is optimized for non-uniformly distributed data.\n"
" */\n"
"__kernel void assignElementsToBuckets2(__global const DATA_TYPE* restrict data, uint length, uint numBuckets, __global const KEY_TYPE* restrict range,\n"
"        __global uint* restrict bucketOffset, __global uint* restrict bucketOfElement, __global uint* restrict offsetInBucket) {\n"
"    // Load 64 datapoints and sort them to get an estimate of the data distribution.\n"
"\n"
"    __local KEY_TYPE elements[64];\n"
"    if (get_local_id(0) < 64) {\n"
"        int index = (int) (get_local_id(0)*length/64.0);\n"
"        elements[get_local_id(0)] = getValue(data[index]);\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (unsigned int k = 2; k <= 64; k *= 2) {\n"
"        for (unsigned int j = k/2; j > 0; j /= 2) {\n"
"            if (get_local_id(0) < 64) {\n"
"                int ixj = get_local_id(0)^j;\n"
"                if (ixj > get_local_id(0)) {\n"
"                    KEY_TYPE value1 = elements[get_local_id(0)];\n"
"                    KEY_TYPE value2 = elements[ixj];\n"
"                    bool ascending = (get_local_id(0)&k) == 0;\n"
"                    KEY_TYPE lowKey = (ascending ? value1 : value2);\n"
"                    KEY_TYPE highKey = (ascending ? value2 : value1);\n"
"                    if (lowKey > highKey) {\n"
"                        elements[get_local_id(0)] = value2;\n"
"                        elements[ixj] = value1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"    }\n"
"\n"
"    // Create a function composed of linear segments mapping data values to bucket indices.\n"
"\n"
"    __local float segmentLowerBound[9];\n"
"    __local float segmentBaseIndex[9];\n"
"    __local float segmentIndexScale[9];\n"
"    if (get_local_id(0) == 0) {\n"
"        segmentLowerBound[0] = elements[0]-0.2f*(elements[5]-elements[0]);\n"
"        segmentLowerBound[1] = elements[5];\n"
"        segmentLowerBound[2] = elements[10];\n"
"        segmentLowerBound[3] = elements[20];\n"
"        segmentLowerBound[4] = elements[30];\n"
"        segmentLowerBound[5] = elements[40];\n"
"        segmentLowerBound[6] = elements[50];\n"
"        segmentLowerBound[7] = elements[60];\n"
"        segmentLowerBound[8] = elements[63]+0.2f*(elements[63]-elements[58]);\n"
"        segmentBaseIndex[0] = numBuckets/16;\n"
"        segmentBaseIndex[1] = 3*numBuckets/16;\n"
"        segmentBaseIndex[2] = 5*numBuckets/16;\n"
"        segmentBaseIndex[3] = 7*numBuckets/16;\n"
"        segmentBaseIndex[4] = 9*numBuckets/16;\n"
"        segmentBaseIndex[5] = 11*numBuckets/16;\n"
"        segmentBaseIndex[6] = 13*numBuckets/16;\n"
"        segmentBaseIndex[7] = 15*numBuckets/16;\n"
"        segmentBaseIndex[8] = numBuckets;\n"
"        for (int i = 0; i < 8; i++)\n"
"            if (segmentLowerBound[i+1] == segmentLowerBound[i])\n"
"                segmentIndexScale[i] = 0;\n"
"            else\n"
"                segmentIndexScale[i] = (segmentBaseIndex[i+1]-segmentBaseIndex[i])/(segmentLowerBound[i+1]-segmentLowerBound[i]);\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Assign elements to buckets.\n"
"\n"
"    for (unsigned int index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        float key = (float) getValue(data[index]);\n"
"        int segment;\n"
"        for (segment = 0; segment < 7 && key > segmentLowerBound[segment+1]; segment++)\n"
"            ;\n"
"        unsigned int bucketIndex = segmentBaseIndex[segment]+(key-segmentLowerBound[segment])*segmentIndexScale[segment];\n"
"        bucketIndex = min(max((uint) 0, bucketIndex), numBuckets-1);\n"
"        offsetInBucket[index] = atom_inc(&bucketOffset[bucketIndex]);\n"
"        bucketOfElement[index] = bucketIndex;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the bucket sizes to compute the start position of each bucket.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeBucketPositions(uint numBuckets, __global uint* restrict bucketOffset, __local uint* restrict buffer) {\n"
"    uint globalOffset = 0;\n"
"    for (uint startBucket = 0; startBucket < numBuckets; startBucket += get_local_size(0)) {\n"
"        // Load the bucket sizes into local memory.\n"
"\n"
"        uint globalIndex = startBucket+get_local_id(0);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        buffer[get_local_id(0)] = (globalIndex < numBuckets ? bucketOffset[globalIndex] : 0);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Perform a parallel prefix sum.\n"
"\n"
"        for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"            uint add = (get_local_id(0) >= step ? buffer[get_local_id(0)-step] : 0);\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            buffer[get_local_id(0)] += add;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"\n"
"        // Write the results back to global memory.\n"
"\n"
"        if (globalIndex < numBuckets)\n"
"            bucketOffset[globalIndex] = buffer[get_local_id(0)]+globalOffset;\n"
"        globalOffset += buffer[get_local_size(0)-1];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the input data into the buckets for sorting.\n"
" */\n"
"__kernel void copyDataToBuckets(__global const DATA_TYPE* restrict data, __global DATA_TYPE* restrict buckets, uint length, __global const uint* restrict bucketOffset, __global const uint* restrict bucketOfElement, __global const uint* restrict offsetInBucket) {\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        DATA_TYPE element = data[index];\n"
"        uint bucketIndex = bucketOfElement[index];\n"
"        uint offset = (bucketIndex == 0 ? 0 : bucketOffset[bucketIndex-1]);\n"
"        buckets[offset+offsetInBucket[index]] = element;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sort the data in each bucket.\n"
" */\n"
"__kernel void sortBuckets(__global DATA_TYPE* restrict data, __global const DATA_TYPE* restrict buckets, uint numBuckets, __global const uint* restrict bucketOffset, __local DATA_TYPE* restrict buffer) {\n"
"    for (int index = get_group_id(0); index < numBuckets; index += get_num_groups(0)) {\n"
"        int startIndex = (index == 0 ? 0 : bucketOffset[index-1]);\n"
"        int endIndex = bucketOffset[index];\n"
"        int length = endIndex-startIndex;\n"
"        if (length <= get_local_size(0)) {\n"
"            // Load the data into local memory.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                buffer[get_local_id(0)] = buckets[startIndex+get_local_id(0)];\n"
"            else\n"
"                buffer[get_local_id(0)] = MAX_VALUE;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in local memory.\n"
"\n"
"            for (int k = 2; k <= get_local_size(0); k *= 2) {\n"
"                for (int j = k/2; j > 0; j /= 2) {\n"
"                    int ixj = get_local_id(0)^j;\n"
"                    if (ixj > get_local_id(0)) {\n"
"                        DATA_TYPE value1 = buffer[get_local_id(0)];\n"
"                        DATA_TYPE value2 = buffer[ixj];\n"
"                        bool ascending = (get_local_id(0)&k) == 0;\n"
"                        KEY_TYPE lowKey = (ascending ? getValue(value1) : getValue(value2));\n"
"                        KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                        if (lowKey > highKey) {\n"
"                            buffer[get_local_id(0)] = value2;\n"
"                            buffer[ixj] = value1;\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_LOCAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"\n"
"            // Write the data to the sorted array.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                data[startIndex+get_local_id(0)] = buffer[get_local_id(0)];\n"
"        }\n"
"        else {\n"
"            // Copy the bucket data over to the output array.\n"
"\n"
"            for (int i = get_local_id(0); i < length; i += get_local_size(0))\n"
"                data[startIndex+i] = buckets[startIndex+i];\n"
"            barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in global memory.\n"
"\n"
"            for (int k = 2; k < 2*length; k *= 2) {\n"
"                for (int j = k/2; j > 0; j /= 2) {\n"
"                    for (int i = get_local_id(0); i < length; i += get_local_size(0)) {\n"
"                        int ixj = i^j;\n"
"                        if (ixj > i && ixj < length) {\n"
"                            DATA_TYPE value1 = data[startIndex+i];\n"
"                            DATA_TYPE value2 = data[startIndex+ixj];\n"
"                            bool ascending = ((i&k) == 0);\n"
"                            for (int mask = k*2; mask < 2*length; mask *= 2)\n"
"                                ascending = ((i&mask) == 0 ? !ascending : ascending);\n"
"                            KEY_TYPE lowKey  = (ascending ? getValue(value1) : getValue(value2));\n"
"                            KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                            if (lowKey > highKey) {\n"
"                                data[startIndex+i] = value2;\n"
"                                data[startIndex+ixj] = value1;\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::utilities = "/**\n"
" * Fill a buffer with 0.\n"
" */\n"
"\n"
"__kernel void clearBuffer(__global int* restrict buffer, int size) {\n"
"    int index = get_global_id(0);\n"
"    __global int4* buffer4 = (__global int4*) buffer;\n"
"    int sizeDiv4 = size/4;\n"
"    while (index < sizeDiv4) {\n"
"        buffer4[index] = (int4) 0;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        for (int i = sizeDiv4*4; i < size; i++)\n"
"            buffer[i] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Fill two buffers with 0.\n"
" */\n"
"__kernel void clearTwoBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"}\n"
"\n"
"/**\n"
" * Fill three buffers with 0.\n"
" */\n"
"__kernel void clearThreeBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"}\n"
"\n"
"/**\n"
" * Fill four buffers with 0.\n"
" */\n"
"__kernel void clearFourBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"}\n"
"\n"
"/**\n"
" * Fill five buffers with 0.\n"
" */\n"
"__kernel void clearFiveBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"}\n"
"\n"
"/**\n"
" * Fill six buffers with 0.\n"
" */\n"
"__kernel void clearSixBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5, __global int* restrict buffer6, int size6) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"    clearBuffer(buffer6, size6);\n"
"}\n"
"\n"
"/**\n"
" * Sum a collection of buffers into the first one.\n"
" * Also, write the result into a 64-bit fixed point buffer (overwriting its contents).\n"
" */\n"
"\n"
"__kernel void reduceReal4Buffer(__global real4* restrict buffer, __global long* restrict longBuffer, int bufferSize, int numBuffers) {\n"
"    int index = get_global_id(0);\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    while (index < bufferSize) {\n"
"        real4 sum = buffer[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"        longBuffer[index] = (long) (sum.x*0x100000000);\n"
"        longBuffer[index+bufferSize] = (long) (sum.y*0x100000000);\n"
"        longBuffer[index+2*bufferSize] = (long) (sum.z*0x100000000);\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the various buffers containing forces.\n"
" */\n"
"__kernel void reduceForces(__global long* restrict longBuffer, __global real4* restrict buffer, int bufferSize, int numBuffers) {\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = get_global_id(0); index < bufferSize; index += get_global_size(0)) {\n"
"        real4 sum = (real4) (scale*longBuffer[index], scale*longBuffer[index+bufferSize], scale*longBuffer[index+2*bufferSize], 0);\n"
"        for (int i = index; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"        longBuffer[index] = (long) (sum.x*0x100000000);\n"
"        longBuffer[index+bufferSize] = (long) (sum.y*0x100000000);\n"
"        longBuffer[index+2*bufferSize] = (long) (sum.z*0x100000000);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the energy buffer.\n"
" */\n"
"__kernel void reduceEnergy(__global const mixed* restrict energyBuffer, __global mixed* restrict result, int bufferSize, int workGroupSize, __local mixed* tempBuffer) {\n"
"    const unsigned int thread = get_local_id(0);\n"
"    mixed sum = 0;\n"
"    for (unsigned int index = thread; index < bufferSize; index += get_local_size(0))\n"
"        sum += energyBuffer[index];\n"
"    tempBuffer[thread] = sum;\n"
"    for (int i = 1; i < workGroupSize; i *= 2) {\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (thread%(i*2) == 0 && thread+i < workGroupSize)\n"
"            tempBuffer[thread] += tempBuffer[thread+i];\n"
"    }\n"
"    if (thread == 0)\n"
"        *result = tempBuffer[0];\n"
"}\n"
"\n"
"/**\n"
" * This is called to determine the accuracy of various native functions.\n"
" */\n"
"\n"
"__kernel void determineNativeAccuracy(__global float8* restrict values, int numValues) {\n"
"    for (int i = get_global_id(0); i < numValues; i += get_global_size(0)) {\n"
"        float v = values[i].s0;\n"
"        values[i] = (float8) (v, native_sqrt(v), native_rsqrt(v), native_recip(v), native_exp(v), native_log(v), 0.0f, 0.0f);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Record the atomic charges into the posq array.\n"
" */\n"
"__kernel void setCharges(__global real* restrict charges, __global real4* restrict posq, __global int* restrict atomOrder, int numAtoms) {\n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0))\n"
"        posq[i].w = charges[atomOrder[i]];\n"
"}";
