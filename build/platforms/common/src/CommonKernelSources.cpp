/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2019 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CommonKernelSources.h"

using namespace OpenMM;
using namespace std;

const string CommonKernelSources::andersenThermostat = "/**\n"
" * Apply the Andersen thermostat to adjust particle velocities.\n"
" */\n"
"\n"
"KERNEL void applyAndersenThermostat(int numAtoms, float collisionFrequency, float kT, GLOBAL mixed4* velm, real stepSize, GLOBAL const float4* RESTRICT random,\n"
"        unsigned int randomIndex, GLOBAL const int* RESTRICT atomGroups) {\n"
"    float collisionProbability = (float) (1-EXP(-collisionFrequency*stepSize));\n"
"    float randomRange = (float) erf(collisionProbability/SQRT(2.0f));\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        float4 selectRand = random[randomIndex+atomGroups[index]];\n"
"        float4 velRand = random[randomIndex+index];\n"
"        real scale = (selectRand.w > -randomRange && selectRand.w < randomRange ? 0 : 1);\n"
"        real add = (1-scale)*SQRT(kT*velocity.w);\n"
"        velocity.x = scale*velocity.x + add*velRand.x;\n"
"        velocity.y = scale*velocity.y + add*velRand.y;\n"
"        velocity.z = scale*velocity.z + add*velRand.z;\n"
"        velm[index] = velocity;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::angleForce = "real3 v0 = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"real3 v1 = make_real3(pos2.x-pos3.x, pos2.y-pos3.y, pos2.z-pos3.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0)\n"
"APPLY_PERIODIC_TO_DELTA(v1)\n"
"#endif\n"
"real3 cp = cross(v0, v1);\n"
"real rp = cp.x*cp.x + cp.y*cp.y + cp.z*cp.z;\n"
"rp = max(SQRT(rp), (real) 1.0e-06f);\n"
"real r21 = v0.x*v0.x + v0.y*v0.y + v0.z*v0.z;\n"
"real r23 = v1.x*v1.x + v1.y*v1.y + v1.z*v1.z;\n"
"real dot = v0.x*v1.x + v0.y*v1.y + v0.z*v1.z;\n"
"real cosine = min(max(dot*RSQRT(r21*r23), (real) -1), (real) 1);\n"
"real theta = ACOS(cosine);\n"
"COMPUTE_FORCE\n"
"real3 force1 = cross(v0, cp)*(dEdAngle/(r21*rp));\n"
"real3 force3 = cross(cp, v1)*(dEdAngle/(r23*rp));\n"
"real3 force2 = -force1-force3;\n"
"";
const string CommonKernelSources::bondForce = "real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"real r = SQRT(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"COMPUTE_FORCE\n"
"dEdR = (r > 0) ? (dEdR / r) : 0;\n"
"delta *= dEdR;\n"
"real3 force1 = delta;\n"
"real3 force2 = -delta;\n"
"";
const string CommonKernelSources::brownian = "/**\n"
" * Perform the first step of Brownian integration.\n"
" */\n"
"\n"
"KERNEL void integrateBrownianPart1(int numAtoms, int paddedNumAtoms, mixed tauDeltaT, mixed noiseAmplitude, GLOBAL const mm_long* RESTRICT force,\n"
"        GLOBAL mixed4* RESTRICT posDelta, GLOBAL const mixed4* RESTRICT velm, GLOBAL const float4* RESTRICT random, unsigned int randomIndex) {\n"
"    randomIndex += GLOBAL_ID;\n"
"    const mixed fscale = tauDeltaT/(mixed) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed invMass = velm[index].w;\n"
"        if (invMass != 0) {\n"
"            posDelta[index].x = fscale*invMass*force[index] + noiseAmplitude*SQRT(invMass)*random[randomIndex].x;\n"
"            posDelta[index].y = fscale*invMass*force[index+paddedNumAtoms] + noiseAmplitude*SQRT(invMass)*random[randomIndex].y;\n"
"            posDelta[index].z = fscale*invMass*force[index+paddedNumAtoms*2] + noiseAmplitude*SQRT(invMass)*random[randomIndex].z;\n"
"        }\n"
"        randomIndex += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Brownian integration.\n"
" */\n"
"\n"
"KERNEL void integrateBrownianPart2(int numAtoms, mixed oneOverDeltaT, GLOBAL real4* posq, GLOBAL mixed4* velm, GLOBAL const mixed4* RESTRICT posDelta\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        if (velm[index].w != 0) {\n"
"            mixed4 delta = posDelta[index];\n"
"            velm[index].x = oneOverDeltaT*delta.x;\n"
"            velm[index].y = oneOverDeltaT*delta.y;\n"
"            velm[index].z = oneOverDeltaT*delta.z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::cmapTorsionForce = "const real PI = (real) 3.14159265358979323846;\n"
"\n"
"// Compute the first angle.\n"
"\n"
"real3 v0a = make_real3(pos1.x-pos2.x, pos1.y-pos2.y, pos1.z-pos2.z);\n"
"real3 v1a = make_real3(pos3.x-pos2.x, pos3.y-pos2.y, pos3.z-pos2.z);\n"
"real3 v2a = make_real3(pos3.x-pos4.x, pos3.y-pos4.y, pos3.z-pos4.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0a)\n"
"APPLY_PERIODIC_TO_DELTA(v1a)\n"
"APPLY_PERIODIC_TO_DELTA(v2a)\n"
"#endif\n"
"real3 cp0a = cross(v0a, v1a);\n"
"real3 cp1a = cross(v1a, v2a);\n"
"real cosangle = dot(normalize(cp0a), normalize(cp1a));\n"
"real angleA;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real3 cross_prod = cross(cp0a, cp1a);\n"
"    real scale = dot(cp0a, cp0a)*dot(cp1a, cp1a);\n"
"    angleA = ASIN(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        angleA = PI-angleA;\n"
"}\n"
"else\n"
"   angleA = ACOS(cosangle);\n"
"angleA = (dot(v0a, cp1a) >= 0 ? angleA : -angleA);\n"
"angleA = fmod(angleA+2.0f*PI, 2.0f*PI);\n"
"\n"
"// Compute the second angle.\n"
"\n"
"real3 v0b = make_real3(pos5.x-pos6.x, pos5.y-pos6.y, pos5.z-pos6.z);\n"
"real3 v1b = make_real3(pos7.x-pos6.x, pos7.y-pos6.y, pos7.z-pos6.z);\n"
"real3 v2b = make_real3(pos7.x-pos8.x, pos7.y-pos8.y, pos7.z-pos8.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0b)\n"
"APPLY_PERIODIC_TO_DELTA(v1b)\n"
"APPLY_PERIODIC_TO_DELTA(v2b)\n"
"#endif\n"
"real3 cp0b = cross(v0b, v1b);\n"
"real3 cp1b = cross(v1b, v2b);\n"
"cosangle = dot(normalize(cp0b), normalize(cp1b));\n"
"real angleB;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real3 cross_prod = cross(cp0b, cp1b);\n"
"    real scale = dot(cp0b, cp0b)*dot(cp1b, cp1b);\n"
"    angleB = ASIN(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        angleB = PI-angleB;\n"
"}\n"
"else\n"
"   angleB = ACOS(cosangle);\n"
"angleB = (dot(v0b, cp1b) >= 0 ? angleB : -angleB);\n"
"angleB = fmod(angleB+2.0f*PI, 2.0f*PI);\n"
"\n"
"// Identify which patch this is in.\n"
"\n"
"int2 pos = MAP_POS[MAPS[index]];\n"
"int size = pos.y;\n"
"real delta = 2*PI/size;\n"
"int s = (int) fmin(angleA/delta, (real) (size-1));\n"
"int t = (int) fmin(angleB/delta, (real) (size-1));\n"
"float4 c[4];\n"
"int coeffIndex = pos.x+4*(s+size*t);\n"
"c[0] = COEFF[coeffIndex];\n"
"c[1] = COEFF[coeffIndex+1];\n"
"c[2] = COEFF[coeffIndex+2];\n"
"c[3] = COEFF[coeffIndex+3];\n"
"real da = angleA/delta-s;\n"
"real db = angleB/delta-t;\n"
"\n"
"// Evaluate the spline to determine the energy and gradients.\n"
"\n"
"real torsionEnergy = 0.0f;\n"
"real dEdA = 0.0f;\n"
"real dEdB = 0.0f;\n"
"torsionEnergy = da*torsionEnergy + ((c[3].w*db + c[3].z)*db + c[3].y)*db + c[3].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].w*da + 2.0f*c[2].w)*da + c[1].w;\n"
"dEdB = da*dEdB + (3.0f*c[3].w*db + 2.0f*c[3].z)*db + c[3].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[2].w*db + c[2].z)*db + c[2].y)*db + c[2].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].z*da + 2.0f*c[2].z)*da + c[1].z;\n"
"dEdB = da*dEdB + (3.0f*c[2].w*db + 2.0f*c[2].z)*db + c[2].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[1].w*db + c[1].z)*db + c[1].y)*db + c[1].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].y*da + 2.0f*c[2].y)*da + c[1].y;\n"
"dEdB = da*dEdB + (3.0f*c[1].w*db + 2.0f*c[1].z)*db + c[1].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[0].w*db + c[0].z)*db + c[0].y)*db + c[0].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].x*da + 2.0f*c[2].x)*da + c[1].x;\n"
"dEdB = da*dEdB + (3.0f*c[0].w*db + 2.0f*c[0].z)*db + c[0].y;\n"
"dEdA /= delta;\n"
"dEdB /= delta;\n"
"energy += torsionEnergy;\n"
"\n"
"// Apply the force to the first torsion.\n"
"\n"
"real normCross1 = dot(cp0a, cp0a);\n"
"real normSqrBC = dot(v1a, v1a);\n"
"real normBC = SQRT(normSqrBC);\n"
"real normCross2 = dot(cp1a, cp1a);\n"
"real dp = RECIP(normSqrBC);\n"
"real4 ff = make_real4((-dEdA*normBC)/normCross1, dot(v0a, v1a)*dp, dot(v2a, v1a)*dp, (dEdA*normBC)/normCross2);\n"
"real3 force1 = ff.x*cp0a;\n"
"real3 force4 = ff.w*cp1a;\n"
"real3 d = ff.y*force1 - ff.z*force4;\n"
"real3 force2 = d-force1;\n"
"real3 force3 = -d-force4;\n"
"\n"
"// Apply the force to the second torsion.\n"
"\n"
"normCross1 = dot(cp0b, cp0b);\n"
"normSqrBC = dot(v1b, v1b);\n"
"normBC = SQRT(normSqrBC);\n"
"normCross2 = dot(cp1b, cp1b);\n"
"dp = RECIP(normSqrBC);\n"
"ff = make_real4((-dEdB*normBC)/normCross1, dot(v0b, v1b)*dp, dot(v2b, v1b)*dp, (dEdB*normBC)/normCross2);\n"
"real3 force5 = ff.x*cp0b;\n"
"real3 force8 = ff.w*cp1b;\n"
"d = ff.y*force5 - ff.z*force8;\n"
"real3 force6 = d-force5;\n"
"real3 force7 = -d-force8;\n"
"";
const string CommonKernelSources::constraints = "KERNEL void applyPositionDeltas(int numAtoms, GLOBAL real4* RESTRICT posq, GLOBAL mixed4* RESTRICT posDelta\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"    for (unsigned int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"        real4 pos1 = posq[index];\n"
"        real4 pos2 = posqCorrection[index];\n"
"        mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"        mixed4 pos = posq[index];\n"
"#endif\n"
"        pos.x += posDelta[index].x;\n"
"        pos.y += posDelta[index].y;\n"
"        pos.z += posDelta[index].z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"        posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"        posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"        posq[index] = pos;\n"
"#endif\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::coulombLennardJones = "{\n"
"#if USE_EWALD\n"
"    unsigned int includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"    const real alphaR = EWALD_ALPHA*r;\n"
"    const real expAlphaRSqr = EXP(-alphaR*alphaR);\n"
"#if HAS_COULOMB\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2*invR;\n"
"#else\n"
"    const real prefactor = 0.0f;\n"
"#endif\n"
"\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    const real erfcAlphaR = erfc(alphaR);\n"
"#else\n"
"    // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"    // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"    // error of 1.5e-7.\n"
"\n"
"    const real t = RECIP(1.0f+0.3275911f*alphaR);\n"
"    const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*expAlphaRSqr;\n"
"#endif\n"
"    real tempForce = 0.0f;\n"
"#if HAS_LENNARD_JONES\n"
"    real sig = SIGMA_EPSILON1.x + SIGMA_EPSILON2.x;\n"
"    real sig2 = invR*sig;\n"
"    sig2 *= sig2;\n"
"    real sig6 = sig2*sig2*sig2;\n"
"    real eps = SIGMA_EPSILON1.y*SIGMA_EPSILON2.y;\n"
"    real epssig6 = sig6*eps;\n"
"    tempForce = epssig6*(12.0f*sig6 - 6.0f);\n"
"    real ljEnergy = epssig6*(sig6 - 1.0f);\n"
"    #if USE_LJ_SWITCH\n"
"    if (r > LJ_SWITCH_CUTOFF) {\n"
"        real x = r-LJ_SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(LJ_SWITCH_C3+x*(LJ_SWITCH_C4+x*LJ_SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*LJ_SWITCH_C3+x*(4*LJ_SWITCH_C4+x*5*LJ_SWITCH_C5));\n"
"        tempForce = tempForce*switchValue - ljEnergy*switchDeriv*r;\n"
"        ljEnergy *= switchValue;\n"
"    }\n"
"    #endif\n"
"#if DO_LJPME\n"
"    // The multiplicative term to correct for the multiplicative terms that are always\n"
"    // present in reciprocal space.\n"
"    const real dispersionAlphaR = EWALD_DISPERSION_ALPHA*r;\n"
"    const real dar2 = dispersionAlphaR*dispersionAlphaR;\n"
"    const real dar4 = dar2*dar2;\n"
"    const real dar6 = dar4*dar2;\n"
"    const real invR2 = invR*invR;\n"
"    const real expDar2 = EXP(-dar2);\n"
"    const float2 sigExpProd = SIGMA_EPSILON1*SIGMA_EPSILON2;\n"
"    const real c6 = 64*sigExpProd.x*sigExpProd.x*sigExpProd.x*sigExpProd.y;\n"
"    const real coef = invR2*invR2*invR2*c6;\n"
"    const real eprefac = 1.0f + dar2 + 0.5f*dar4;\n"
"    const real dprefac = eprefac + dar6/6.0f;\n"
"    // The multiplicative grid term\n"
"    ljEnergy += coef*(1.0f - expDar2*eprefac);\n"
"    tempForce += 6.0f*coef*(1.0f - expDar2*dprefac);\n"
"    // The potential shift accounts for the step at the cutoff introduced by the\n"
"    // transition from additive to multiplicative combintion rules and is only\n"
"    // needed for the real (not excluded) terms.  By addin these terms to ljEnergy\n"
"    // instead of tempEnergy here, the includeInteraction mask is correctly applied.\n"
"    sig2 = sig*sig;\n"
"    sig6 = sig2*sig2*sig2*INVCUT6;\n"
"    epssig6 = eps*sig6;\n"
"    // The additive part of the potential shift\n"
"    ljEnergy += epssig6*(1.0f - sig6);\n"
"    // The multiplicative part of the potential shift\n"
"    ljEnergy += MULTSHIFT6*c6;\n"
"#endif\n"
"    tempForce += prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    tempEnergy += includeInteraction ? ljEnergy + prefactor*erfcAlphaR : 0;\n"
"#else\n"
"    tempForce = prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    tempEnergy += includeInteraction ? prefactor*erfcAlphaR : 0;\n"
"#endif\n"
"    dEdR += includeInteraction ? tempForce*invR*invR : 0;\n"
"#else\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    unsigned int includeInteraction = (!isExcluded);\n"
"#endif\n"
"    real tempForce = 0.0f;\n"
"#if HAS_LENNARD_JONES\n"
"    real sig = SIGMA_EPSILON1.x + SIGMA_EPSILON2.x;\n"
"    real sig2 = invR*sig;\n"
"    sig2 *= sig2;\n"
"    real sig6 = sig2*sig2*sig2;\n"
"    real epssig6 = sig6*(SIGMA_EPSILON1.y*SIGMA_EPSILON2.y);\n"
"    tempForce = epssig6*(12.0f*sig6 - 6.0f);\n"
"    real ljEnergy = includeInteraction ? epssig6*(sig6 - 1) : 0;\n"
"    #if USE_LJ_SWITCH\n"
"    if (r > LJ_SWITCH_CUTOFF) {\n"
"        real x = r-LJ_SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(LJ_SWITCH_C3+x*(LJ_SWITCH_C4+x*LJ_SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*LJ_SWITCH_C3+x*(4*LJ_SWITCH_C4+x*5*LJ_SWITCH_C5));\n"
"        tempForce = tempForce*switchValue - ljEnergy*switchDeriv*r;\n"
"        ljEnergy *= switchValue;\n"
"    }\n"
"    #endif\n"
"    tempEnergy += ljEnergy;\n"
"#endif\n"
"#if HAS_COULOMB\n"
"  #ifdef USE_CUTOFF\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2;\n"
"    tempForce += prefactor*(invR - 2.0f*REACTION_FIELD_K*r2);\n"
"    tempEnergy += includeInteraction ? prefactor*(invR + REACTION_FIELD_K*r2 - REACTION_FIELD_C) : 0;\n"
"  #else\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2*invR;\n"
"    tempForce += prefactor;\n"
"    tempEnergy += includeInteraction ? prefactor : 0;\n"
"  #endif\n"
"#endif\n"
"    dEdR += includeInteraction ? tempForce*invR*invR : 0;\n"
"#endif\n"
"}\n"
"";
const string CommonKernelSources::customCVForce = "/**\n"
" * Copy the positions and velocities to the inner context.\n"
" */\n"
"KERNEL void copyState(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT innerPosq,\n"
"#ifdef USE_MIXED_PRECISION\n"
"        GLOBAL real4* RESTRICT posqCorrection, GLOBAL real4* RESTRICT innerPosqCorrection,\n"
"#endif\n"
"        GLOBAL mixed4* RESTRICT velm, GLOBAL mixed4* RESTRICT innerVelm, GLOBAL int* RESTRICT atomOrder, GLOBAL int* RESTRICT innerInvAtomOrder, int numAtoms) {\n"
"    for (int i = GLOBAL_ID; i < numAtoms; i += GLOBAL_SIZE) {\n"
"        int index = innerInvAtomOrder[atomOrder[i]];\n"
"        innerPosq[index] = posq[i];\n"
"        innerVelm[index] = velm[i];\n"
"#ifdef USE_MIXED_PRECISION\n"
"        innerPosqCorrection[index] = posqCorrection[i];\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the forces back to the main context.\n"
" */\n"
"KERNEL void copyForces(GLOBAL mm_long* RESTRICT forces, GLOBAL int* RESTRICT invAtomOrder, GLOBAL mm_long* RESTRICT innerForces,\n"
"        GLOBAL int* RESTRICT innerAtomOrder, int numAtoms, int paddedNumAtoms) {\n"
"    for (int i = GLOBAL_ID; i < numAtoms; i += GLOBAL_SIZE) {\n"
"        int index = invAtomOrder[innerAtomOrder[i]];\n"
"        forces[index] = innerForces[i];\n"
"        forces[index+paddedNumAtoms] = innerForces[i+paddedNumAtoms];\n"
"        forces[index+paddedNumAtoms*2] = innerForces[i+paddedNumAtoms*2];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Add all the forces from the CVs.\n"
" */\n"
"KERNEL void addForces(GLOBAL mm_long* RESTRICT forces, int bufferSize\n"
"    PARAMETER_ARGUMENTS) {\n"
"    for (int i = GLOBAL_ID; i < bufferSize; i += GLOBAL_SIZE) {\n"
"        ADD_FORCES\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customCentroidBond = "/**\n"
" * Compute the center of each group.\n"
" */\n"
"KERNEL void computeGroupCenters(int numParticleGroups, GLOBAL const real4* RESTRICT posq, GLOBAL const int* RESTRICT groupParticles,\n"
"        GLOBAL const real* RESTRICT groupWeights, GLOBAL const int* RESTRICT groupOffsets, GLOBAL real4* RESTRICT centerPositions) {\n"
"    LOCAL volatile real3 temp[64];\n"
"    for (int group = GROUP_ID; group < numParticleGroups; group += NUM_GROUPS) {\n"
"        // The threads in this block work together to compute the center one group.\n"
"\n"
"        int firstIndex = groupOffsets[group];\n"
"        int lastIndex = groupOffsets[group+1];\n"
"        real3 center = make_real3(0);\n"
"        for (int index = LOCAL_ID; index < lastIndex-firstIndex; index += LOCAL_SIZE) {\n"
"            int atom = groupParticles[firstIndex+index];\n"
"            real weight = groupWeights[firstIndex+index];\n"
"            real4 pos = posq[atom];\n"
"            center.x += weight*pos.x;\n"
"            center.y += weight*pos.y;\n"
"            center.z += weight*pos.z;\n"
"        }\n"
"\n"
"        // Sum the values.\n"
"\n"
"        int thread = LOCAL_ID;\n"
"        temp[thread].x = center.x;\n"
"        temp[thread].y = center.y;\n"
"        temp[thread].z = center.z;\n"
"        SYNC_THREADS;\n"
"        if (thread < 32) {\n"
"            temp[thread].x += temp[thread+32].x;\n"
"            temp[thread].y += temp[thread+32].y;\n"
"            temp[thread].z += temp[thread+32].z;\n"
"        }\n"
"        SYNC_WARPS;\n"
"        if (thread < 16) {\n"
"            temp[thread].x += temp[thread+16].x;\n"
"            temp[thread].y += temp[thread+16].y;\n"
"            temp[thread].z += temp[thread+16].z;\n"
"        }\n"
"        SYNC_WARPS;\n"
"        if (thread < 8) {\n"
"            temp[thread].x += temp[thread+8].x;\n"
"            temp[thread].y += temp[thread+8].y;\n"
"            temp[thread].z += temp[thread+8].z;\n"
"        }\n"
"        SYNC_WARPS;\n"
"        if (thread < 4) {\n"
"            temp[thread].x += temp[thread+4].x;\n"
"            temp[thread].y += temp[thread+4].y;\n"
"            temp[thread].z += temp[thread+4].z;\n"
"        }\n"
"        SYNC_WARPS;\n"
"        if (thread < 2) {\n"
"            temp[thread].x += temp[thread+2].x;\n"
"            temp[thread].y += temp[thread+2].y;\n"
"            temp[thread].z += temp[thread+2].z;\n"
"        }\n"
"        SYNC_WARPS;\n"
"        if (thread == 0)\n"
"            centerPositions[group] = make_real4(temp[0].x+temp[1].x, temp[0].y+temp[1].y, temp[0].z+temp[1].z, 0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the forces on groups based on the bonds.\n"
" */\n"
"KERNEL void computeGroupForces(int numParticleGroups, GLOBAL mm_ulong* RESTRICT groupForce, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT centerPositions,\n"
"        GLOBAL const int* RESTRICT bondGroups, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"        EXTRA_ARGS) {\n"
"    mixed energy = 0;\n"
"    INIT_PARAM_DERIVS\n"
"    for (int index = GLOBAL_ID; index < NUM_BONDS; index += GLOBAL_SIZE) {\n"
"        COMPUTE_FORCE\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"    SAVE_PARAM_DERIVS\n"
"}\n"
"\n"
"/**\n"
" * Apply the forces from the group centers to the individual atoms.\n"
" */\n"
"KERNEL void applyForcesToAtoms(int numParticleGroups, GLOBAL const int* RESTRICT groupParticles, GLOBAL const real* RESTRICT groupWeights, GLOBAL const int* RESTRICT groupOffsets,\n"
"        GLOBAL const mm_long* RESTRICT groupForce, GLOBAL mm_ulong* RESTRICT atomForce) {\n"
"    for (int group = GROUP_ID; group < numParticleGroups; group += NUM_GROUPS) {\n"
"        mm_long fx = groupForce[group];\n"
"        mm_long fy = groupForce[group+numParticleGroups];\n"
"        mm_long fz = groupForce[group+numParticleGroups*2];\n"
"        int firstIndex = groupOffsets[group];\n"
"        int lastIndex = groupOffsets[group+1];\n"
"        for (int index = LOCAL_ID; index < lastIndex-firstIndex; index += LOCAL_SIZE) {\n"
"            int atom = groupParticles[firstIndex+index];\n"
"            real weight = groupWeights[firstIndex+index];\n"
"            ATOMIC_ADD(&atomForce[atom], (mm_ulong) ((mm_long) (fx*weight)));\n"
"            ATOMIC_ADD(&atomForce[atom+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (fy*weight)));\n"
"            ATOMIC_ADD(&atomForce[atom+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (fz*weight)));\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customExternalForce = "COMPUTE_FORCE\n"
"real3 force1 = make_real3(-dEdX, -dEdY, -dEdZ);\n"
"";
const string CommonKernelSources::customGBChainRule = "#ifdef USE_CUTOFF\n"
"if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2 && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"#ifdef USE_SYMMETRIC\n"
"    real tempForce = 0;\n"
"#else\n"
"    real3 tempForce1 = make_real3(0);\n"
"    real3 tempForce2 = make_real3(0);\n"
"#endif\n"
"    COMPUTE_FORCE\n"
"#ifdef USE_SYMMETRIC\n"
"    dEdR += tempForce*invR;\n"
"#else\n"
"    dEdR1 += tempForce1;\n"
"    dEdR2 += tempForce2;\n"
"#endif\n"
"}\n"
"";
const string CommonKernelSources::customGBEnergyN2 = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#define STORE_DERIVATIVE_1(INDEX) ATOMIC_ADD(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (deriv##INDEX##_1*0x100000000)));\n"
"#define STORE_DERIVATIVE_2(INDEX) ATOMIC_ADD(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_deriv##INDEX[LOCAL_ID]*0x100000000)));\n"
"#else\n"
"#define STORE_DERIVATIVE_1(INDEX) derivBuffers##INDEX[offset] += deriv##INDEX##_1;\n"
"#define STORE_DERIVATIVE_2(INDEX) derivBuffers##INDEX[offset] += local_deriv##INDEX[LOCAL_ID];\n"
"#endif\n"
"\n"
"/**\n"
" * Compute a force based on pair interactions.\n"
" */\n"
"KERNEL void computeN2Energy(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers,\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* exclusionTiles, int needEnergy,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    mixed energy = 0;\n"
"    INIT_PARAM_DERIVS\n"
"    LOCAL real3 local_pos[LOCAL_BUFFER_SIZE];\n"
"    LOCAL real3 local_force[LOCAL_BUFFER_SIZE];\n"
"    ATOM_PARAMETER_DATA\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real3 force = make_real3(0);\n"
"        DECLARE_ATOM1_DERIVATIVES\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real3 pos1 = trimTo3(posq[atom1]);\n"
"        LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            local_pos[localAtomIndex] = pos1;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real3 pos2 = local_pos[atom2];\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    real dEdR = 0;\n"
"                    real tempEnergy = 0;\n"
"                    const real interactionScale = 0.5f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                        COMPUTE_INTERACTION\n"
"                        dEdR /= -r;\n"
"                    }\n"
"                    if (needEnergy)\n"
"                        energy += 0.5f*tempEnergy;\n"
"                    delta *= dEdR;\n"
"                    force.x -= delta.x;\n"
"                    force.y -= delta.y;\n"
"                    force.z -= delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            local_force[localAtomIndex] = make_real3(0);\n"
"            CLEAR_LOCAL_DERIVATIVES\n"
"            SYNC_WARPS;\n"
"#ifdef USE_EXCLUSIONS\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"                real3 pos2 = local_pos[atom2];\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+tj;\n"
"                    real dEdR = 0;\n"
"                    real tempEnergy = 0;\n"
"                    const real interactionScale = 1;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        COMPUTE_INTERACTION\n"
"                        dEdR /= -r;\n"
"                    }\n"
"                    if (needEnergy)\n"
"                        energy += tempEnergy;\n"
"                    delta *= dEdR;\n"
"                    force.x -= delta.x;\n"
"                    force.y -= delta.y;\n"
"                    force.z -= delta.z;\n"
"                    atom2 = tbx+tj;\n"
"                    local_force[atom2] += delta;\n"
"                    RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"        STORE_DERIVATIVES_1\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].z*0x100000000)));\n"
"            STORE_DERIVATIVES_2\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset = offset1;\n"
"        forceBuffers[offset1].xyz += force.xyz;\n"
"        STORE_DERIVATIVES_1\n"
"        if (x != y) {\n"
"            offset = offset2;\n"
"            forceBuffers[offset2] += (real4) (local_force[LOCAL_ID].x, local_force[LOCAL_ID].y, local_force[LOCAL_ID].z, 0.0f);\n"
"            STORE_DERIVATIVES_2\n"
"        }\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"    int end = (int) ((warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"#else\n"
"    int pos = (int) (warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[LOCAL_BUFFER_SIZE];\n"
"    LOCAL volatile int skipTiles[LOCAL_BUFFER_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        const bool isExcluded = false;\n"
"        real3 force = make_real3(0);\n"
"        DECLARE_ATOM1_DERIVATIVES\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            real3 pos1 = trimTo3(posq[atom1]);\n"
"            LOAD_ATOM1_PARAMETERS\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                local_force[localAtomIndex] = make_real3(0);\n"
"                CLEAR_LOCAL_DERIVATIVES\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(local_pos[LOCAL_ID], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = local_pos[atom2];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real dEdR = 0;\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        if (needEnergy)\n"
"                            energy += tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                        atom2 = tbx+tj;\n"
"                        local_force[atom2] += delta;\n"
"                        RECORD_DERIVATIVE_2\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = local_pos[atom2];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real dEdR = 0;\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        if (needEnergy)\n"
"                            energy += tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                        atom2 = tbx+tj;\n"
"                        local_force[atom2] += delta;\n"
"                        RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"        \n"
"            // Write results.\n"
"\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long)  (force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"            unsigned int offset = atom1;\n"
"            STORE_DERIVATIVES_1\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[LOCAL_ID].z*0x100000000)));\n"
"                offset = atom2;\n"
"                STORE_DERIVATIVES_2\n"
"            }\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"            forceBuffers[offset1].xyz += force.xyz;\n"
"            unsigned int offset = offset1;\n"
"            STORE_DERIVATIVES_1\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                forceBuffers[offset2] += (real4) (local_force[LOCAL_ID].x, local_force[LOCAL_ID].y, local_force[LOCAL_ID].z, 0.0f);\n"
"                offset = offset2;\n"
"                STORE_DERIVATIVES_2\n"
"            }\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"    SAVE_PARAM_DERIVS\n"
"}\n"
"";
const string CommonKernelSources::customGBEnergyN2_cpu = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#define STORE_DERIVATIVE_1(INDEX) ATOMIC_ADD(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (deriv##INDEX##_1*0x100000000)));\n"
"#define STORE_DERIVATIVE_2(INDEX) ATOMIC_ADD(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_deriv##INDEX[tgx]*0x100000000)));\n"
"#else\n"
"#define STORE_DERIVATIVE_1(INDEX) derivBuffers##INDEX[offset] += deriv##INDEX##_1;\n"
"#define STORE_DERIVATIVE_2(INDEX) derivBuffers##INDEX[offset] += local_deriv##INDEX[tgx];\n"
"#endif\n"
"\n"
"/**\n"
" * Compute a force based on pair interactions.\n"
" */\n"
"KERNEL void computeN2Energy(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers,\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* exclusionTiles, int needEnergy,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    mixed energy = 0;\n"
"    INIT_PARAM_DERIVS\n"
"    LOCAL real3 local_pos[LOCAL_BUFFER_SIZE];\n"
"    LOCAL real3 local_force[LOCAL_BUFFER_SIZE];\n"
"    ATOM_PARAMETER_DATA\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const int firstExclusionTile = FIRST_EXCLUSION_TILE+GROUP_ID*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    const int lastExclusionTile = FIRST_EXCLUSION_TILE+(GROUP_ID+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                DECLARE_ATOM1_DERIVATIVES\n"
"                real3 pos1 = trimTo3(posq[atom1]);\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = local_pos[j];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta, delta);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        real dEdR = 0;\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 0.5f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        energy += 0.5f*tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = atom1;\n"
"                ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"                STORE_DERIVATIVES_1\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz += force.xyz;\n"
"                STORE_DERIVATIVES_1\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                local_force[localAtomIndex] = 0;\n"
"                CLEAR_LOCAL_DERIVATIVES\n"
"            }\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                DECLARE_ATOM1_DERIVATIVES\n"
"                real3 pos1 = trimTo3(posq[atom1]);\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = local_pos[j];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        real dEdR = 0;\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                        if (!isExcluded) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        energy += tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                        atom2 = j;\n"
"                        local_force[atom2].xyz += delta.xyz;\n"
"                        RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = atom1;\n"
"                ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"                STORE_DERIVATIVES_1\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz += force.xyz;\n"
"                STORE_DERIVATIVES_1\n"
"#endif\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = y*TILE_SIZE+tgx;\n"
"                ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (local_force[tgx].x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[tgx].y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[tgx].z*0x100000000)));\n"
"                STORE_DERIVATIVES_2\n"
"#else\n"
"                unsigned int offset = y*TILE_SIZE+tgx + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz += local_force[tgx].xyz;\n"
"                STORE_DERIVATIVES_2\n"
"#endif\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (GROUP_ID*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"#else\n"
"    int pos = (int) (GROUP_ID*(mm_long)numTiles/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(mm_long)numTiles/NUM_GROUPS);\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    LOCAL int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        const bool isExcluded = false;\n"
"        bool includeTile = true;\n"
"        \n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                    local_force[localAtomIndex] = 0;\n"
"                    CLEAR_LOCAL_DERIVATIVES\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(local_pos[tgx], blockCenterX)\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    DECLARE_ATOM1_DERIVATIVES\n"
"                    real3 pos1 = trimTo3(posq[atom1]);\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = local_pos[j];\n"
"                        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"                            real dEdR = 0;\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                            energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            atom2 = j;\n"
"                            local_force[atom2].xyz += delta.xyz;\n"
"                            RECORD_DERIVATIVE_2\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    unsigned int offset = atom1;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"                    STORE_DERIVATIVES_1\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz += force.xyz;\n"
"                    STORE_DERIVATIVES_1\n"
"#endif\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    DECLARE_ATOM1_DERIVATIVES\n"
"                    real3 pos1 = trimTo3(posq[atom1]);\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = local_pos[j];\n"
"                        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"                            real dEdR = 0;\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                            energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            atom2 = j;\n"
"                            local_force[atom2] += delta;\n"
"                            RECORD_DERIVATIVE_2\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    unsigned int offset = atom1;\n"
"                    ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"                    STORE_DERIVATIVES_1\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz += force.xyz;\n"
"                    STORE_DERIVATIVES_1\n"
"#endif\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (local_force[tgx].x*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[tgx].y*0x100000000)));\n"
"                    ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (local_force[tgx].z*0x100000000)));\n"
"                    unsigned int offset = atom2;\n"
"                    STORE_DERIVATIVES_2\n"
"#else\n"
"                    unsigned int offset = atom2 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz += local_force[tgx].xyz;\n"
"                    STORE_DERIVATIVES_2\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"    SAVE_PARAM_DERIVS\n"
"}\n"
"";
const string CommonKernelSources::customGBEnergyPerParticle = "#define REDUCE_VALUE(NAME, TYPE) {\\\n"
"    TYPE sum = NAME[index]; \\\n"
"    for (int i = index+bufferSize; i < totalSize; i += bufferSize) \\\n"
"        sum += NAME[i]; \\\n"
"    NAME[index] = sum; \\\n"
"}\n"
"\n"
"/**\n"
" * Reduce the derivatives computed in the N^2 energy kernel, and compute all per-particle energy terms.\n"
" */\n"
"\n"
"KERNEL void computePerParticleEnergy(GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_long* RESTRICT forceBuffers\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers, int bufferSize, int numBuffers\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    mixed energy = 0;\n"
"    INIT_PARAM_DERIVS\n"
"    for (int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        // Reduce the derivatives\n"
"\n"
"#ifndef SUPPORTS_64_BIT_ATOMICS\n"
"        int totalSize = bufferSize*numBuffers;\n"
"#endif\n"
"        REDUCE_DERIVATIVES\n"
"\n"
"        // Now calculate the per-particle energy terms.\n"
"\n"
"        real4 pos = posq[index];\n"
"        real3 force = make_real3(0, 0, 0);\n"
"        COMPUTE_ENERGY\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"    SAVE_PARAM_DERIVS\n"
"}\n"
"";
const string CommonKernelSources::customGBGradientChainRule = "/**\n"
" * Compute chain rule terms for computed values that depend explicitly on particle coordinates.\n"
" */\n"
"\n"
"KERNEL void computeGradientChainRuleTerms(GLOBAL const real4* RESTRICT posq,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"    GLOBAL mm_long* RESTRICT forceBuffers\n"
"#else\n"
"    GLOBAL real4* RESTRICT forceBuffers\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    INIT_PARAM_DERIVS\n"
"    const real scale = RECIP((real) 0x100000000);\n"
"    for (int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        real4 pos = posq[index];\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        real3 force = make_real3(scale*forceBuffers[index], scale*forceBuffers[index+PADDED_NUM_ATOMS], scale*forceBuffers[index+PADDED_NUM_ATOMS*2]);\n"
"#else\n"
"        real3 force = trimTo3(forceBuffers[index]);\n"
"#endif\n"
"        COMPUTE_FORCES\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        forceBuffers[index] = (mm_long) (force.x*0x100000000);\n"
"        forceBuffers[index+PADDED_NUM_ATOMS] = (mm_long) (force.y*0x100000000);\n"
"        forceBuffers[index+PADDED_NUM_ATOMS*2] = (mm_long) (force.z*0x100000000);\n"
"#else\n"
"        forceBuffers[index] = make_real4(force.x, force.y, force.z, 0);\n"
"#endif\n"
"    }\n"
"    SAVE_PARAM_DERIVS\n"
"}\n"
"";
const string CommonKernelSources::customGBValueN2 = "/**\n"
" * Compute a value based on pair interactions.\n"
" */\n"
"KERNEL void computeN2Value(GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* exclusionTiles,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT global_value,\n"
"#else\n"
"        GLOBAL real* RESTRICT global_value,\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    LOCAL real3 local_pos[LOCAL_BUFFER_SIZE];\n"
"    LOCAL real local_value[LOCAL_BUFFER_SIZE];\n"
"    ATOM_PARAMETER_DATA\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real value = 0;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real3 pos1 = trimTo3(posq[atom1]);\n"
"        LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            local_pos[localAtomIndex] = pos1;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real3 pos2 = local_pos[atom2];\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    real tempValue1 = 0;\n"
"                    real tempValue2 = 0;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                    if (!isExcluded && atom1 != atom2) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                        COMPUTE_VALUE\n"
"                    }\n"
"                    value += tempValue1;\n"
"                    ADD_TEMP_DERIVS1\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            local_value[localAtomIndex] = 0;\n"
"            SYNC_WARPS;\n"
"#ifdef USE_EXCLUSIONS\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"                real3 pos2 = local_pos[atom2];\n"
"                real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+tj;\n"
"                    real tempValue1 = 0;\n"
"                    real tempValue2 = 0;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                    if (!isExcluded) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                        COMPUTE_VALUE\n"
"                    }\n"
"                    value += tempValue1;\n"
"                    local_value[tbx+tj] += tempValue2;\n"
"                    ADD_TEMP_DERIVS1\n"
"                    ADD_TEMP_DERIVS2\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"        STORE_PARAM_DERIVS1\n"
"        if (x != y) {\n"
"            unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&global_value[offset2], (mm_ulong) ((mm_long) (local_value[LOCAL_ID]*0x100000000)));\n"
"            STORE_PARAM_DERIVS2\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        global_value[offset1] += value;\n"
"        STORE_PARAM_DERIVS1\n"
"        if (x != y) {\n"
"            global_value[offset2] += local_value[LOCAL_ID];\n"
"            STORE_PARAM_DERIVS2\n"
"        }\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"    int end = (int) ((warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"#else\n"
"    int pos = (int) (warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[LOCAL_BUFFER_SIZE];\n"
"    LOCAL volatile int skipTiles[LOCAL_BUFFER_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        real value = 0;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"            \n"
"            real3 pos1 = trimTo3(posq[atom1]);\n"
"            LOAD_ATOM1_PARAMETERS\n"
"            const unsigned int localAtomIndex = LOCAL_ID;\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                local_value[localAtomIndex] = 0;\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(local_pos[LOCAL_ID], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = local_pos[atom2];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real tempValue1 = 0;\n"
"                        real tempValue2 = 0;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        local_value[tbx+tj] += tempValue2;\n"
"                        ADD_TEMP_DERIVS1\n"
"                        ADD_TEMP_DERIVS2\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real3 pos2 = local_pos[atom2];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"                        real tempValue1 = 0;\n"
"                        real tempValue2 = 0;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        local_value[tbx+tj] += tempValue2;\n"
"                        ADD_TEMP_DERIVS1\n"
"                        ADD_TEMP_DERIVS2\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"        \n"
"            // Write results.\n"
"\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            unsigned int offset1 = atom1;\n"
"            ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"            STORE_PARAM_DERIVS1\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                unsigned int offset2 = atom2;\n"
"                ATOMIC_ADD(&global_value[offset2], (mm_ulong) ((mm_long) (local_value[LOCAL_ID]*0x100000000)));\n"
"                STORE_PARAM_DERIVS2\n"
"            }\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            global_value[offset1] += value;\n"
"            STORE_PARAM_DERIVS1\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"                global_value[offset2] += local_value[LOCAL_ID];\n"
"                STORE_PARAM_DERIVS2\n"
"            }\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customGBValueN2_cpu = "/**\n"
" * Compute a value based on pair interactions.\n"
" */\n"
"KERNEL void computeN2Value(GLOBAL const real4* RESTRICT posq, GLOBAL const unsigned int* RESTRICT exclusions,\n"
"        GLOBAL const int2* exclusionTiles,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT global_value,\n"
"#else\n"
"        GLOBAL real* RESTRICT global_value,\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    LOCAL real3 local_pos[LOCAL_BUFFER_SIZE];\n"
"    LOCAL real local_value[LOCAL_BUFFER_SIZE];\n"
"    ATOM_PARAMETER_DATA\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const int firstExclusionTile = FIRST_EXCLUSION_TILE+get_group_id(0)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    const int lastExclusionTile = FIRST_EXCLUSION_TILE+(get_group_id(0)+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real value = 0;\n"
"                real3 pos1 = trimTo3(posq[atom1]);\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = local_pos[j];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        real tempValue1 = 0;\n"
"                        real tempValue2 = 0;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                        if (!isExcluded && atom1 != atom2) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        ADD_TEMP_DERIVS1\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset1 = atom1;\n"
"                ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"#else\n"
"                unsigned int offset1 = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_value[offset1] += value;\n"
"#endif\n"
"                STORE_PARAM_DERIVS1\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                local_value[tgx] = 0;\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real value = 0;\n"
"                real3 pos1 = trimTo3(posq[atom1]);\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = local_pos[j];\n"
"                    real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        real tempValue1 = 0;\n"
"                        real tempValue2 = 0;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"                        if (!isExcluded) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        local_value[j] += tempValue2;\n"
"                        ADD_TEMP_DERIVS1\n"
"                        ADD_TEMP_DERIVS2\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset1 = atom1;\n"
"                ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"#else\n"
"                unsigned int offset1 = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_value[offset1] += value;\n"
"#endif\n"
"                STORE_PARAM_DERIVS1\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset2 = y*TILE_SIZE+tgx;\n"
"                ATOMIC_ADD(&global_value[offset2], (mm_ulong) ((mm_long) (local_value[tgx]*0x100000000)));\n"
"#else\n"
"                unsigned int offset2 = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_value[offset2] += local_value[tgx];\n"
"#endif\n"
"                STORE_PARAM_DERIVS2\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0));\n"
"    int end = (int) ((get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0));\n"
"#else\n"
"    int pos = (int) (get_group_id(0)*(mm_long)numTiles/get_num_groups(0));\n"
"    int end = (int) ((get_group_id(0)+1)*(mm_long)numTiles/get_num_groups(0));\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    LOCAL int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"        \n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    local_pos[localAtomIndex] = trimTo3(posq[j]);\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                    local_value[localAtomIndex] = 0;\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(local_pos[tgx], blockCenterX)\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real value = 0;\n"
"                    real3 pos1 = trimTo3(posq[atom1]);\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = local_pos[j];\n"
"                        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"                            real tempValue1 = 0;\n"
"                            real tempValue2 = 0;\n"
"                            COMPUTE_VALUE\n"
"                            value += tempValue1;\n"
"                            local_value[j] += tempValue2;\n"
"                            ADD_TEMP_DERIVS1\n"
"                            ADD_TEMP_DERIVS2\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    unsigned int offset1 = atom1;\n"
"                    ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"#else\n"
"                    unsigned int offset1 = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    global_value[offset1] += value;\n"
"#endif\n"
"                    STORE_PARAM_DERIVS1\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real value = 0;\n"
"                    real3 pos1 = trimTo3(posq[atom1]);\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = local_pos[j];\n"
"                        real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atomIndices[j] < NUM_ATOMS) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"                            real tempValue1 = 0;\n"
"                            real tempValue2 = 0;\n"
"                            COMPUTE_VALUE\n"
"                            value += tempValue1;\n"
"                            local_value[j] += tempValue2;\n"
"                            ADD_TEMP_DERIVS1\n"
"                            ADD_TEMP_DERIVS2\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    unsigned int offset1 = atom1;\n"
"                    ATOMIC_ADD(&global_value[offset1], (mm_ulong) ((mm_long) (value*0x100000000)));\n"
"#else\n"
"                    unsigned int offset1 = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    global_value[offset1] += value;\n"
"#endif\n"
"                    STORE_PARAM_DERIVS1\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    unsigned int offset2 = atom2;\n"
"                    ATOMIC_ADD(&global_value[offset2], (mm_ulong) ((mm_long) (local_value[tgx]*0x100000000)));\n"
"#else\n"
"                    unsigned int offset2 = atom2 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    global_value[offset2] += local_value[tgx];\n"
"#endif\n"
"                    STORE_PARAM_DERIVS2\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customGBValuePerParticle = "/**\n"
" * Reduce a pairwise computed value, and compute per-particle values.\n"
" */\n"
"\n"
"KERNEL void computePerParticleValues(GLOBAL real4* posq,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_long* valueBuffers\n"
"#else\n"
"        GLOBAL real* valueBuffers, int bufferSize, int numBuffers\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    for (int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        // Reduce the pairwise value\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        real sum = valueBuffers[index]/(real) 0x100000000;\n"
"#else\n"
"        int totalSize = bufferSize*numBuffers;\n"
"        real sum = valueBuffers[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += valueBuffers[i];\n"
"#endif\n"
"        REDUCE_PARAM0_DERIV\n"
"        \n"
"        // Now calculate other values\n"
"\n"
"        real4 pos = posq[index];\n"
"        COMPUTE_VALUES\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customHbondForce = "/**\n"
" * Compute the difference between two vectors, optionally taking periodic boundary conditions into account\n"
" * and setting the fourth component to the squared magnitude.\n"
" */\n"
"inline DEVICE real4 delta(real4 vec1, real4 vec2, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ) {\n"
"    real4 result = make_real4(vec1.x-vec2.x, vec1.y-vec2.y, vec1.z-vec2.z, 0);\n"
"#ifdef USE_PERIODIC\n"
"    APPLY_PERIODIC_TO_DELTA(result)\n"
"#endif\n"
"    result.w = result.x*result.x + result.y*result.y + result.z*result.z;\n"
"    return result;\n"
"}\n"
"\n"
"/**\n"
" * Compute the angle between two vectors.  The w component of each vector should contain the squared magnitude.\n"
" */\n"
"inline DEVICE real computeAngle(real4 vec1, real4 vec2) {\n"
"    real dotProduct = vec1.x*vec2.x + vec1.y*vec2.y + vec1.z*vec2.z;\n"
"    real cosine = dotProduct*RSQRT(vec1.w*vec2.w);\n"
"    real angle;\n"
"    if (cosine > 0.99f || cosine < -0.99f) {\n"
"        // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"        real3 crossProduct = cross(trimTo3(vec1), trimTo3(vec2));\n"
"        real scale = vec1.w*vec2.w;\n"
"        angle = ASIN(SQRT(dot(crossProduct, crossProduct)/scale));\n"
"        if (cosine < 0)\n"
"            angle = M_PI-angle;\n"
"    }\n"
"    else\n"
"       angle = ACOS(cosine);\n"
"    return angle;\n"
"}\n"
"\n"
"/**\n"
" * Compute the cross product of two vectors, setting the fourth component to the squared magnitude.\n"
" */\n"
"inline DEVICE real4 computeCross(real4 vec1, real4 vec2) {\n"
"    real3 cp = cross(trimTo3(vec1), trimTo3(vec2));\n"
"    return make_real4(cp.x, cp.y, cp.z, cp.x*cp.x+cp.y*cp.y+cp.z*cp.z);\n"
"}\n"
"\n"
"/**\n"
" * Compute forces on donors.\n"
" */\n"
"KERNEL void computeDonorForces(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"	GLOBAL mm_ulong* RESTRICT force,\n"
"#else\n"
"	GLOBAL real4* RESTRICT forceBuffers, GLOBAL const int4* RESTRICT donorBufferIndices,\n"
"#endif\n"
"	GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT exclusions,\n"
"        GLOBAL const int4* RESTRICT donorAtoms, GLOBAL const int4* RESTRICT acceptorAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"        PARAMETER_ARGUMENTS) {\n"
"    LOCAL real4 posBuffer[3*THREAD_BLOCK_SIZE];\n"
"    mixed energy = 0;\n"
"    real3 f1 = make_real3(0);\n"
"    real3 f2 = make_real3(0);\n"
"    real3 f3 = make_real3(0);\n"
"    for (int donorStart = 0; donorStart < NUM_DONORS; donorStart += GLOBAL_SIZE) {\n"
"        // Load information about the donor this thread will compute forces on.\n"
"\n"
"        int donorIndex = donorStart+GLOBAL_ID;\n"
"        int4 atoms, exclusionIndices;\n"
"        real4 d1, d2, d3;\n"
"        if (donorIndex < NUM_DONORS) {\n"
"            atoms = donorAtoms[donorIndex];\n"
"            d1 = (atoms.x > -1 ? posq[atoms.x] : make_real4(0));\n"
"            d2 = (atoms.y > -1 ? posq[atoms.y] : make_real4(0));\n"
"            d3 = (atoms.z > -1 ? posq[atoms.z] : make_real4(0));\n"
"#ifdef USE_EXCLUSIONS\n"
"            exclusionIndices = exclusions[donorIndex];\n"
"#endif\n"
"        }\n"
"        else\n"
"            atoms = make_int4(-1, -1, -1, -1);\n"
"        for (int acceptorStart = 0; acceptorStart < NUM_ACCEPTORS; acceptorStart += LOCAL_SIZE) {\n"
"            // Load the next block of acceptors into local memory.\n"
"\n"
"            SYNC_THREADS;\n"
"            int blockSize = min((int) LOCAL_SIZE, NUM_ACCEPTORS-acceptorStart);\n"
"            if (LOCAL_ID < blockSize) {\n"
"                int4 atoms2 = acceptorAtoms[acceptorStart+LOCAL_ID];\n"
"                posBuffer[3*LOCAL_ID] = (atoms2.x > -1 ? posq[atoms2.x] : make_real4(0));\n"
"                posBuffer[3*LOCAL_ID+1] = (atoms2.y > -1 ? posq[atoms2.y] : make_real4(0));\n"
"                posBuffer[3*LOCAL_ID+2] = (atoms2.z > -1 ? posq[atoms2.z] : make_real4(0));\n"
"            }\n"
"            SYNC_THREADS;\n"
"            if (donorIndex < NUM_DONORS) {\n"
"                for (int index = 0; index < blockSize; index++) {\n"
"                    int acceptorIndex = acceptorStart+index;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    if (acceptorIndex == exclusionIndices.x || acceptorIndex == exclusionIndices.y || acceptorIndex == exclusionIndices.z || acceptorIndex == exclusionIndices.w)\n"
"                        continue;\n"
"#endif\n"
"                    // Compute the interaction between a donor and an acceptor.\n"
"\n"
"                    real4 a1 = posBuffer[3*index];\n"
"                    real4 a2 = posBuffer[3*index+1];\n"
"                    real4 a3 = posBuffer[3*index+2];\n"
"                    real4 deltaD1A1 = delta(d1, a1, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"#ifdef USE_CUTOFF\n"
"                    if (deltaD1A1.w < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        COMPUTE_DONOR_FORCE\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        // Write results\n"
"\n"
"        if (donorIndex < NUM_DONORS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            if (atoms.x > -1) {\n"
"                ATOMIC_ADD(&force[atoms.x], (mm_ulong) ((mm_long) (f1.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.x+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f1.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.x+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f1.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                ATOMIC_ADD(&force[atoms.y], (mm_ulong) ((mm_long) (f2.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.y+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f2.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.y+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f2.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                ATOMIC_ADD(&force[atoms.z], (mm_ulong) ((mm_long) (f3.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.z+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f3.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.z+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f3.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"#else\n"
"            int4 bufferIndices = donorBufferIndices[donorIndex];\n"
"            if (atoms.x > -1) {\n"
"                unsigned int offset = atoms.x+bufferIndices.x*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f1.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                unsigned int offset = atoms.y+bufferIndices.y*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f2.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                unsigned int offset = atoms.z+bufferIndices.z*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f3.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"#endif\n"
"        }\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"/**\n"
" * Compute forces on acceptors.\n"
" */\n"
"KERNEL void computeAcceptorForces(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"	GLOBAL mm_ulong* RESTRICT force,\n"
"#else\n"
"	GLOBAL real4* RESTRICT forceBuffers, GLOBAL const int4* RESTRICT acceptorBufferIndices,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT exclusions,\n"
"        GLOBAL const int4* RESTRICT donorAtoms, GLOBAL const int4* RESTRICT acceptorAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"        PARAMETER_ARGUMENTS) {\n"
"    LOCAL real4 posBuffer[3*THREAD_BLOCK_SIZE];\n"
"    real3 f1 = make_real3(0);\n"
"    real3 f2 = make_real3(0);\n"
"    real3 f3 = make_real3(0);\n"
"    for (int acceptorStart = 0; acceptorStart < NUM_ACCEPTORS; acceptorStart += GLOBAL_SIZE) {\n"
"        // Load information about the acceptor this thread will compute forces on.\n"
"\n"
"        int acceptorIndex = acceptorStart+GLOBAL_ID;\n"
"        int4 atoms, exclusionIndices;\n"
"        real4 a1, a2, a3;\n"
"        if (acceptorIndex < NUM_ACCEPTORS) {\n"
"            atoms = acceptorAtoms[acceptorIndex];\n"
"            a1 = (atoms.x > -1 ? posq[atoms.x] : make_real4(0));\n"
"            a2 = (atoms.y > -1 ? posq[atoms.y] : make_real4(0));\n"
"            a3 = (atoms.z > -1 ? posq[atoms.z] : make_real4(0));\n"
"#ifdef USE_EXCLUSIONS\n"
"            exclusionIndices = exclusions[acceptorIndex];\n"
"#endif\n"
"        }\n"
"        else\n"
"            atoms = make_int4(-1, -1, -1, -1);\n"
"        for (int donorStart = 0; donorStart < NUM_DONORS; donorStart += LOCAL_SIZE) {\n"
"            // Load the next block of donors into local memory.\n"
"\n"
"            SYNC_THREADS;\n"
"            int blockSize = min((int) LOCAL_SIZE, NUM_DONORS-donorStart);\n"
"            if (LOCAL_ID < blockSize) {\n"
"                int4 atoms2 = donorAtoms[donorStart+LOCAL_ID];\n"
"                posBuffer[3*LOCAL_ID] = (atoms2.x > -1 ? posq[atoms2.x] : make_real4(0));\n"
"                posBuffer[3*LOCAL_ID+1] = (atoms2.y > -1 ? posq[atoms2.y] : make_real4(0));\n"
"                posBuffer[3*LOCAL_ID+2] = (atoms2.z > -1 ? posq[atoms2.z] : make_real4(0));\n"
"            }\n"
"            SYNC_THREADS;\n"
"            if (acceptorIndex < NUM_ACCEPTORS) {\n"
"                for (int index = 0; index < blockSize; index++) {\n"
"                    int donorIndex = donorStart+index;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    if (donorIndex == exclusionIndices.x || donorIndex == exclusionIndices.y || donorIndex == exclusionIndices.z || donorIndex == exclusionIndices.w)\n"
"                        continue;\n"
"#endif\n"
"                    // Compute the interaction between a donor and an acceptor.\n"
"\n"
"                    real4 d1 = posBuffer[3*index];\n"
"                    real4 d2 = posBuffer[3*index+1];\n"
"                    real4 d3 = posBuffer[3*index+2];\n"
"                    real4 deltaD1A1 = delta(d1, a1, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"#ifdef USE_CUTOFF\n"
"                    if (deltaD1A1.w < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        COMPUTE_ACCEPTOR_FORCE\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        // Write results\n"
"\n"
"        if (acceptorIndex < NUM_ACCEPTORS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            if (atoms.x > -1) {\n"
"                ATOMIC_ADD(&force[atoms.x], (mm_ulong) ((mm_long) (f1.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.x+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f1.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.x+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f1.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                ATOMIC_ADD(&force[atoms.y], (mm_ulong) ((mm_long) (f2.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.y+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f2.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.y+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f2.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                ATOMIC_ADD(&force[atoms.z], (mm_ulong) ((mm_long) (f3.x*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.z+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f3.y*0x100000000)));\n"
"                ATOMIC_ADD(&force[atoms.z+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (f3.z*0x100000000)));\n"
"                MEM_FENCE;\n"
"            }\n"
"#else\n"
"            int4 bufferIndices = acceptorBufferIndices[acceptorIndex];\n"
"            if (atoms.x > -1) {\n"
"                unsigned int offset = atoms.x+bufferIndices.x*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f1.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                unsigned int offset = atoms.y+bufferIndices.y*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f2.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                unsigned int offset = atoms.z+bufferIndices.z*PADDED_NUM_ATOMS;\n"
"                real4 force = forceBuffers[offset];\n"
"                force.xyz += f3.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"#endif\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customIntegrator = "KERNEL void computeFloatSum(GLOBAL const float* RESTRICT sumBuffer, GLOBAL float* result, int bufferSize) {\n"
"    LOCAL float tempBuffer[WORK_GROUP_SIZE];\n"
"    const unsigned int thread = LOCAL_ID;\n"
"    float sum = 0;\n"
"    for (unsigned int index = thread; index < bufferSize; index += LOCAL_SIZE)\n"
"        sum += sumBuffer[index];\n"
"    tempBuffer[thread] = sum;\n"
"    for (int i = 1; i < WORK_GROUP_SIZE; i *= 2) {\n"
"        SYNC_THREADS;\n"
"        if (thread%(i*2) == 0 && thread+i < WORK_GROUP_SIZE)\n"
"            tempBuffer[thread] += tempBuffer[thread+i];\n"
"    }\n"
"    if (thread == 0)\n"
"        *result = tempBuffer[0];\n"
"}\n"
"\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"KERNEL void computeDoubleSum(GLOBAL const double* RESTRICT sumBuffer, GLOBAL double* result, int bufferSize) {\n"
"    LOCAL double tempBuffer[WORK_GROUP_SIZE];\n"
"    const unsigned int thread = LOCAL_ID;\n"
"    double sum = 0;\n"
"    for (unsigned int index = thread; index < bufferSize; index += LOCAL_SIZE)\n"
"        sum += sumBuffer[index];\n"
"    tempBuffer[thread] = sum;\n"
"    for (int i = 1; i < WORK_GROUP_SIZE; i *= 2) {\n"
"        SYNC_THREADS;\n"
"        if (thread%(i*2) == 0 && thread+i < WORK_GROUP_SIZE)\n"
"            tempBuffer[thread] += tempBuffer[thread+i];\n"
"    }\n"
"    if (thread == 0)\n"
"        *result = tempBuffer[0];\n"
"}\n"
"#endif\n"
"\n"
"KERNEL void applyPositionDeltas(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, GLOBAL mixed4* RESTRICT posDelta) {\n"
"    for (unsigned int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"        real4 pos1 = posq[index];\n"
"        real4 pos2 = posqCorrection[index];\n"
"        mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"        real4 pos = posq[index];\n"
"#endif\n"
"        pos.x += posDelta[index].x;\n"
"        pos.y += posDelta[index].y;\n"
"        pos.z += posDelta[index].z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"        posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"        posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"        posq[index] = pos;\n"
"#endif\n"
"        posDelta[index] = make_mixed4(0);\n"
"    }\n"
"}\n"
"\n"
"KERNEL void generateRandomNumbers(int numValues, GLOBAL float4* RESTRICT random, GLOBAL uint4* RESTRICT seed) {\n"
"    uint4 state = seed[GLOBAL_ID];\n"
"    unsigned int carry = 0;\n"
"    for (int index = GLOBAL_ID; index < numValues; index += GLOBAL_SIZE) {\n"
"        // Generate three uniform random numbers.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        unsigned int k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        unsigned int m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x1 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x2 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x3 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"\n"
"        // Record the values.\n"
"\n"
"        random[index] = make_float4(x1, x2, x3, 0.0f);\n"
"    }\n"
"    seed[GLOBAL_ID] = state;\n"
"}\n"
"";
const string CommonKernelSources::customIntegratorPerDof = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"typedef double TempType;\n"
"typedef double3 TempType3;\n"
"typedef double4 TempType4;\n"
"\n"
"#define make_TempType3 make_double3\n"
"#define make_TempType4 make_double4\n"
"#define convertToTempType3(a) make_double3((a).x, (a).y, (a).z)\n"
"#define convertToTempType4(a) make_double4((a).x, (a).y, (a).z, (a).w)\n"
"\n"
"inline DEVICE mixed4 convertFromDouble4(double4 a) {\n"
"    return make_mixed4(a.x, a.y, a.z, a.w);\n"
"}\n"
"#else\n"
"typedef float TempType;\n"
"typedef float3 TempType3;\n"
"typedef float4 TempType4;\n"
"\n"
"#define make_TempType3 make_float3\n"
"#define make_TempType4 make_float4\n"
"#define convertToTempType3(a) make_float3((a).x, (a).y, (a).z)\n"
"#define convertToTempType4(a) make_float4((a).x, (a).y, (a).z, (a).w)\n"
"#endif\n"
"\n"
"/**\n"
" * Load the position of a particle.\n"
" */\n"
"inline DEVICE TempType4 loadPos(GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT posqCorrection, int index) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"    real4 pos1 = posq[index];\n"
"    real4 pos2 = posqCorrection[index];\n"
"    return make_TempType4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"    return convertToTempType4(posq[index]);\n"
"#endif\n"
"}\n"
"\n"
"/**\n"
" * Store the position of a particle.\n"
" */\n"
"inline DEVICE void storePos(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, int index, TempType4 pos) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"    posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"    posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"    posq[index] = make_real4(pos.x, pos.y, pos.z, pos.w);\n"
"#endif\n"
"}\n"
"\n"
"KERNEL void computePerDof(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, GLOBAL const mixed2* RESTRICT dt, GLOBAL const mixed* RESTRICT globals,\n"
"        GLOBAL mixed* RESTRICT sum, GLOBAL const float4* RESTRICT gaussianValues, unsigned int gaussianBaseIndex, GLOBAL const float4* RESTRICT uniformValues,\n"
"        const mixed energy, GLOBAL mixed* RESTRICT energyParamDerivs\n"
"        PARAMETER_ARGUMENTS) {\n"
"    TempType3 stepSize = make_TempType3(dt[0].y);\n"
"    int index = GLOBAL_ID;\n"
"    const TempType forceScale = ((TempType) 1)/0xFFFFFFFF;\n"
"    while (index < NUM_ATOMS) {\n"
"#ifdef LOAD_POS_AS_DELTA\n"
"        TempType4 position = loadPos(posq, posqCorrection, index) + convertToTempType4(posDelta[index]);\n"
"#else\n"
"        TempType4 position = loadPos(posq, posqCorrection, index);\n"
"#endif\n"
"        TempType4 velocity = convertToTempType4(velm[index]);\n"
"        TempType3 f = make_TempType3(forceScale*force[index], forceScale*force[index+PADDED_NUM_ATOMS], forceScale*force[index+PADDED_NUM_ATOMS*2]);\n"
"        TempType3 mass = make_TempType3(RECIP(velocity.w));\n"
"        if (velocity.w != 0.0) {\n"
"            int gaussianIndex = gaussianBaseIndex;\n"
"            int uniformIndex = 0;\n"
"            COMPUTE_STEP\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customManyParticle = "/**\n"
" * Record the force on an atom to global memory.\n"
" */\n"
"inline DEVICE void storeForce(int atom, real3 force, GLOBAL mm_ulong* RESTRICT forceBuffers) {\n"
"    ATOMIC_ADD(&forceBuffers[atom], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"    ATOMIC_ADD(&forceBuffers[atom+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"    ATOMIC_ADD(&forceBuffers[atom+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"}\n"
"\n"
"/**\n"
" * Compute the difference between two vectors, taking periodic boundary conditions into account\n"
" * and setting the fourth component to the squared magnitude.\n"
" */\n"
"inline DEVICE real4 delta(real3 vec1, real3 vec2, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ) {\n"
"    real4 result = make_real4(vec1.x-vec2.x, vec1.y-vec2.y, vec1.z-vec2.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"    APPLY_PERIODIC_TO_DELTA(result)\n"
"#endif\n"
"    result.w = result.x*result.x + result.y*result.y + result.z*result.z;\n"
"    return result;\n"
"}\n"
"\n"
"/**\n"
" * Determine whether a particular interaction is in the list of exclusions.\n"
" */\n"
"inline DEVICE bool isInteractionExcluded(int atom1, int atom2, GLOBAL const int* RESTRICT exclusions, GLOBAL const int* RESTRICT exclusionStartIndex) {\n"
"    if (atom1 > atom2) {\n"
"        int temp = atom1;\n"
"        atom1 = atom2;\n"
"        atom2 = temp;\n"
"    }\n"
"    int first = exclusionStartIndex[atom1];\n"
"    int last = exclusionStartIndex[atom1+1];\n"
"    for (int i = last-1; i >= first; i--) {\n"
"        int excluded = exclusions[i];\n"
"        if (excluded == atom2)\n"
"            return true;\n"
"        if (excluded <= atom1)\n"
"            return false;\n"
"    }\n"
"    return false;\n"
"}\n"
"\n"
"/**\n"
" * Compute the interaction.\n"
" */\n"
"KERNEL void computeInteraction(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"#ifdef USE_CUTOFF\n"
"        , GLOBAL const int* RESTRICT neighbors, GLOBAL const int* RESTRICT neighborStartIndex\n"
"#endif\n"
"#ifdef USE_FILTERS\n"
"        , GLOBAL int* RESTRICT particleTypes, GLOBAL int* RESTRICT orderIndex, GLOBAL int* RESTRICT particleOrder\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"        , GLOBAL int* RESTRICT exclusions, GLOBAL int* RESTRICT exclusionStartIndex\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    mixed energy = 0;\n"
"    \n"
"    // Loop over particles to be the first one in the set.\n"
"    \n"
"    for (int p1 = GROUP_ID; p1 < NUM_ATOMS; p1 += NUM_GROUPS) {\n"
"#ifdef USE_CENTRAL_PARTICLE\n"
"        const int a1 = p1;\n"
"#else\n"
"        const int a1 = 0;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"        int firstNeighbor = neighborStartIndex[p1];\n"
"        int numNeighbors = neighborStartIndex[p1+1]-firstNeighbor;\n"
"#else\n"
"  #ifdef USE_CENTRAL_PARTICLE\n"
"        int numNeighbors = NUM_ATOMS;\n"
"  #else\n"
"        int numNeighbors = NUM_ATOMS-p1-1;\n"
"  #endif\n"
"#endif\n"
"        int numCombinations = NUM_CANDIDATE_COMBINATIONS;\n"
"        for (int index = LOCAL_ID; index < numCombinations; index += LOCAL_SIZE) {\n"
"            FIND_ATOMS_FOR_COMBINATION_INDEX;\n"
"            bool includeInteraction = IS_VALID_COMBINATION;\n"
"#ifdef USE_CUTOFF\n"
"            if (includeInteraction) {\n"
"                VERIFY_CUTOFF;\n"
"            }\n"
"#endif\n"
"#ifdef USE_FILTERS\n"
"            int order = orderIndex[COMPUTE_TYPE_INDEX];\n"
"            if (order == -1)\n"
"                includeInteraction = false;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"            if (includeInteraction) {\n"
"                VERIFY_EXCLUSIONS;\n"
"            }\n"
"#endif\n"
"            if (includeInteraction) {\n"
"                PERMUTE_ATOMS;\n"
"                LOAD_PARTICLE_DATA;\n"
"                COMPUTE_INTERACTION;\n"
"            }\n"
"        }\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"KERNEL void findBlockBounds(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL real4* RESTRICT blockCenter, GLOBAL real4* RESTRICT blockBoundingBox, GLOBAL int* RESTRICT numNeighborPairs) {\n"
"    int index = GLOBAL_ID;\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < NUM_ATOMS) {\n"
"        real4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, NUM_ATOMS);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = make_real4(min(minPos.x,pos.x), min(minPos.y,pos.y), min(minPos.z,pos.z), 0);\n"
"            maxPos = make_real4(max(maxPos.x,pos.x), max(maxPos.y,pos.y), max(maxPos.z,pos.z), 0);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        index += GLOBAL_SIZE;\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (GROUP_ID == 0 && LOCAL_ID == 0)\n"
"        *numNeighborPairs = 0;\n"
"}\n"
"\n"
"/**\n"
" * Find a list of neighbors for each atom.\n"
" */\n"
"KERNEL void findNeighbors(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT blockCenter, GLOBAL const real4* RESTRICT blockBoundingBox, GLOBAL int2* RESTRICT neighborPairs,\n"
"        GLOBAL int* RESTRICT numNeighborPairs, GLOBAL int* RESTRICT numNeighborsForAtom, int maxNeighborPairs\n"
"#ifdef USE_EXCLUSIONS\n"
"        , GLOBAL const int* RESTRICT exclusions, GLOBAL const int* RESTRICT exclusionStartIndex\n"
"#endif\n"
"        ) {\n"
"    LOCAL real3 positionCache[FIND_NEIGHBORS_WORKGROUP_SIZE];\n"
"    int indexInWarp = LOCAL_ID%32;\n"
"#ifndef __CUDA_ARCH__\n"
"    LOCAL bool includeBlockFlags[FIND_NEIGHBORS_WORKGROUP_SIZE];\n"
"    int warpStart = LOCAL_ID-indexInWarp;\n"
"#endif\n"
"    for (int atom1 = GLOBAL_ID; atom1 < PADDED_NUM_ATOMS; atom1 += GLOBAL_SIZE) {\n"
"        // Load data for this atom.  Note that all threads in a warp are processing atoms from the same block.\n"
"        \n"
"        real3 pos1 = trimTo3(posq[atom1]);\n"
"        int block1 = atom1/TILE_SIZE;\n"
"        real4 blockCenter1 = blockCenter[block1];\n"
"        real4 blockSize1 = blockBoundingBox[block1];\n"
"        int totalNeighborsForAtom1 = 0;\n"
"        \n"
"        // Loop over atom blocks to search for neighbors.  The threads in a warp compare block1 against 32\n"
"        // other blocks in parallel.\n"
"\n"
"#ifdef USE_CENTRAL_PARTICLE\n"
"        int startBlock = 0;\n"
"#else\n"
"        int startBlock = block1;\n"
"#endif\n"
"        for (int block2Base = startBlock; block2Base < NUM_BLOCKS; block2Base += 32) {\n"
"            int block2 = block2Base+indexInWarp;\n"
"            bool includeBlock2 = (block2 < NUM_BLOCKS);\n"
"            if (includeBlock2) {\n"
"                real4 blockCenter2 = blockCenter[block2];\n"
"                real4 blockSize2 = blockBoundingBox[block2];\n"
"                real4 blockDelta = blockCenter1-blockCenter2;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(blockDelta)\n"
"#endif\n"
"                blockDelta.x = max((real) 0, fabs(blockDelta.x)-blockSize1.x-blockSize2.x);\n"
"                blockDelta.y = max((real) 0, fabs(blockDelta.y)-blockSize1.y-blockSize2.y);\n"
"                blockDelta.z = max((real) 0, fabs(blockDelta.z)-blockSize1.z-blockSize2.z);\n"
"                includeBlock2 &= (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z < CUTOFF_SQUARED);\n"
"            }\n"
"            \n"
"            // Loop over any blocks we identified as potentially containing neighbors.\n"
"            \n"
"#ifdef __CUDA_ARCH__\n"
"            int includeBlockFlags = BALLOT(includeBlock2);\n"
"            while (includeBlockFlags != 0) {\n"
"                int i = __ffs(includeBlockFlags)-1;\n"
"                includeBlockFlags &= includeBlockFlags-1;\n"
"                {\n"
"#else\n"
"            includeBlockFlags[LOCAL_ID] = includeBlock2;\n"
"            SYNC_WARPS;\n"
"            for (int i = 0; i < TILE_SIZE; i++) {\n"
"                if (includeBlockFlags[warpStart+i]) {\n"
"#endif\n"
"                    int block2 = block2Base+i;\n"
"\n"
"                    // Loop over atoms in this block.\n"
"\n"
"                    int start = block2*TILE_SIZE;\n"
"                    int included[TILE_SIZE];\n"
"                    int numIncluded = 0;\n"
"                    SYNC_WARPS;\n"
"                    positionCache[LOCAL_ID] = trimTo3(posq[start+indexInWarp]);\n"
"                    SYNC_WARPS;\n"
"                    if (atom1 < NUM_ATOMS) {\n"
"                        for (int j = 0; j < 32; j++) {\n"
"                            int atom2 = start+j;\n"
"                            real3 pos2 = positionCache[LOCAL_ID-indexInWarp+j];\n"
"\n"
"                            // Decide whether to include this atom pair in the neighbor list.\n"
"\n"
"                            real4 atomDelta = delta(pos1, pos2, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ);\n"
"#ifdef USE_CENTRAL_PARTICLE\n"
"                            bool includeAtom = (atom2 != atom1 && atom2 < NUM_ATOMS && atomDelta.w < CUTOFF_SQUARED);\n"
"#else\n"
"                            bool includeAtom = (atom2 > atom1 && atom2 < NUM_ATOMS && atomDelta.w < CUTOFF_SQUARED);\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                            if (includeAtom)\n"
"                                includeAtom &= !isInteractionExcluded(atom1, atom2, exclusions, exclusionStartIndex);\n"
"#endif\n"
"                            if (includeAtom)\n"
"                                included[numIncluded++] = atom2;\n"
"                        }\n"
"                    }\n"
"\n"
"                    // If we found any neighbors, store them to the neighbor list.\n"
"\n"
"                    if (numIncluded > 0) {\n"
"                        int baseIndex = ATOMIC_ADD(numNeighborPairs, numIncluded);\n"
"                        if (baseIndex+numIncluded <= maxNeighborPairs)\n"
"                            for (int j = 0; j < numIncluded; j++)\n"
"                                neighborPairs[baseIndex+j] = make_int2(atom1, included[j]);\n"
"                        totalNeighborsForAtom1 += numIncluded;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        if (atom1 < NUM_ATOMS)\n"
"            numNeighborsForAtom[atom1] = totalNeighborsForAtom1;\n"
"        SYNC_WARPS;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the neighbor counts to compute the start position of each atom.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"KERNEL void computeNeighborStartIndices(GLOBAL int* RESTRICT numNeighborsForAtom, GLOBAL int* RESTRICT neighborStartIndex,\n"
"            GLOBAL int* RESTRICT numNeighborPairs, int maxNeighborPairs) {\n"
"    LOCAL unsigned int posBuffer[256];\n"
"    if (*numNeighborPairs > maxNeighborPairs) {\n"
"        // There wasn't enough memory for the neighbor list, so we'll need to rebuild it.  Set the neighbor start\n"
"        // indices to indicate no neighbors for any atom.\n"
"        \n"
"        for (int i = LOCAL_ID; i <= NUM_ATOMS; i += LOCAL_SIZE)\n"
"            neighborStartIndex[i] = 0;\n"
"        return;\n"
"    }\n"
"    unsigned int globalOffset = 0;\n"
"    for (unsigned int startAtom = 0; startAtom < NUM_ATOMS; startAtom += LOCAL_SIZE) {\n"
"        // Load the neighbor counts into local memory.\n"
"\n"
"        unsigned int globalIndex = startAtom+LOCAL_ID;\n"
"        posBuffer[LOCAL_ID] = (globalIndex < NUM_ATOMS ? numNeighborsForAtom[globalIndex] : 0);\n"
"        SYNC_THREADS;\n"
"\n"
"        // Perform a parallel prefix sum.\n"
"\n"
"        for (unsigned int step = 1; step < LOCAL_SIZE; step *= 2) {\n"
"            unsigned int add = (LOCAL_ID >= step ? posBuffer[LOCAL_ID-step] : 0);\n"
"            SYNC_THREADS;\n"
"            posBuffer[LOCAL_ID] += add;\n"
"            SYNC_THREADS;\n"
"        }\n"
"\n"
"        // Write the results back to global memory.\n"
"\n"
"        if (globalIndex < NUM_ATOMS) {\n"
"            neighborStartIndex[globalIndex+1] = posBuffer[LOCAL_ID]+globalOffset;\n"
"            numNeighborsForAtom[globalIndex] = 0; // Clear this so the next kernel can use it as a counter\n"
"        }\n"
"        globalOffset += posBuffer[LOCAL_SIZE-1];\n"
"        SYNC_THREADS;\n"
"    }\n"
"    if (LOCAL_ID == 0)\n"
"        neighborStartIndex[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Assemble the final neighbor list.\n"
" */\n"
"KERNEL void copyPairsToNeighborList(GLOBAL const int2* RESTRICT neighborPairs, GLOBAL int* RESTRICT neighbors, GLOBAL int* RESTRICT numNeighborPairs,\n"
"            int maxNeighborPairs, GLOBAL int* RESTRICT numNeighborsForAtom, GLOBAL const int* RESTRICT neighborStartIndex) {\n"
"    int actualPairs = *numNeighborPairs;\n"
"    if (actualPairs > maxNeighborPairs)\n"
"        return; // There wasn't enough memory for the neighbor list, so we'll need to rebuild it.\n"
"    for (unsigned int index = GLOBAL_ID; index < actualPairs; index += GLOBAL_SIZE) {\n"
"        int2 pair = neighborPairs[index];\n"
"        int startIndex = neighborStartIndex[pair.x];\n"
"        int offset = ATOMIC_ADD(numNeighborsForAtom+pair.x, 1);\n"
"        neighbors[startIndex+offset] = pair.y;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::customNonbonded = "#ifdef USE_CUTOFF\n"
"if (!isExcluded && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"if (!isExcluded) {\n"
"#endif\n"
"    real tempForce = 0;\n"
"    real switchValue = 1, switchDeriv = 0;\n"
"#if USE_SWITCH\n"
"    if (r > SWITCH_CUTOFF) {\n"
"        real x = r-SWITCH_CUTOFF;\n"
"        switchValue = 1+x*x*x*(SWITCH_C3+x*(SWITCH_C4+x*SWITCH_C5));\n"
"        switchDeriv = x*x*(3*SWITCH_C3+x*(4*SWITCH_C4+x*5*SWITCH_C5));\n"
"    }\n"
"#endif\n"
"    COMPUTE_FORCE\n"
"#if USE_SWITCH\n"
"    tempForce = tempForce*switchValue - customEnergy*switchDeriv;\n"
"    tempEnergy += customEnergy*switchValue;\n"
"#else\n"
"    tempEnergy += customEnergy;\n"
"#endif\n"
"    dEdR += tempForce*invR;\n"
"}\n"
"";
const string CommonKernelSources::customNonbondedGroups = "typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    real padding;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Find the maximum of a value across all threads in a warp, and return that to\n"
" * every thread.\n"
" */\n"
"DEVICE int reduceMax(int val, LOCAL_ARG int* temp) {\n"
"#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 700\n"
"    // CUDA lets us do this slightly more efficiently by using shuffle operations.\n"
"    for (int mask = 16; mask > 0; mask /= 2)\n"
"        val = max(val, __shfl_xor_sync(0xffffffff, val, mask));\n"
"    return val;\n"
"#else\n"
"    int indexInWarp = LOCAL_ID%32;\n"
"    temp[LOCAL_ID] = val;\n"
"    SYNC_WARPS;\n"
"    for (int offset = 16; offset > 0; offset /= 2) {\n"
"        if (indexInWarp < offset)\n"
"            temp[LOCAL_ID] = max(temp[LOCAL_ID], temp[LOCAL_ID+offset]);\n"
"        SYNC_WARPS;\n"
"    }\n"
"    return temp[LOCAL_ID-indexInWarp];\n"
"#endif\n"
"}\n"
"\n"
"#ifndef SUPPORTS_64_BIT_ATOMICS\n"
"/**\n"
" * This function is used on devices that don't support 64 bit atomics.  Multiple threads within\n"
" * a single tile might have computed forces on the same atom.  This loops over them and makes sure\n"
" * that only one thread updates the force on any given atom.\n"
" */\n"
"void writeForces(GLOBAL real4* forceBuffers, LOCAL AtomData* localData, int atomIndex) {\n"
"    localData[LOCAL_ID].x = atomIndex;\n"
"    SYNC_WARPS;\n"
"    real4 forceSum = make_real4(0);\n"
"    int start = (LOCAL_ID/TILE_SIZE)*TILE_SIZE;\n"
"    int end = start+32;\n"
"    bool isFirst = true;\n"
"    for (int i = start; i < end; i++)\n"
"        if (localData[i].x == atomIndex) {\n"
"            forceSum += (real4) (localData[i].fx, localData[i].fy, localData[i].fz, 0);\n"
"            isFirst &= (i >= LOCAL_ID);\n"
"        }\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    unsigned int offset = atomIndex + warp*PADDED_NUM_ATOMS;\n"
"    if (isFirst)\n"
"        forceBuffers[offset] += forceSum;\n"
"    SYNC_WARPS;\n"
"}\n"
"#endif\n"
"\n"
"KERNEL void computeInteractionGroups(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers,\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT groupData,\n"
"        GLOBAL const int* RESTRICT numGroupTiles, int useNeighborList,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE; // global warpIndex\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1); // index within the warp\n"
"    const unsigned int tbx = LOCAL_ID - tgx;           // block warpIndex\n"
"    mixed energy = 0;\n"
"    INIT_DERIVATIVES\n"
"    LOCAL AtomData localData[LOCAL_MEMORY_SIZE];\n"
"    LOCAL int reductionBuffer[LOCAL_MEMORY_SIZE];\n"
"\n"
"    const unsigned int startTile = (useNeighborList ? warp*numGroupTiles[0]/totalWarps : FIRST_TILE+warp*(LAST_TILE-FIRST_TILE)/totalWarps);\n"
"    const unsigned int endTile = (useNeighborList ? (warp+1)*numGroupTiles[0]/totalWarps : FIRST_TILE+(warp+1)*(LAST_TILE-FIRST_TILE)/totalWarps);\n"
"    for (int tile = startTile; tile < endTile; tile++) {\n"
"        const int4 atomData = groupData[TILE_SIZE*tile+tgx];\n"
"        const int atom1 = atomData.x;\n"
"        const int atom2 = atomData.y;\n"
"        const int rangeStart = atomData.z&0xFFFF;\n"
"        const int rangeEnd = (atomData.z>>16)&0xFFFF;\n"
"        const int exclusions = atomData.w;\n"
"        real4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"        real3 force = make_real3(0);\n"
"        real4 posq2 = posq[atom2];\n"
"        localData[LOCAL_ID].x = posq2.x;\n"
"        localData[LOCAL_ID].y = posq2.y;\n"
"        localData[LOCAL_ID].z = posq2.z;\n"
"        localData[LOCAL_ID].q = posq2.w;\n"
"        LOAD_LOCAL_PARAMETERS\n"
"        localData[LOCAL_ID].fx = 0.0f;\n"
"        localData[LOCAL_ID].fy = 0.0f;\n"
"        localData[LOCAL_ID].fz = 0.0f;\n"
"        int tj = tgx;\n"
"        int rangeStop = rangeStart + reduceMax(rangeEnd-rangeStart, reductionBuffer);\n"
"        SYNC_WARPS;\n"
"        for (int j = rangeStart; j < rangeStop; j++) {\n"
"            if (j < rangeEnd) {\n"
"                bool isExcluded = (((exclusions>>tj)&1) == 0);\n"
"                int localIndex = tbx+tj;\n"
"                posq2 = make_real4(localData[localIndex].x, localData[localIndex].y, localData[localIndex].z, localData[localIndex].q);\n"
"                real3 delta = make_real3(posq2.x-posq1.x, posq2.y-posq1.y, posq2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (!isExcluded && r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    real dEdR = 0.0f;\n"
"                    real tempEnergy = 0.0f;\n"
"                    const real interactionScale = 1.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += tempEnergy;\n"
"                    delta *= dEdR;\n"
"                    force.x -= delta.x;\n"
"                    force.y -= delta.y;\n"
"                    force.z -= delta.z;\n"
"                    localData[localIndex].fx += delta.x;\n"
"                    localData[localIndex].fy += delta.y;\n"
"                    localData[localIndex].fz += delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"                tj = (tj == rangeEnd-1 ? rangeStart : tj+1);\n"
"            }\n"
"            SYNC_WARPS;\n"
"        }\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (exclusions != 0) {\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"        }\n"
"        ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"        SYNC_WARPS;\n"
"#else\n"
"        writeForces(forceBuffers, localData, atom2);\n"
"        localData[LOCAL_ID].fx = force.x;\n"
"        localData[LOCAL_ID].fy = force.y;\n"
"        localData[LOCAL_ID].fz = force.z;\n"
"        writeForces(forceBuffers, localData, atom1);\n"
"#endif\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"    SAVE_DERIVATIVES\n"
"}\n"
"\n"
"/**\n"
" * If the neighbor list needs to be rebuilt, reset the number of tiles to 0.  This is\n"
" * executed by a single thread.\n"
" */\n"
"KERNEL void prepareToBuildNeighborList(GLOBAL int* RESTRICT rebuildNeighborList, GLOBAL int* RESTRICT numGroupTiles) {\n"
"    if (rebuildNeighborList[0] == 1)\n"
"        numGroupTiles[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Filter the list of tiles to include only ones that have interactions within the\n"
" * padded cutoff.\n"
" */\n"
"KERNEL void buildNeighborList(GLOBAL int* RESTRICT rebuildNeighborList, GLOBAL int* RESTRICT numGroupTiles,\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const int4* RESTRICT groupData, GLOBAL int4* RESTRICT filteredGroupData,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ) {\n"
"    \n"
"    // If the neighbor list doesn't need to be rebuilt on this step, return immediately.\n"
"    \n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return;\n"
"\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE; // global warpIndex\n"
"    const unsigned int local_warp = LOCAL_ID/TILE_SIZE; // local warpIndex\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1); // index within the warp\n"
"    const unsigned int tbx = LOCAL_ID - tgx;           // block warpIndex\n"
"    LOCAL real4 localPos[LOCAL_MEMORY_SIZE];\n"
"    LOCAL volatile bool anyInteraction[WARPS_IN_BLOCK];\n"
"    LOCAL volatile int tileIndex[WARPS_IN_BLOCK];\n"
"    LOCAL int reductionBuffer[LOCAL_MEMORY_SIZE];\n"
"\n"
"    const unsigned int startTile = warp*NUM_TILES/totalWarps;\n"
"    const unsigned int endTile = (warp+1)*NUM_TILES/totalWarps;\n"
"    for (int tile = startTile; tile < endTile; tile++) {\n"
"        const int4 atomData = groupData[TILE_SIZE*tile+tgx];\n"
"        const int atom1 = atomData.x;\n"
"        const int atom2 = atomData.y;\n"
"        const int rangeStart = atomData.z&0xFFFF;\n"
"        const int rangeEnd = (atomData.z>>16)&0xFFFF;\n"
"        const int exclusions = atomData.w;\n"
"        real4 posq1 = posq[atom1];\n"
"        localPos[LOCAL_ID] = posq[atom2];\n"
"        if (tgx == 0)\n"
"            anyInteraction[local_warp] = false;\n"
"        int tj = tgx;\n"
"        int rangeStop = rangeStart + reduceMax(rangeEnd-rangeStart, reductionBuffer);\n"
"        SYNC_WARPS;\n"
"        for (int j = rangeStart; j < rangeStop && !anyInteraction[local_warp]; j++) {\n"
"            SYNC_WARPS;\n"
"            if (j < rangeEnd && tj < rangeEnd) {\n"
"                bool isExcluded = (((exclusions>>tj)&1) == 0);\n"
"                int localIndex = tbx+tj;\n"
"                real3 delta = make_real3(localPos[localIndex].x-posq1.x, localPos[localIndex].y-posq1.y, localPos[localIndex].z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                if (!isExcluded && r2 < PADDED_CUTOFF_SQUARED)\n"
"                    anyInteraction[local_warp] = true;\n"
"            }\n"
"            tj = (tj == rangeEnd-1 ? rangeStart : tj+1);\n"
"            SYNC_WARPS;\n"
"        }\n"
"        if (anyInteraction[local_warp]) {\n"
"            SYNC_WARPS;\n"
"            if (tgx == 0)\n"
"                tileIndex[local_warp] = ATOMIC_ADD(numGroupTiles, 1);\n"
"            SYNC_WARPS;\n"
"            filteredGroupData[TILE_SIZE*tileIndex[local_warp]+tgx] = atomData;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::ewald = "DEVICE real2 multofReal2(real2 a, real2 b) {\n"
"    return make_real2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
"}\n"
"\n"
"/**\n"
" * Precompute the cosine and sine sums which appear in each force term.\n"
" */\n"
"\n"
"KERNEL void calculateEwaldCosSinSums(GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL real2* RESTRICT cosSinSum, real4 periodicBoxSize) {\n"
"    const unsigned int ksizex = 2*KMAX_X-1;\n"
"    const unsigned int ksizey = 2*KMAX_Y-1;\n"
"    const unsigned int ksizez = 2*KMAX_Z-1;\n"
"    const unsigned int totalK = ksizex*ksizey*ksizez;\n"
"    real3 reciprocalBoxSize = make_real3(2*M_PI/periodicBoxSize.x, 2*M_PI/periodicBoxSize.y, 2*M_PI/periodicBoxSize.z);\n"
"    real reciprocalCoefficient = ONE_4PI_EPS0*4*M_PI/(periodicBoxSize.x*periodicBoxSize.y*periodicBoxSize.z);\n"
"    unsigned int index = GLOBAL_ID;\n"
"    mixed energy = 0;\n"
"    while (index < (KMAX_Y-1)*ksizez+KMAX_Z)\n"
"        index += GLOBAL_SIZE;\n"
"    while (index < totalK) {\n"
"        // Find the wave vector (kx, ky, kz) this index corresponds to.\n"
"\n"
"        int rx = index/(ksizey*ksizez);\n"
"        int remainder = index - rx*ksizey*ksizez;\n"
"        int ry = remainder/ksizez;\n"
"        int rz = remainder - ry*ksizez - KMAX_Z + 1;\n"
"        ry += -KMAX_Y + 1;\n"
"        real kx = rx*reciprocalBoxSize.x;\n"
"        real ky = ry*reciprocalBoxSize.y;\n"
"        real kz = rz*reciprocalBoxSize.z;\n"
"\n"
"        // Compute the sum for this wave vector.\n"
"\n"
"        real2 sum = make_real2(0);\n"
"        for (int atom = 0; atom < NUM_ATOMS; atom++) {\n"
"            real4 apos = posq[atom];\n"
"            real phase = apos.x*kx;\n"
"            real2 structureFactor = make_real2(COS(phase), SIN(phase));\n"
"            phase = apos.y*ky;\n"
"            structureFactor = multofReal2(structureFactor, make_real2(COS(phase), SIN(phase)));\n"
"            phase = apos.z*kz;\n"
"            structureFactor = multofReal2(structureFactor, make_real2(COS(phase), SIN(phase)));\n"
"            sum += apos.w*structureFactor;\n"
"        }\n"
"        cosSinSum[index] = sum;\n"
"\n"
"        // Compute the contribution to the energy.\n"
"\n"
"        real k2 = kx*kx + ky*ky + kz*kz;\n"
"        real ak = EXP(k2*EXP_COEFFICIENT) / k2;\n"
"        energy += reciprocalCoefficient*ak*(sum.x*sum.x + sum.y*sum.y);\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute the reciprocal space part of the Ewald force, using the precomputed sums from the\n"
" * previous routine.\n"
" */\n"
"\n"
"KERNEL void calculateEwaldForces(GLOBAL mm_long* RESTRICT forceBuffers, GLOBAL const real4* RESTRICT posq, GLOBAL const real2* RESTRICT cosSinSum, real4 periodicBoxSize) {\n"
"    unsigned int atom = GLOBAL_ID;\n"
"    real3 reciprocalBoxSize = make_real3(2*M_PI/periodicBoxSize.x, 2*M_PI/periodicBoxSize.y, 2*M_PI/periodicBoxSize.z);\n"
"    real reciprocalCoefficient = ONE_4PI_EPS0*4*M_PI/(periodicBoxSize.x*periodicBoxSize.y*periodicBoxSize.z);\n"
"    while (atom < NUM_ATOMS) {\n"
"        real3 force = make_real3(0);\n"
"        real4 apos = posq[atom];\n"
"\n"
"        // Loop over all wave vectors.\n"
"\n"
"        int lowry = 0;\n"
"        int lowrz = 1;\n"
"        for (int rx = 0; rx < KMAX_X; rx++) {\n"
"            real kx = rx*reciprocalBoxSize.x;\n"
"            for (int ry = lowry; ry < KMAX_Y; ry++) {\n"
"                real ky = ry*reciprocalBoxSize.y;\n"
"                real phase = apos.x*kx;\n"
"                real2 tab_xy = make_real2(COS(phase), SIN(phase));\n"
"                phase = apos.y*ky;\n"
"                tab_xy = multofReal2(tab_xy, make_real2(COS(phase), SIN(phase)));\n"
"                for (int rz = lowrz; rz < KMAX_Z; rz++) {\n"
"                    real kz = rz*reciprocalBoxSize.z;\n"
"\n"
"                    // Compute the force contribution of this wave vector.\n"
"\n"
"                    int index = rx*(KMAX_Y*2-1)*(KMAX_Z*2-1) + (ry+KMAX_Y-1)*(KMAX_Z*2-1) + (rz+KMAX_Z-1);\n"
"                    real k2 = kx*kx + ky*ky + kz*kz;\n"
"                    real ak = EXP(k2*EXP_COEFFICIENT)/k2;\n"
"                    phase = apos.z*kz;\n"
"                    real2 structureFactor = multofReal2(tab_xy, make_real2(COS(phase), SIN(phase)));\n"
"                    real2 sum = cosSinSum[index];\n"
"                    real dEdR = 2*reciprocalCoefficient*ak*apos.w*(sum.x*structureFactor.y - sum.y*structureFactor.x);\n"
"                    force.x += dEdR*kx;\n"
"                    force.y += dEdR*ky;\n"
"                    force.z += dEdR*kz;\n"
"                    lowrz = 1 - KMAX_Z;\n"
"                }\n"
"                lowry = 1 - KMAX_Y;\n"
"            }\n"
"        }\n"
"\n"
"        // Record the force on the atom.\n"
"\n"
"        forceBuffers[atom] += (mm_long) (force.x*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] += (mm_long) (force.y*0x100000000);\n"
"        forceBuffers[atom+2*PADDED_NUM_ATOMS] += (mm_long) (force.z*0x100000000);\n"
"        atom += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::gayBerne = "#define TILE_SIZE 32\n"
"#define NEIGHBOR_BLOCK_SIZE 32\n"
"\n"
"/**\n"
" * Calculate the ellipsoid coordinate frames and associated matrices.\n"
" */\n"
"KERNEL void computeEllipsoidFrames(int numParticles, GLOBAL const real4* RESTRICT posq, GLOBAL int2* const RESTRICT axisParticleIndices,\n"
"        GLOBAL const float4* RESTRICT sigParams, GLOBAL const float4* RESTRICT scale, GLOBAL real* RESTRICT aMatrix,\n"
"        GLOBAL real* RESTRICT bMatrix, GLOBAL real* RESTRICT gMatrix, GLOBAL const int* sortedParticles) {\n"
"    for (int sortedIndex = GLOBAL_ID; sortedIndex < numParticles; sortedIndex += GLOBAL_SIZE) {\n"
"        // Compute the local coordinate system of the ellipsoid;\n"
"\n"
"        int originalIndex = sortedParticles[sortedIndex];\n"
"        real3 pos = trimTo3(posq[originalIndex]);\n"
"        int2 axisParticles = axisParticleIndices[originalIndex];\n"
"        real3 xdir, ydir, zdir;\n"
"        if (axisParticles.x == -1) {\n"
"            xdir = make_real3(1, 0, 0);\n"
"            ydir = make_real3(0, 1, 0);\n"
"        }\n"
"        else {\n"
"            xdir = pos-trimTo3(posq[axisParticles.x]);\n"
"            xdir = normalize(xdir);\n"
"            if (axisParticles.y == -1) {\n"
"                if (xdir.y > -0.5f && xdir.y < 0.5f)\n"
"                    ydir = make_real3(0, 1, 0);\n"
"                else\n"
"                    ydir = make_real3(1, 0, 0);\n"
"            }\n"
"            else\n"
"                ydir = pos-trimTo3(posq[axisParticles.y]);\n"
"            ydir -= xdir*dot(xdir, ydir);\n"
"            ydir = normalize(ydir);\n"
"        }\n"
"        zdir = cross(xdir, ydir);\n"
"\n"
"        // Compute matrices we will need later.\n"
"\n"
"        GLOBAL real (*a)[3] = (GLOBAL real (*)[3]) (aMatrix+sortedIndex*9);\n"
"        GLOBAL real (*b)[3] = (GLOBAL real (*)[3]) (bMatrix+sortedIndex*9);\n"
"        GLOBAL real (*g)[3] = (GLOBAL real (*)[3]) (gMatrix+sortedIndex*9);\n"
"        a[0][0] = xdir.x;\n"
"        a[0][1] = xdir.y;\n"
"        a[0][2] = xdir.z;\n"
"        a[1][0] = ydir.x;\n"
"        a[1][1] = ydir.y;\n"
"        a[1][2] = ydir.z;\n"
"        a[2][0] = zdir.x;\n"
"        a[2][1] = zdir.y;\n"
"        a[2][2] = zdir.z;\n"
"        float4 sig = sigParams[originalIndex];\n"
"        float3 r2 = make_float3(sig.y, sig.z, sig.w);\n"
"        float3 e2 = trimTo3(scale[originalIndex]);\n"
"        for (int i = 0; i < 3; i++)\n"
"            for (int j = 0; j < 3; j++) {\n"
"                b[i][j] = a[0][i]*e2.x*a[0][j] + a[1][i]*e2.y*a[1][j] + a[2][i]*e2.z*a[2][j];\n"
"                g[i][j] = a[0][i]*r2.x*a[0][j] + a[1][i]*r2.y*a[1][j] + a[2][i]*r2.z*a[2][j];\n"
"            }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"KERNEL void findBlockBounds(int numAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        GLOBAL const int* sortedAtoms, GLOBAL const real4* RESTRICT posq, GLOBAL real4* RESTRICT sortedPos, GLOBAL real4* RESTRICT blockCenter,\n"
"        GLOBAL real4* RESTRICT blockBoundingBox, GLOBAL int* RESTRICT neighborBlockCount) {\n"
"    int index = GLOBAL_ID;\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        real4 pos = posq[sortedAtoms[base]];\n"
"        sortedPos[base] = pos;\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[sortedAtoms[i]];\n"
"            sortedPos[i] = pos;\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = make_real4(min(minPos.x,pos.x), min(minPos.y,pos.y), min(minPos.z,pos.z), 0);\n"
"            maxPos = make_real4(max(maxPos.x,pos.x), max(maxPos.y,pos.y), max(maxPos.z,pos.z), 0);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        index += GLOBAL_SIZE;\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (GLOBAL_ID == 0)\n"
"        *neighborBlockCount = 0;\n"
"}\n"
"\n"
"/**\n"
" * This is called by findNeighbors() to write a block to the neighbor list.\n"
" */\n"
"DEVICE void storeNeighbors(int atom1, int* neighborBuffer, int numAtomsInBuffer, int maxNeighborBlocks, GLOBAL int* RESTRICT neighbors,\n"
"        GLOBAL int* RESTRICT neighborIndex, GLOBAL int* RESTRICT neighborBlockCount) {\n"
"    int blockIndex = ATOMIC_ADD(neighborBlockCount, 1);\n"
"    if (blockIndex >= maxNeighborBlocks)\n"
"        return; // We don't have enough room for the neighbor list.\n"
"    neighborIndex[blockIndex] = atom1;\n"
"    int baseIndex = blockIndex*NEIGHBOR_BLOCK_SIZE;\n"
"    for (int i = 0; i < numAtomsInBuffer; i++)\n"
"        neighbors[baseIndex+i] = neighborBuffer[i];\n"
"    for (int i = numAtomsInBuffer; i < NEIGHBOR_BLOCK_SIZE; i++)\n"
"        neighbors[baseIndex+i] = -1;\n"
"}\n"
"\n"
"/**\n"
" * Build a list of neighbors for each atom.\n"
" */\n"
"KERNEL void findNeighbors(int numAtoms, int maxNeighborBlocks, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        GLOBAL real4* RESTRICT sortedPos, GLOBAL real4* RESTRICT blockCenter, GLOBAL real4* RESTRICT blockBoundingBox, GLOBAL int* RESTRICT neighbors,\n"
"        GLOBAL int* RESTRICT neighborIndex, GLOBAL int* RESTRICT neighborBlockCount, GLOBAL const int* RESTRICT exclusions, GLOBAL const int* RESTRICT exclusionStartIndex) {\n"
"    const int numBlocks = (numAtoms+TILE_SIZE-1)/TILE_SIZE;\n"
"    int neighborBuffer[NEIGHBOR_BLOCK_SIZE];\n"
"    for (int atom1 = GLOBAL_ID; atom1 < numAtoms; atom1 += GLOBAL_SIZE) {\n"
"        int nextExclusion = exclusionStartIndex[atom1];\n"
"        int lastExclusion = exclusionStartIndex[atom1+1];\n"
"        real4 pos = sortedPos[atom1];\n"
"        int nextBufferIndex = 0;\n"
"        \n"
"        // Loop over atom blocks and compute the distance of this atom from each one's bounding box.\n"
"        \n"
"        for (int block = (atom1+1)/TILE_SIZE; block < numBlocks; block++) {\n"
"            real4 center = blockCenter[block];\n"
"            real4 blockSize = blockBoundingBox[block];\n"
"            real4 blockDelta = center-pos;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(blockDelta)\n"
"#endif\n"
"            blockDelta.x = max((real) 0, fabs(blockDelta.x)-blockSize.x);\n"
"            blockDelta.y = max((real) 0, fabs(blockDelta.y)-blockSize.y);\n"
"            blockDelta.z = max((real) 0, fabs(blockDelta.z)-blockSize.z);\n"
"            if (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z >= CUTOFF_SQUARED)\n"
"                continue;\n"
"            \n"
"            // Loop over atoms within this block.\n"
"            \n"
"            int first = max(block*TILE_SIZE, atom1+1);\n"
"            int last = min((block+1)*TILE_SIZE, numAtoms);\n"
"            for (int atom2 = first; atom2 < last; atom2++) {\n"
"                // Skip over excluded interactions.\n"
"\n"
"                if (nextExclusion < lastExclusion && exclusions[nextExclusion] >= atom2) {\n"
"                    nextExclusion++;\n"
"                    continue;\n"
"                }\n"
"                real4 delta = pos-sortedPos[atom2];\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"                    neighborBuffer[nextBufferIndex++] = atom2;\n"
"                    if (nextBufferIndex == NEIGHBOR_BLOCK_SIZE) {\n"
"                        storeNeighbors(atom1, neighborBuffer, nextBufferIndex, maxNeighborBlocks, neighbors, neighborIndex, neighborBlockCount);\n"
"                        nextBufferIndex = 0;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        if (nextBufferIndex > 0)\n"
"            storeNeighbors(atom1, neighborBuffer, nextBufferIndex, maxNeighborBlocks, neighbors, neighborIndex, neighborBlockCount);\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    float4 sig;\n"
"    float2 eps;\n"
"    real3 pos;\n"
"    real a[3][3], b[3][3], g[3][3];\n"
"} AtomData;\n"
"\n"
"DEVICE void loadAtomData(AtomData* data, int sortedIndex, int originalIndex, GLOBAL const real4* RESTRICT pos, GLOBAL const float4* RESTRICT sigParams,\n"
"        GLOBAL const float2* RESTRICT epsParams, GLOBAL const real* RESTRICT aMatrix, GLOBAL const real* RESTRICT bMatrix, GLOBAL const real* RESTRICT gMatrix) {\n"
"    data->sig = sigParams[originalIndex];\n"
"    data->eps = epsParams[originalIndex];\n"
"    data->pos = trimTo3(pos[sortedIndex]);\n"
"    for (int i = 0; i < 3; i++)\n"
"        for (int j = 0; j < 3; j++) {\n"
"            int k = 9*sortedIndex+3*i+j;\n"
"            data->a[i][j] = aMatrix[k];\n"
"            data->b[i][j] = bMatrix[k];\n"
"            data->g[i][j] = gMatrix[k];\n"
"        }\n"
"}\n"
"\n"
"inline DEVICE real3 matrixVectorProduct(real (*m)[3], real3 v) {\n"
"    return make_real3(m[0][0]*v.x + m[0][1]*v.y + m[0][2]*v.z,\n"
"                      m[1][0]*v.x + m[1][1]*v.y + m[1][2]*v.z,\n"
"                      m[2][0]*v.x + m[2][1]*v.y + m[2][2]*v.z);\n"
"}\n"
"\n"
"inline DEVICE real3 vectorMatrixProduct(real3 v, real (*m)[3]) {\n"
"    return make_real3(m[0][0]*v.x + m[1][0]*v.y + m[2][0]*v.z,\n"
"                      m[0][1]*v.x + m[1][1]*v.y + m[2][1]*v.z,\n"
"                      m[0][2]*v.x + m[1][2]*v.y + m[2][2]*v.z);\n"
"}\n"
"\n"
"inline DEVICE void matrixSum(real (*result)[3], real (*a)[3], real (*b)[3]) {\n"
"    result[0][0] = a[0][0]+b[0][0];\n"
"    result[0][1] = a[0][1]+b[0][1];\n"
"    result[0][2] = a[0][2]+b[0][2];\n"
"    result[1][0] = a[1][0]+b[1][0];\n"
"    result[1][1] = a[1][1]+b[1][1];\n"
"    result[1][2] = a[1][2]+b[1][2];\n"
"    result[2][0] = a[2][0]+b[2][0];\n"
"    result[2][1] = a[2][1]+b[2][1];\n"
"    result[2][2] = a[2][2]+b[2][2];\n"
"}\n"
"\n"
"inline DEVICE real determinant(real (*m)[3]) {\n"
"    return (m[0][0]*m[1][1]*m[2][2] + m[0][1]*m[1][2]*m[2][0] + m[0][2]*m[1][0]*m[2][1] -\n"
"            m[0][0]*m[1][2]*m[2][1] - m[0][1]*m[1][0]*m[2][2] - m[0][2]*m[1][1]*m[2][0]);\n"
"}\n"
"\n"
"inline DEVICE void matrixInverse(real (*result)[3], real (*m)[3]) {\n"
"    real invDet = RECIP(determinant(m));\n"
"    result[0][0] = invDet*(m[1][1]*m[2][2] - m[1][2]*m[2][1]);\n"
"    result[1][0] = -invDet*(m[1][0]*m[2][2] - m[1][2]*m[2][0]);\n"
"    result[2][0] = invDet*(m[1][0]*m[2][1] - m[1][1]*m[2][0]);\n"
"    result[0][1] = -invDet*(m[0][1]*m[2][2] - m[0][2]*m[2][1]);\n"
"    result[1][1] = invDet*(m[0][0]*m[2][2] - m[0][2]*m[2][0]);\n"
"    result[2][1] = -invDet*(m[0][0]*m[2][1] - m[0][1]*m[2][0]);\n"
"    result[0][2] = invDet*(m[0][1]*m[1][2] - m[0][2]*m[1][1]);\n"
"    result[1][2] = -invDet*(m[0][0]*m[1][2] - m[0][2]*m[1][0]);\n"
"    result[2][2] = invDet*(m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n"
"}\n"
"\n"
"DEVICE void computeOneInteraction(AtomData* data1, AtomData* data2, real sigma, real epsilon, real3 dr, real r2, real3* force1, real3* force2, real3* torque1, real3* torque2, mixed *totalEnergy) {\n"
"    real rInv = RSQRT(r2);\n"
"    real r = r2*rInv;\n"
"    real3 drUnit = dr*rInv;\n"
"    \n"
"    // Compute the switching function.\n"
"\n"
"    real switchValue = 1, switchDeriv = 0;\n"
"    #if USE_SWITCH\n"
"    if (r > SWITCH_CUTOFF) {\n"
"        real x = r-SWITCH_CUTOFF;\n"
"        switchValue = 1+x*x*x*(SWITCH_C3+x*(SWITCH_C4+x*SWITCH_C5));\n"
"        switchDeriv = x*x*(3*SWITCH_C3+x*(4*SWITCH_C4+x*5*SWITCH_C5));\n"
"    }\n"
"    #endif\n"
"\n"
"    // Compute vectors and matrices we'll be needing.\n"
"\n"
"    real B12[3][3], G12[3][3], B12inv[3][3], G12inv[3][3];\n"
"    matrixSum(B12, data1->b, data2->b);\n"
"    matrixSum(G12, data1->g, data2->g);\n"
"    matrixInverse(B12inv, B12);\n"
"    matrixInverse(G12inv, G12);\n"
"    real detG12 = determinant(G12);\n"
"\n"
"    // Estimate the distance between the ellipsoids and compute the first terms needed for the energy.\n"
"\n"
"    real sigma12 = 1/SQRT(0.5f*dot(drUnit, matrixVectorProduct(G12inv, drUnit)));\n"
"    real h12 = r - sigma12;\n"
"    real rho = sigma/(h12+sigma);\n"
"    real rho2 = rho*rho;\n"
"    real rho6 = rho2*rho2*rho2;\n"
"    real u = 4*epsilon*(rho6*rho6-rho6);\n"
"    real eta = SQRT(2*data1->eps.y*data2->eps.y/detG12);\n"
"    real chi = 2*dot(drUnit, matrixVectorProduct(B12inv, drUnit));\n"
"    chi *= chi;\n"
"    real energy = u*eta*chi;\n"
"    \n"
"    // Compute the terms needed for the force.\n"
"\n"
"    real3 kappa = matrixVectorProduct(G12inv, dr);\n"
"    real3 iota = matrixVectorProduct(B12inv, dr);\n"
"    real rInv2 = rInv*rInv;\n"
"    real dUSLJdr = 24*epsilon*(2*rho6-1)*rho6*rho/sigma;\n"
"    real temp = 0.5f*sigma12*sigma12*sigma12*rInv2;\n"
"    real3 dudr = (drUnit + (kappa-drUnit*dot(kappa, drUnit))*temp)*dUSLJdr;\n"
"    real3 dchidr = (iota-drUnit*dot(iota, drUnit))*(-8*rInv2*SQRT(chi));\n"
"    real3 force = (dchidr*u + dudr*chi)*(eta*switchValue) - drUnit*(energy*switchDeriv);\n"
"    *force1 += force;\n"
"    *force2 -= force;\n"
"\n"
"    // Compute the terms needed for the torque.\n"
"\n"
"    for (int j = 0; j < 2; j++) {\n"
"        real (*a)[3] = (j == 0 ? data1->a : data2->a);\n"
"        real (*b)[3] = (j == 0 ? data1->b : data2->b);\n"
"        real (*g)[3] = (j == 0 ? data1->g : data2->g);\n"
"        float4 sig = (j == 0 ? data1->sig : data2->sig);\n"
"        real3 dudq = cross(vectorMatrixProduct(kappa, g), kappa*(temp*dUSLJdr));\n"
"        real3 dchidq = cross(vectorMatrixProduct(iota, b), iota)*(-4*rInv2);\n"
"        real3 scale = make_real3(sig.y, sig.z, sig.w)*(-0.5f*eta/detG12);\n"
"        real d[3][3];\n"
"        d[0][0] = scale.x*(2*a[0][0]*(G12[1][1]*G12[2][2] - G12[1][2]*G12[2][1]) +\n"
"                             a[0][2]*(G12[1][2]*G12[0][1] + G12[1][0]*G12[2][1] - G12[1][1]*(G12[0][2] + G12[2][0])) +\n"
"                             a[0][1]*(G12[0][2]*G12[2][1] + G12[2][0]*G12[1][2] - G12[2][2]*(G12[0][1] + G12[1][0])));\n"
"        d[0][1] = scale.x*(  a[0][0]*(G12[0][2]*G12[2][1] + G12[2][0]*G12[1][2] - G12[2][2]*(G12[0][1] + G12[1][0])) +\n"
"                           2*a[0][1]*(G12[0][0]*G12[2][2] - G12[2][0]*G12[0][2]) +\n"
"                             a[0][2]*(G12[1][0]*G12[0][2] + G12[2][0]*G12[0][1] - G12[0][0]*(G12[1][2] + G12[2][1])));\n"
"        d[0][2] = scale.x*(  a[0][0]*(G12[0][1]*G12[1][2] + G12[1][0]*G12[2][1] - G12[1][1]*(G12[0][2] + G12[2][0])) +\n"
"                             a[0][1]*(G12[1][0]*G12[0][2] + G12[2][0]*G12[0][1] - G12[0][0]*(G12[1][2] + G12[2][1])) +\n"
"                           2*a[0][2]*(G12[1][1]*G12[0][0] - G12[1][0]*G12[0][1]));\n"
"        d[1][0] = scale.y*(2*a[1][0]*(G12[1][1]*G12[2][2] - G12[1][2]*G12[2][1]) +\n"
"                             a[1][1]*(G12[0][2]*G12[2][1] + G12[2][0]*G12[1][2] - G12[2][2]*(G12[0][1] + G12[1][0])) +\n"
"                             a[1][2]*(G12[1][2]*G12[0][1] + G12[1][0]*G12[2][1] - G12[1][1]*(G12[0][2] + G12[2][0])));\n"
"        d[1][1] = scale.y*(  a[1][0]*(G12[0][2]*G12[2][1] + G12[2][0]*G12[1][2] - G12[2][2]*(G12[0][1] + G12[1][0])) +\n"
"                           2*a[1][1]*(G12[2][2]*G12[0][0] - G12[2][0]*G12[0][2]) +\n"
"                             a[1][2]*(G12[1][0]*G12[0][2] + G12[0][1]*G12[2][0] - G12[0][0]*(G12[1][2] + G12[2][1])));\n"
"        d[1][2] = scale.y*(  a[1][0]*(G12[0][1]*G12[1][2] + G12[1][0]*G12[2][1] - G12[1][1]*(G12[0][2] + G12[2][0])) +\n"
"                             a[1][1]*(G12[1][0]*G12[0][2] + G12[0][1]*G12[2][0] - G12[0][0]*(G12[1][2] + G12[2][1])) +\n"
"                           2*a[1][2]*(G12[1][1]*G12[0][0] - G12[1][0]*G12[0][1]));\n"
"        d[2][0] = scale.z*(2*a[2][0]*(G12[1][1]*G12[2][2] - G12[2][1]*G12[1][2]) +\n"
"                             a[2][1]*(G12[0][2]*G12[2][1] + G12[1][2]*G12[2][0] - G12[2][2]*(G12[0][1] + G12[1][0])) +\n"
"                             a[2][2]*(G12[0][1]*G12[1][2] + G12[2][1]*G12[1][0] - G12[1][1]*(G12[0][2] + G12[2][0])));\n"
"        d[2][1] = scale.z*(  a[2][0]*(G12[0][2]*G12[2][1] + G12[1][2]*G12[2][0] - G12[2][2]*(G12[0][1] + G12[1][0])) +\n"
"                           2*a[2][1]*(G12[0][0]*G12[2][2] - G12[0][2]*G12[2][0]) +\n"
"                             a[2][2]*(G12[1][0]*G12[0][2] + G12[0][1]*G12[2][0] - G12[0][0]*(G12[1][2] + G12[2][1])));\n"
"        d[2][2] = scale.z*(  a[2][0]*(G12[0][1]*G12[1][2] + G12[2][1]*G12[1][0] - G12[1][1]*(G12[0][2] + G12[2][0])) +\n"
"                             a[2][1]*(G12[1][0]*G12[0][2] + G12[2][0]*G12[0][1] - G12[0][0]*(G12[1][2] + G12[2][1])) +\n"
"                           2*a[2][2]*(G12[1][1]*G12[0][0] - G12[1][0]*G12[0][1]));\n"
"        real3 detadq = make_real3(0);\n"
"        for (int i = 0; i < 3; i++)\n"
"            detadq += cross(make_real3(a[i][0], a[i][1], a[i][2]), make_real3(d[i][0], d[i][1], d[i][2]));\n"
"        real3 torque = (dchidq*(u*eta) + detadq*(u*chi) + dudq*(eta*chi))*switchValue;\n"
"        *(j == 0 ? torque1 : torque2) -= torque;\n"
"    }\n"
"    *totalEnergy += switchValue*energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute the interactions.\n"
" */\n"
"KERNEL void computeForce(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT torqueBuffers,\n"
"        int numAtoms, int numExceptions, GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT pos,\n"
"        GLOBAL const float4* RESTRICT sigParams, GLOBAL const float2* RESTRICT epsParams, GLOBAL const int* RESTRICT sortedAtoms,\n"
"        GLOBAL const real* RESTRICT aMatrix, GLOBAL const real* RESTRICT bMatrix, GLOBAL const real* RESTRICT gMatrix,\n"
"        GLOBAL const int* RESTRICT exclusions, GLOBAL const int* RESTRICT exclusionStartIndex,\n"
"        GLOBAL const int4* RESTRICT exceptionParticles, GLOBAL const float2* RESTRICT exceptionParams\n"
"#ifdef USE_CUTOFF\n"
"        , int maxNeighborBlocks, GLOBAL int* RESTRICT neighbors, GLOBAL int* RESTRICT neighborIndex, GLOBAL int* RESTRICT neighborBlockCount,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ\n"
"#endif\n"
"        ) {\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    mixed energy = 0;\n"
"#ifdef USE_CUTOFF\n"
"    const int numBlocks = *neighborBlockCount;\n"
"    if (numBlocks > maxNeighborBlocks)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    for (int block = GLOBAL_ID; block < numBlocks; block += GLOBAL_SIZE) {\n"
"        // Load parameters for atom1.\n"
"        \n"
"        int atom1 = neighborIndex[block];\n"
"        int index1 = sortedAtoms[atom1];\n"
"        AtomData data1;\n"
"        loadAtomData(&data1, atom1, index1, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"        real3 force1 = make_real3(0);\n"
"        real3 torque1 = make_real3(0);\n"
"        for (int indexInBlock = 0; indexInBlock < NEIGHBOR_BLOCK_SIZE; indexInBlock++) {\n"
"            // Load parameters for atom2.\n"
"            \n"
"            int atom2 = neighbors[NEIGHBOR_BLOCK_SIZE*block+indexInBlock];\n"
"            if (atom2 == -1)\n"
"                continue;\n"
"            int index2 = sortedAtoms[atom2];\n"
"            AtomData data2;\n"
"            loadAtomData(&data2, atom2, index2, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"            real3 force2 = make_real3(0);\n"
"            real3 torque2 = make_real3(0);\n"
"            \n"
"            // Compute the interaction.\n"
"            \n"
"            real3 delta = data1.pos-data2.pos;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"            real sigma = data1.sig.x+data2.sig.x;\n"
"            real epsilon = data1.eps.x*data2.eps.x;\n"
"            computeOneInteraction(&data1, &data2, sigma, epsilon, delta, r2, &force1, &force2, &torque1, &torque2, &energy);\n"
"            ATOMIC_ADD(&forceBuffers[index2], (mm_ulong) ((mm_long) (force2.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2], (mm_ulong) ((mm_long) (torque2.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.z*0x100000000)));\n"
"        }\n"
"        ATOMIC_ADD(&forceBuffers[index1], (mm_ulong) ((mm_long) (force1.x*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.y*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.z*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1], (mm_ulong) ((mm_long) (torque1.x*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.y*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.z*0x100000000)));\n"
"    }\n"
"#else\n"
"    for (int atom1 = GLOBAL_ID; atom1 < numAtoms; atom1 += GLOBAL_SIZE) {\n"
"        // Load parameters for atom1.\n"
"        \n"
"        int index1 = sortedAtoms[atom1];\n"
"        AtomData data1;\n"
"        loadAtomData(&data1, atom1, index1, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"        real3 force1 = make_real3(0);\n"
"        real3 torque1 = make_real3(0);\n"
"        int nextExclusion = exclusionStartIndex[atom1];\n"
"        int lastExclusion = exclusionStartIndex[atom1+1];\n"
"        for (int atom2 = atom1+1; atom2 < numAtoms; atom2++) {\n"
"            // Skip over excluded interactions.\n"
"            \n"
"            if (nextExclusion < lastExclusion && exclusions[nextExclusion] == atom2) {\n"
"                nextExclusion++;\n"
"                continue;\n"
"            }\n"
"            \n"
"            // Load parameters for atom2.\n"
"            \n"
"            int index2 = sortedAtoms[atom2];\n"
"            AtomData data2;\n"
"            loadAtomData(&data2, atom2, index2, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"            real3 force2 = make_real3(0);\n"
"            real3 torque2 = make_real3(0);\n"
"            \n"
"            // Compute the interaction.\n"
"            \n"
"            real3 delta = data1.pos-data2.pos;\n"
"            real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"            real sigma = data1.sig.x+data2.sig.x;\n"
"            real epsilon = data1.eps.x*data2.eps.x;\n"
"            computeOneInteraction(&data1, &data2, sigma, epsilon, delta, r2, &force1, &force2, &torque1, &torque2, &energy);\n"
"            ATOMIC_ADD(&forceBuffers[index2], (mm_ulong) ((mm_long) (force2.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2], (mm_ulong) ((mm_long) (torque2.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.z*0x100000000)));\n"
"        }\n"
"        ATOMIC_ADD(&forceBuffers[index1], (mm_ulong) ((mm_long) (force1.x*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.y*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.z*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1], (mm_ulong) ((mm_long) (torque1.x*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.y*0x100000000)));\n"
"        ATOMIC_ADD(&torqueBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.z*0x100000000)));\n"
"    }\n"
"#endif\n"
"    \n"
"    // Now compute exceptions.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < numExceptions; index += GLOBAL_SIZE) {\n"
"        int4 atomIndices = exceptionParticles[index];\n"
"        float2 params = exceptionParams[index];\n"
"        int index1 = atomIndices.x, index2 = atomIndices.y;\n"
"        int atom1 = atomIndices.z, atom2 = atomIndices.w;\n"
"        AtomData data1, data2;\n"
"        loadAtomData(&data1, atom1, index1, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"        loadAtomData(&data2, atom2, index2, pos, sigParams, epsParams, aMatrix, bMatrix, gMatrix);\n"
"        real3 force1 = make_real3(0), force2 = make_real3(0);\n"
"        real3 torque1 = make_real3(0), torque2 = make_real3(0);\n"
"        real3 delta = data1.pos-data2.pos;\n"
"        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"            computeOneInteraction(&data1, &data2, params.x, params.y, delta, r2, &force1, &force2, &torque1, &torque2, &energy);\n"
"            ATOMIC_ADD(&forceBuffers[index1], (mm_ulong) ((mm_long) (force1.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force1.z*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2], (mm_ulong) ((mm_long) (force2.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force2.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index1], (mm_ulong) ((mm_long) (torque1.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque1.z*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2], (mm_ulong) ((mm_long) (torque2.x*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.y*0x100000000)));\n"
"            ATOMIC_ADD(&torqueBuffers[index2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (torque2.z*0x100000000)));\n"
"#ifdef USE_CUTOFF\n"
"        }\n"
"#endif\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Convert the torques to forces on the connected particles.\n"
" */\n"
"KERNEL void applyTorques(\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL const mm_long* RESTRICT torqueBuffers,\n"
"        int numParticles, GLOBAL const real4* RESTRICT posq, GLOBAL int2* const RESTRICT axisParticleIndices,\n"
"        GLOBAL const int* sortedParticles) {\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    for (int sortedIndex = GLOBAL_ID; sortedIndex < numParticles; sortedIndex += GLOBAL_SIZE) {\n"
"        int originalIndex = sortedParticles[sortedIndex];\n"
"        real3 pos = trimTo3(posq[originalIndex]);\n"
"        int2 axisParticles = axisParticleIndices[originalIndex];\n"
"        if (axisParticles.x != -1) {\n"
"            // Load the torque.\n"
"\n"
"            real scale = 1/(real) 0x100000000;\n"
"            real3 torque = make_real3(scale*torqueBuffers[originalIndex], scale*torqueBuffers[originalIndex+PADDED_NUM_ATOMS], scale*torqueBuffers[originalIndex+2*PADDED_NUM_ATOMS]);\n"
"            real3 force = make_real3(0), xforce = make_real3(0), yforce = make_real3(0);\n"
"\n"
"            // Apply a force to the x particle.\n"
"            \n"
"            real3 dx = trimTo3(posq[axisParticles.x])-pos;\n"
"            real dx2 = dot(dx, dx);\n"
"            real3 f = cross(torque, dx)/dx2;\n"
"            xforce += f;\n"
"            force -= f;\n"
"            if (axisParticles.y != -1) {\n"
"                // Apply a force to the y particle.  This is based on the component of the torque\n"
"                // that was not already applied to the x particle.\n"
"                \n"
"                real3 dy = trimTo3(posq[axisParticles.y])-pos;\n"
"                real dy2 = dot(dy, dy);\n"
"                real3 torque2 = dx*dot(torque, dx)/dx2;\n"
"                f = cross(torque2, dy)/dy2;\n"
"                yforce += f;\n"
"                force -= f;\n"
"            }\n"
"            ATOMIC_ADD(&forceBuffers[originalIndex], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[originalIndex+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[originalIndex+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[axisParticles.x], (mm_ulong) ((mm_long) (xforce.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[axisParticles.x+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (xforce.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[axisParticles.x+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (xforce.z*0x100000000)));\n"
"            if (axisParticles.y != -1) {\n"
"                ATOMIC_ADD(&forceBuffers[axisParticles.y], (mm_ulong) ((mm_long) (yforce.x*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[axisParticles.y+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (yforce.y*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[axisParticles.y+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (yforce.z*0x100000000)));\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::gbsaObc = "#define WARPS_PER_GROUP (FORCE_WORK_GROUP_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    float radius, scaledRadius;\n"
"    real bornSum;\n"
"} AtomData1;\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"KERNEL void computeBornSum(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT global_bornSum,\n"
"#else\n"
"        GLOBAL real* RESTRICT global_bornSum,\n"
"#endif\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT charge, GLOBAL const float2* RESTRICT global_params,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        GLOBAL const int2* RESTRICT exclusionTiles) {\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    LOCAL AtomData1 localData[FORCE_WORK_GROUP_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real bornSum = 0;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 posq1 = posq[atom1];\n"
"        real charge1 = charge[atom1];\n"
"        float2 params1 = global_params[atom1];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].x = posq1.x;\n"
"            localData[LOCAL_ID].y = posq1.y;\n"
"            localData[LOCAL_ID].z = posq1.z;\n"
"            localData[LOCAL_ID].q = charge1;\n"
"            localData[LOCAL_ID].radius = params1.x;\n"
"            localData[LOCAL_ID].scaledRadius = params1.y;\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = make_real3(localData[tbx+j].x-posq1.x, localData[tbx+j].y-posq1.y, localData[tbx+j].z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    float2 params2 = make_float2(localData[tbx+j].radius, localData[tbx+j].scaledRadius);\n"
"                    real rScaledRadiusJ = r+params2.y;\n"
"                    if ((j != tgx) && (params1.x < rScaledRadiusJ)) {\n"
"                        real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                        real u_ij = RECIP(rScaledRadiusJ);\n"
"                        real l_ij2 = l_ij*l_ij;\n"
"                        real u_ij2 = u_ij*u_ij;\n"
"                        real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                        bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                         (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                        bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                    }\n"
"                }\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[LOCAL_ID].x = tempPosq.x;\n"
"            localData[LOCAL_ID].y = tempPosq.y;\n"
"            localData[LOCAL_ID].z = tempPosq.z;\n"
"            localData[LOCAL_ID].q = charge[j];\n"
"            float2 tempParams = global_params[j];\n"
"            localData[LOCAL_ID].radius = tempParams.x;\n"
"            localData[LOCAL_ID].scaledRadius = tempParams.y;\n"
"            localData[LOCAL_ID].bornSum = 0.0f;\n"
"            SYNC_WARPS;\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                real3 delta = make_real3(localData[tbx+tj].x-posq1.x, localData[tbx+tj].y-posq1.y, localData[tbx+tj].z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    float2 params2 = make_float2(localData[tbx+tj].radius, localData[tbx+tj].scaledRadius);\n"
"                    real rScaledRadiusJ = r+params2.y;\n"
"                    if (params1.x < rScaledRadiusJ) {\n"
"                        real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                        real u_ij = RECIP(rScaledRadiusJ);\n"
"                        real l_ij2 = l_ij*l_ij;\n"
"                        real u_ij2 = u_ij*u_ij;\n"
"                        real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                        bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                         (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                        bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                    }\n"
"                    real rScaledRadiusI = r+params1.y;\n"
"                    if (params2.x < rScaledRadiusI) {\n"
"                        real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                        real u_ij = RECIP(rScaledRadiusI);\n"
"                        real l_ij2 = l_ij*l_ij;\n"
"                        real u_ij2 = u_ij*u_ij;\n"
"                        real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                        real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                         (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                        term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                        localData[tbx+tj].bornSum += term;\n"
"                    }\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&global_bornSum[offset], (mm_ulong) ((mm_long) (bornSum*0x100000000)));\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&global_bornSum[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].bornSum*0x100000000)));\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        global_bornSum[offset1] += bornSum;\n"
"        if (x != y)\n"
"            global_bornSum[offset2] += localData[LOCAL_ID].bornSum;\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"    int end = (int) ((warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"#else\n"
"    int pos = (int) (warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[FORCE_WORK_GROUP_SIZE];\n"
"    LOCAL volatile int skipTiles[FORCE_WORK_GROUP_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        real bornSum = 0;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            real4 posq1 = posq[atom1];\n"
"            real charge1 = charge[atom1];\n"
"            float2 params1 = global_params[atom1];\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                real4 tempPosq = posq[j];\n"
"                localData[LOCAL_ID].x = tempPosq.x;\n"
"                localData[LOCAL_ID].y = tempPosq.y;\n"
"                localData[LOCAL_ID].z = tempPosq.z;\n"
"                localData[LOCAL_ID].q = charge[j];\n"
"                float2 tempParams = global_params[j];\n"
"                localData[LOCAL_ID].radius = tempParams.x;\n"
"                localData[LOCAL_ID].scaledRadius = tempParams.y;\n"
"                localData[LOCAL_ID].bornSum = 0.0f;\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[LOCAL_ID], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 delta = make_real3(localData[tbx+tj].x-posq1.x, localData[tbx+tj].y-posq1.y, localData[tbx+tj].z-posq1.z);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    int atom2 = atomIndices[tbx+tj];\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        float2 params2 = make_float2(localData[tbx+tj].radius, localData[tbx+tj].scaledRadius);\n"
"                        real rScaledRadiusJ = r+params2.y;\n"
"                        if (params1.x < rScaledRadiusJ) {\n"
"                            real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusJ);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                            bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                        }\n"
"                        real rScaledRadiusI = r+params1.y;\n"
"                        if (params2.x < rScaledRadiusI) {\n"
"                            real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusI);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                            term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                            localData[tbx+tj].bornSum += term;\n"
"                        }\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 delta = make_real3(localData[tbx+tj].x-posq1.x, localData[tbx+tj].y-posq1.y, localData[tbx+tj].z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    int atom2 = atomIndices[tbx+tj];\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        float2 params2 = make_float2(localData[tbx+tj].radius, localData[tbx+tj].scaledRadius);\n"
"                        real rScaledRadiusJ = r+params2.y;\n"
"                        if (params1.x < rScaledRadiusJ) {\n"
"                            real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusJ);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                            bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                        }\n"
"                        real rScaledRadiusI = r+params1.y;\n"
"                        if (params2.x < rScaledRadiusI) {\n"
"                            real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusI);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                            term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                            localData[tbx+tj].bornSum += term;\n"
"                        }\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            ATOMIC_ADD(&global_bornSum[atom1], (mm_ulong) ((mm_long) (bornSum*0x100000000)));\n"
"            if (atom2 < PADDED_NUM_ATOMS)\n"
"                ATOMIC_ADD(&global_bornSum[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].bornSum*0x100000000)));\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"            global_bornSum[offset1] += bornSum;\n"
"            if (atom2 < PADDED_NUM_ATOMS)\n"
"                global_bornSum[offset2] += localData[LOCAL_ID].bornSum;\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz, fw;\n"
"    real bornRadius;\n"
"} AtomData2;\n"
"\n"
"/**\n"
" * First part of computing the GBSA interaction.\n"
" */\n"
"\n"
"KERNEL void computeGBSAForce1(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL mm_ulong* RESTRICT global_bornForce,\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers, GLOBAL real* RESTRICT global_bornForce,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT charge,\n"
"        GLOBAL const real* RESTRICT global_bornRadii, int needEnergy,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize, \n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        GLOBAL const int2* RESTRICT exclusionTiles) {\n"
"    const unsigned int totalWarps = GLOBAL_SIZE/TILE_SIZE;\n"
"    const unsigned int warp = GLOBAL_ID/TILE_SIZE;\n"
"    const unsigned int tgx = LOCAL_ID & (TILE_SIZE-1);\n"
"    const unsigned int tbx = LOCAL_ID - tgx;\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData2 localData[FORCE_WORK_GROUP_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real4 force = make_real4(0);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 posq1 = posq[atom1];\n"
"        real charge1 = charge[atom1];\n"
"        real bornRadius1 = global_bornRadii[atom1];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            localData[LOCAL_ID].x = posq1.x;\n"
"            localData[LOCAL_ID].y = posq1.y;\n"
"            localData[LOCAL_ID].z = posq1.z;\n"
"            localData[LOCAL_ID].q = charge1;\n"
"            localData[LOCAL_ID].bornRadius = bornRadius1;\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"                    real3 pos2 = make_real3(localData[tbx+j].x, localData[tbx+j].y, localData[tbx+j].z);\n"
"                    real charge2 = localData[tbx+j].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        real bornRadius2 = localData[tbx+j].bornRadius;\n"
"                        real alpha2_ij = bornRadius1*bornRadius2;\n"
"                        real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        real expTerm = EXP(-D_ij);\n"
"                        real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        real denominator = SQRT(denominator2);\n"
"                        real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                        real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                        real Gpol = tempEnergy*RECIP(denominator2);\n"
"                        real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 != y*TILE_SIZE+j)\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                        if (needEnergy)\n"
"                            energy += 0.5f*tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[LOCAL_ID].x = tempPosq.x;\n"
"            localData[LOCAL_ID].y = tempPosq.y;\n"
"            localData[LOCAL_ID].z = tempPosq.z;\n"
"            localData[LOCAL_ID].q = charge[j];\n"
"            localData[LOCAL_ID].bornRadius = global_bornRadii[j];\n"
"            localData[LOCAL_ID].fx = 0.0f;\n"
"            localData[LOCAL_ID].fy = 0.0f;\n"
"            localData[LOCAL_ID].fz = 0.0f;\n"
"            localData[LOCAL_ID].fw = 0.0f;\n"
"            SYNC_WARPS;\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS) {\n"
"                    real3 pos2 = make_real3(localData[tbx+tj].x, localData[tbx+tj].y, localData[tbx+tj].z);\n"
"                    real charge2 = localData[tbx+tj].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        real bornRadius2 = localData[tbx+tj].bornRadius;\n"
"                        real alpha2_ij = bornRadius1*bornRadius2;\n"
"                        real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        real expTerm = EXP(-D_ij);\n"
"                        real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        real denominator = SQRT(denominator2);\n"
"                        real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                        real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                        real Gpol = tempEnergy*RECIP(denominator2);\n"
"                        real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                        tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                        if (needEnergy)\n"
"                            energy += tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                        localData[tbx+tj].fx += delta.x;\n"
"                        localData[tbx+tj].fy += delta.y;\n"
"                        localData[tbx+tj].fz += delta.z;\n"
"                        localData[tbx+tj].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"        ATOMIC_ADD(&global_bornForce[offset], (mm_ulong) ((mm_long) (force.w*0x100000000)));\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            ATOMIC_ADD(&forceBuffers[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"            ATOMIC_ADD(&global_bornForce[offset], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fw*0x100000000)));\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        forceBuffers[offset1] += make_real4(force.x, force.y, force.z, 0);\n"
"        global_bornForce[offset1] += force.w;\n"
"        if (x != y) {\n"
"            forceBuffers[offset2] += (real4) (localData[LOCAL_ID].fx, localData[LOCAL_ID].fy, localData[LOCAL_ID].fz, 0.0f);\n"
"            global_bornForce[offset2] += localData[LOCAL_ID].fw;\n"
"        }\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"    int end = (int) ((warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : (mm_long)numTiles)/totalWarps);\n"
"#else\n"
"    int pos = (int) (warp*(mm_long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(mm_long)numTiles/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    LOCAL int atomIndices[FORCE_WORK_GROUP_SIZE];\n"
"    LOCAL volatile int skipTiles[FORCE_WORK_GROUP_SIZE];\n"
"    skipTiles[LOCAL_ID] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        real4 force = make_real4(0);\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[LOCAL_ID] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[LOCAL_ID] = end;\n"
"            skipBase += TILE_SIZE;            \n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"            \n"
"            real4 posq1 = posq[atom1];\n"
"            real charge1 = charge[atom1];\n"
"            real bornRadius1 = global_bornRadii[atom1];\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[LOCAL_ID] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                real4 tempPosq = posq[j];\n"
"                localData[LOCAL_ID].x = tempPosq.x;\n"
"                localData[LOCAL_ID].y = tempPosq.y;\n"
"                localData[LOCAL_ID].z = tempPosq.z;\n"
"                localData[LOCAL_ID].q = charge[j];\n"
"                localData[LOCAL_ID].bornRadius = global_bornRadii[j];\n"
"                localData[LOCAL_ID].fx = 0.0f;\n"
"                localData[LOCAL_ID].fy = 0.0f;\n"
"                localData[LOCAL_ID].fz = 0.0f;\n"
"                localData[LOCAL_ID].fw = 0.0f;\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[LOCAL_ID], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = atomIndices[tbx+tj];\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 pos2 = make_real3(localData[tbx+tj].x, localData[tbx+tj].y, localData[tbx+tj].z);\n"
"                        real charge2 = localData[tbx+tj].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            real bornRadius2 = localData[tbx+tj].bornRadius;\n"
"                            real alpha2_ij = bornRadius1*bornRadius2;\n"
"                            real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                            real expTerm = EXP(-D_ij);\n"
"                            real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                            real denominator = SQRT(denominator2);\n"
"                            real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                            real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                            real Gpol = tempEnergy*RECIP(denominator2);\n"
"                            real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                            real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                            force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                            if (needEnergy)\n"
"                                energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            localData[tbx+tj].fx += delta.x;\n"
"                            localData[tbx+tj].fy += delta.y;\n"
"                            localData[tbx+tj].fz += delta.z;\n"
"                            localData[tbx+tj].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"                        }\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = atomIndices[tbx+tj];\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                        real3 pos2 = make_real3(localData[tbx+tj].x, localData[tbx+tj].y, localData[tbx+tj].z);\n"
"                        real charge2 = localData[tbx+tj].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            real bornRadius2 = localData[tbx+tj].bornRadius;\n"
"                            real alpha2_ij = bornRadius1*bornRadius2;\n"
"                            real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                            real expTerm = EXP(-D_ij);\n"
"                            real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                            real denominator = SQRT(denominator2);\n"
"                            real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                            real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                            real Gpol = tempEnergy*RECIP(denominator2);\n"
"                            real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                            real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                            force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                            if (needEnergy)\n"
"                                energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            localData[tbx+tj].fx += delta.x;\n"
"                            localData[tbx+tj].fy += delta.y;\n"
"                            localData[tbx+tj].fz += delta.z;\n"
"                            localData[tbx+tj].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"                    }\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[LOCAL_ID];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            ATOMIC_ADD(&forceBuffers[atom1], (mm_ulong) ((mm_long) (force.x*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.y*0x100000000)));\n"
"            ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (force.z*0x100000000)));\n"
"            ATOMIC_ADD(&global_bornForce[atom1], (mm_ulong) ((mm_long) (force.w*0x100000000)));\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                ATOMIC_ADD(&forceBuffers[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fx*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fy*0x100000000)));\n"
"                ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fz*0x100000000)));\n"
"                ATOMIC_ADD(&global_bornForce[atom2], (mm_ulong) ((mm_long) (localData[LOCAL_ID].fw*0x100000000)));\n"
"            }\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"            forceBuffers[offset1] += make_real4(force.x, force.y, force.z, 0);\n"
"            global_bornForce[offset1] += force.w;\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                forceBuffers[offset2] += (real4) (localData[LOCAL_ID].fx, localData[LOCAL_ID].fy, localData[LOCAL_ID].fz, 0.0f);\n"
"                global_bornForce[offset2] += localData[LOCAL_ID].fw;\n"
"            }\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"";
const string CommonKernelSources::gbsaObc2 = "{\n"
"    real invRSquaredOver4 = 0.25f*invR*invR;\n"
"    real rScaledRadiusJ = r+OBC_PARAMS2.y;\n"
"    real rScaledRadiusI = r+OBC_PARAMS1.y;\n"
"    real l_ijJ = RECIP(max((real) OBC_PARAMS1.x, fabs(r-OBC_PARAMS2.y)));\n"
"    real l_ijI = RECIP(max((real) OBC_PARAMS2.x, fabs(r-OBC_PARAMS1.y)));\n"
"    real u_ijJ = RECIP(rScaledRadiusJ);\n"
"    real u_ijI = RECIP(rScaledRadiusI);\n"
"    real l_ij2J = l_ijJ*l_ijJ;\n"
"    real l_ij2I = l_ijI*l_ijI;\n"
"    real u_ij2J = u_ijJ*u_ijJ;\n"
"    real u_ij2I = u_ijI*u_ijI;\n"
"    real t1J = LOG(u_ijJ*RECIP(l_ijJ));\n"
"    real t1I = LOG(u_ijI*RECIP(l_ijI));\n"
"    real t2J = (l_ij2J-u_ij2J);\n"
"    real t2I = (l_ij2I-u_ij2I);\n"
"    real term1 = (0.5f*(0.25f+OBC_PARAMS2.y*OBC_PARAMS2.y*invRSquaredOver4)*t2J + t1J*invRSquaredOver4)*invR;\n"
"    real term2 = (0.5f*(0.25f+OBC_PARAMS1.y*OBC_PARAMS1.y*invRSquaredOver4)*t2I + t1I*invRSquaredOver4)*invR;\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"    real tempdEdR = (OBC_PARAMS1.x < rScaledRadiusJ ? BORN_FORCE1*term1/0x100000000 : 0);\n"
"    tempdEdR += (OBC_PARAMS2.x < rScaledRadiusI ? BORN_FORCE2*term2/0x100000000 : 0);\n"
"#else\n"
"    real tempdEdR = (OBC_PARAMS1.x < rScaledRadiusJ ? BORN_FORCE1*term1 : (real) 0);\n"
"    tempdEdR += (OBC_PARAMS2.x < rScaledRadiusI ? BORN_FORCE2*term2 : (real) 0);\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int includeInteraction = (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2 && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    unsigned int includeInteraction = (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2);\n"
"#endif\n"
"    dEdR += (includeInteraction ? tempdEdR : (real) 0);\n"
"}\n"
"";
const string CommonKernelSources::gbsaObcReductions = "#define DIELECTRIC_OFFSET 0.009f\n"
"#define PROBE_RADIUS 0.14f\n"
"\n"
"/**\n"
" * Reduce the Born sums to compute the Born radii.\n"
" */\n"
"\n"
"KERNEL void reduceBornSum(float alpha, float beta, float gamma,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            GLOBAL const mm_long* RESTRICT bornSum,\n"
"#else\n"
"            GLOBAL const real* RESTRICT bornSum, int bufferSize, int numBuffers,\n"
"#endif\n"
"            GLOBAL const float2* RESTRICT params, GLOBAL real* RESTRICT bornRadii, GLOBAL real* RESTRICT obcChain) {\n"
"    for (unsigned int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        // Get summed Born data\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        real sum = RECIP((real) 0x100000000)*bornSum[index];\n"
"#else\n"
"        real sum = bornSum[index];\n"
"        int totalSize = bufferSize*numBuffers;\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += bornSum[i];\n"
"#endif\n"
"\n"
"        // Now calculate Born radius and OBC term.\n"
"\n"
"        float offsetRadius = params[index].x;\n"
"        sum *= 0.5f*offsetRadius;\n"
"        real sum2 = sum*sum;\n"
"        real sum3 = sum*sum2;\n"
"        real tanhSum = tanh(alpha*sum - beta*sum2 + gamma*sum3);\n"
"        real nonOffsetRadius = offsetRadius + DIELECTRIC_OFFSET;\n"
"        real radius = RECIP(RECIP(offsetRadius) - tanhSum/nonOffsetRadius);\n"
"        real chain = offsetRadius*(alpha - 2*beta*sum + 3*gamma*sum2);\n"
"        chain = (1-tanhSum*tanhSum)*chain / nonOffsetRadius;\n"
"        bornRadii[index] = radius;\n"
"        obcChain[index] = chain;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Reduce the Born force.\n"
" */\n"
"\n"
"KERNEL void reduceBornForce(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            GLOBAL mm_long* RESTRICT bornForce,\n"
"#else\n"
"            GLOBAL real* bornForce, int bufferSize, int numBuffers,\n"
"#endif\n"
"            GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const float2* RESTRICT params, GLOBAL const real* RESTRICT bornRadii, GLOBAL const real* RESTRICT obcChain) {\n"
"    mixed energy = 0;\n"
"    for (unsigned int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        // Get summed Born force\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        real force = RECIP((real) 0x100000000)*bornForce[index];\n"
"#else\n"
"        real force = bornForce[index];\n"
"        int totalSize = bufferSize*numBuffers;\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            force += bornForce[i];\n"
"#endif\n"
"        // Now calculate the actual force\n"
"\n"
"        float offsetRadius = params[index].x;\n"
"        real bornRadius = bornRadii[index];\n"
"        real r = offsetRadius+DIELECTRIC_OFFSET+PROBE_RADIUS;\n"
"        real ratio6 = POW((offsetRadius+DIELECTRIC_OFFSET)/bornRadius, (real) 6);\n"
"        real saTerm = SURFACE_AREA_FACTOR*r*r*ratio6;\n"
"        force += saTerm/bornRadius;\n"
"        energy += saTerm;\n"
"        force *= bornRadius*bornRadius*obcChain[index];\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        bornForce[index] = (mm_long) (force*0x100000000);\n"
"#else\n"
"        bornForce[index] = force;\n"
"#endif\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy/-6;\n"
"}";
const string CommonKernelSources::gbsaObc_cpu = "typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    float radius, scaledRadius;\n"
"    real bornSum;\n"
"} AtomData1;\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"KERNEL void computeBornSum(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_long* RESTRICT global_bornSum,\n"
"#else\n"
"        GLOBAL real* RESTRICT global_bornSum,\n"
"#endif\n"
"        GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT charge, GLOBAL const float2* RESTRICT global_params,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        GLOBAL const int2* exclusionTiles) {\n"
"    LOCAL AtomData1 localData[TILE_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+GROUP_ID*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(GROUP_ID+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = charge[j];\n"
"            float2 tempParams = global_params[j];\n"
"            localData[localAtomIndex].radius = tempParams.x;\n"
"            localData[localAtomIndex].scaledRadius = tempParams.y;\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real bornSum = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                float2 params1 = global_params[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                    real charge2 = localData[j].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(trimTo3(delta), trimTo3(delta));\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        float2 params2 = make_float2(localData[j].radius, localData[j].scaledRadius);\n"
"                        real rScaledRadiusJ = r+params2.y;\n"
"                        if ((j != tgx) && (params1.x < rScaledRadiusJ)) {\n"
"                            real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusJ);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                            bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                        }\n"
"                    }\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                ATOMIC_ADD(&global_bornSum[atom1], (mm_long) (bornSum*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += bornSum;\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                localData[tgx].bornSum = 0;\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real bornSum = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                float2 params1 = global_params[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                    real charge2 = localData[j].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        float2 params2 = make_float2(localData[j].radius, localData[j].scaledRadius);\n"
"                        real rScaledRadiusJ = r+params2.y;\n"
"                        if (params1.x < rScaledRadiusJ) {\n"
"                            real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusJ);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                            bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                        }\n"
"                        real rScaledRadiusI = r+params1.y;\n"
"                        if (params2.x < rScaledRadiusI) {\n"
"                            real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                            real u_ij = RECIP(rScaledRadiusI);\n"
"                            real l_ij2 = l_ij*l_ij;\n"
"                            real u_ij2 = u_ij*u_ij;\n"
"                            real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                            term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                            localData[j].bornSum += term;\n"
"                        }\n"
"                    }\n"
"                }\n"
"\n"
"               // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                ATOMIC_ADD(&global_bornSum[atom1], (mm_long) (bornSum*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += bornSum;\n"
"#endif\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = y*TILE_SIZE + tgx;\n"
"                ATOMIC_ADD(&global_bornSum[offset], (mm_long) (localData[tgx].bornSum*0x100000000));\n"
"#else\n"
"                unsigned int offset = y*TILE_SIZE+tgx + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += localData[tgx].bornSum;\n"
"#endif\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (GROUP_ID*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"#else\n"
"    int pos = (int) (GROUP_ID*(mm_long)numTiles/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(mm_long)numTiles/NUM_GROUPS);\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    LOCAL int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    real4 tempPosq = posq[j];\n"
"                    localData[localAtomIndex].x = tempPosq.x;\n"
"                    localData[localAtomIndex].y = tempPosq.y;\n"
"                    localData[localAtomIndex].z = tempPosq.z;\n"
"                    localData[localAtomIndex].q = charge[j];\n"
"                    float2 tempParams = global_params[j];\n"
"                    localData[localAtomIndex].radius = tempParams.x;\n"
"                    localData[localAtomIndex].scaledRadius = tempParams.y;\n"
"                    localData[localAtomIndex].bornSum = 0.0f;\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[tgx], blockCenterX)\n"
"                }\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real bornSum = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                    float2 params1 = global_params[atom1];\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                        real charge2 = localData[j].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                        int atom2 = atomIndices[j];\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            float2 params2 = make_float2(localData[j].radius, localData[j].scaledRadius);\n"
"                            real rScaledRadiusJ = r+params2.y;\n"
"                            if (params1.x < rScaledRadiusJ) {\n"
"                                real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                                real u_ij = RECIP(rScaledRadiusJ);\n"
"                                real l_ij2 = l_ij*l_ij;\n"
"                                real u_ij2 = u_ij*u_ij;\n"
"                                real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                                bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                            }\n"
"                            real rScaledRadiusI = r+params1.y;\n"
"                            if (params2.x < rScaledRadiusI) {\n"
"                                real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                                real u_ij = RECIP(rScaledRadiusI);\n"
"                                real l_ij2 = l_ij*l_ij;\n"
"                                real u_ij2 = u_ij*u_ij;\n"
"                                real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                                term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                                localData[j].bornSum += term;\n"
"                            }\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&global_bornSum[atom1], (mm_long) (bornSum*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    global_bornSum[offset] += bornSum;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real bornSum = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    float2 params1 = global_params[atom1];\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                        real charge2 = localData[j].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                        int atom2 = atomIndices[j];\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            float2 params2 = make_float2(localData[j].radius, localData[j].scaledRadius);\n"
"                            real rScaledRadiusJ = r+params2.y;\n"
"                            if (params1.x < rScaledRadiusJ) {\n"
"                                real l_ij = RECIP(max((real) params1.x, fabs(r-params2.y)));\n"
"                                real u_ij = RECIP(rScaledRadiusJ);\n"
"                                real l_ij2 = l_ij*l_ij;\n"
"                                real u_ij2 = u_ij*u_ij;\n"
"                                real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                                bornSum += (params1.x < params2.y-r ? 2.0f*(RECIP(params1.x)-l_ij) : 0);\n"
"                            }\n"
"                            real rScaledRadiusI = r+params1.y;\n"
"                            if (params2.x < rScaledRadiusI) {\n"
"                                real l_ij = RECIP(max((real) params2.x, fabs(r-params1.y)));\n"
"                                real u_ij = RECIP(rScaledRadiusI);\n"
"                                real l_ij2 = l_ij*l_ij;\n"
"                                real u_ij2 = u_ij*u_ij;\n"
"                                real ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                real term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                                term += (params2.x < params1.y-r ? 2.0f*(RECIP(params2.x)-l_ij) : 0);\n"
"                                localData[j].bornSum += term;\n"
"                            }\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&global_bornSum[atom1], (mm_long) (bornSum*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    global_bornSum[offset] += bornSum;\n"
"#endif\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&global_bornSum[atom2], (mm_long) (localData[tgx].bornSum*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom2 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    global_bornSum[offset] += localData[tgx].bornSum;\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz, fw;\n"
"    real bornRadius;\n"
"} AtomData2;\n"
"\n"
"/**\n"
" * First part of computing the GBSA interaction.\n"
" */\n"
"\n"
"KERNEL void computeGBSAForce1(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        GLOBAL mm_long* RESTRICT forceBuffers, GLOBAL mm_long* RESTRICT global_bornForce,\n"
"#else\n"
"        GLOBAL real4* RESTRICT forceBuffers, GLOBAL real* RESTRICT global_bornForce,\n"
"#endif\n"
"        GLOBAL mixed* RESTRICT energyBuffer, GLOBAL const real4* RESTRICT posq, GLOBAL const real* RESTRICT charge,\n"
"        GLOBAL const real* RESTRICT global_bornRadii, int needEnergy,\n"
"#ifdef USE_CUTOFF\n"
"        GLOBAL const int* RESTRICT tiles, GLOBAL const unsigned int* RESTRICT interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, GLOBAL const real4* RESTRICT blockCenter,\n"
"        GLOBAL const real4* RESTRICT blockSize, GLOBAL const int* RESTRICT interactingAtoms,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        GLOBAL const int2* exclusionTiles) {\n"
"    mixed energy = 0;\n"
"    LOCAL AtomData2 localData[TILE_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"    \n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+GROUP_ID*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(GROUP_ID+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/NUM_GROUPS;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = charge[j];\n"
"            localData[localAtomIndex].bornRadius = global_bornRadii[j];\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = make_real4(0);\n"
"                real4 posq1 = posq[atom1];\n"
"                real charge1 = charge[atom1];\n"
"                real bornRadius1 = global_bornRadii[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                    real charge2 = localData[j].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        real bornRadius2 = localData[j].bornRadius;\n"
"                        real alpha2_ij = bornRadius1*bornRadius2;\n"
"                        real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        real expTerm = EXP(-D_ij);\n"
"                        real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        real denominator = SQRT(denominator2);\n"
"                        real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                        real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                        real Gpol = tempEnergy*RECIP(denominator2);\n"
"                        real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 != y*TILE_SIZE+j)\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                        energy += 0.5f*tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                    }\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                ATOMIC_ADD(&forceBuffers[atom1], (mm_long) (force.x*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_long) (force.y*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_long) (force.z*0x100000000));\n"
"                ATOMIC_ADD(&global_bornForce[atom1], (mm_long) (force.w*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset] += make_real4(force.x, force.y, force.z, 0);\n"
"                global_bornForce[offset] += force.w;\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                localData[tgx].fx = 0;\n"
"                localData[tgx].fy = 0;\n"
"                localData[tgx].fz = 0;\n"
"                localData[tgx].fw = 0;\n"
"            }\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = make_real4(0);\n"
"                real4 posq1 = posq[atom1];\n"
"                real charge1 = charge[atom1];\n"
"                real bornRadius1 = global_bornRadii[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                    real charge2 = localData[j].q;\n"
"                    real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        real bornRadius2 = localData[j].bornRadius;\n"
"                        real alpha2_ij = bornRadius1*bornRadius2;\n"
"                        real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        real expTerm = EXP(-D_ij);\n"
"                        real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        real denominator = SQRT(denominator2);\n"
"                        real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                        real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                        real Gpol = tempEnergy*RECIP(denominator2);\n"
"                        real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                        tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                        energy += tempEnergy;\n"
"                        delta *= dEdR;\n"
"                        force.x -= delta.x;\n"
"                        force.y -= delta.y;\n"
"                        force.z -= delta.z;\n"
"                        localData[j].fx += delta.x;\n"
"                        localData[j].fy += delta.y;\n"
"                        localData[j].fz += delta.z;\n"
"                        localData[j].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"                    }\n"
"                }\n"
"\n"
"               // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                ATOMIC_ADD(&forceBuffers[atom1], (mm_long) (force.x*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_long) (force.y*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_long) (force.z*0x100000000));\n"
"                ATOMIC_ADD(&global_bornForce[atom1], (mm_long) (force.w*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset] += make_real4(force.x, force.y, force.z, 0);\n"
"                global_bornForce[offset] += force.w;\n"
"#endif\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = y*TILE_SIZE + tgx;\n"
"                ATOMIC_ADD(&forceBuffers[offset], (mm_long) (localData[tgx].fx*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[offset+PADDED_NUM_ATOMS], (mm_long) (localData[tgx].fy*0x100000000));\n"
"                ATOMIC_ADD(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (mm_long) (localData[tgx].fz*0x100000000));\n"
"                ATOMIC_ADD(&global_bornForce[offset], (mm_long) (localData[tgx].fw*0x100000000));\n"
"#else\n"
"                unsigned int offset = y*TILE_SIZE+tgx + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                real4 f = forceBuffers[offset];\n"
"                f.x += localData[tgx].fx;\n"
"                f.y += localData[tgx].fy;\n"
"                f.z += localData[tgx].fz;\n"
"                forceBuffers[offset] = f;\n"
"                global_bornForce[offset] += localData[tgx].fw;\n"
"#endif\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (GROUP_ID*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(numTiles > maxTiles ? NUM_BLOCKS*((mm_long)NUM_BLOCKS+1)/2 : numTiles)/NUM_GROUPS);\n"
"#else\n"
"    int pos = (int) (GROUP_ID*(mm_long)numTiles/NUM_GROUPS);\n"
"    int end = (int) ((GROUP_ID+1)*(mm_long)numTiles/NUM_GROUPS);\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    LOCAL int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"        \n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    real4 tempPosq = posq[j];\n"
"                    localData[localAtomIndex].x = tempPosq.x;\n"
"                    localData[localAtomIndex].y = tempPosq.y;\n"
"                    localData[localAtomIndex].z = tempPosq.z;\n"
"                    localData[localAtomIndex].q = charge[j];\n"
"                    localData[localAtomIndex].bornRadius = global_bornRadii[j];\n"
"                    localData[localAtomIndex].fx = 0.0f;\n"
"                    localData[localAtomIndex].fy = 0.0f;\n"
"                    localData[localAtomIndex].fz = 0.0f;\n"
"                    localData[localAtomIndex].fw = 0.0f;\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[tgx], blockCenterX)\n"
"                }\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = make_real4(0);\n"
"                    real4 posq1 = posq[atom1];\n"
"                    real charge1 = charge[atom1];\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                    float bornRadius1 = global_bornRadii[atom1];\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                        real charge2 = localData[j].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                        int atom2 = atomIndices[j];\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            real bornRadius2 = localData[j].bornRadius;\n"
"                            real alpha2_ij = bornRadius1*bornRadius2;\n"
"                            real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                            real expTerm = EXP(-D_ij);\n"
"                            real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                            real denominator = SQRT(denominator2);\n"
"                            real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                            real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                            real Gpol = tempEnergy*RECIP(denominator2);\n"
"                            real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                            real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                            force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                            energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"                            localData[j].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&forceBuffers[atom1], (mm_long) (force.x*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_long) (force.y*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_long) (force.z*0x100000000));\n"
"                    ATOMIC_ADD(&global_bornForce[atom1], (mm_long) (force.w*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset] += make_real4(force.x, force.y, force.z, 0);\n"
"                    global_bornForce[offset] += force.w;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = make_real4(0);\n"
"                    real4 posq1 = posq[atom1];\n"
"                    real charge1 = charge[atom1];\n"
"                    float bornRadius1 = global_bornRadii[atom1];\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real3 pos2 = make_real3(localData[j].x, localData[j].y, localData[j].z);\n"
"                        real charge2 = localData[j].q;\n"
"                        real3 delta = make_real3(pos2.x-posq1.x, pos2.y-posq1.y, pos2.z-posq1.z);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                        int atom2 = atomIndices[j];\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            real bornRadius2 = localData[j].bornRadius;\n"
"                            real alpha2_ij = bornRadius1*bornRadius2;\n"
"                            real D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                            real expTerm = EXP(-D_ij);\n"
"                            real denominator2 = r2 + alpha2_ij*expTerm;\n"
"                            real denominator = SQRT(denominator2);\n"
"                            real scaledChargeProduct = PREFACTOR*charge1*charge2;\n"
"                            real tempEnergy = scaledChargeProduct*RECIP(denominator);\n"
"                            real Gpol = tempEnergy*RECIP(denominator2);\n"
"                            real dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                            real dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                            force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"#ifdef USE_CUTOFF\n"
"                            tempEnergy -= scaledChargeProduct/CUTOFF;\n"
"#endif\n"
"                            energy += tempEnergy;\n"
"                            delta *= dEdR;\n"
"                            force.x -= delta.x;\n"
"                            force.y -= delta.y;\n"
"                            force.z -= delta.z;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"                            localData[j].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"                        }\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&forceBuffers[atom1], (mm_long) (force.x*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom1+PADDED_NUM_ATOMS], (mm_long) (force.y*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (mm_long) (force.z*0x100000000));\n"
"                    ATOMIC_ADD(&global_bornForce[atom1], (mm_long) (force.w*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset] += make_real4(force.x, force.y, force.z, 0);\n"
"                    global_bornForce[offset] += force.w;\n"
"#endif\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    ATOMIC_ADD(&forceBuffers[atom2], (mm_long) (localData[tgx].fx*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom2+PADDED_NUM_ATOMS], (mm_long) (localData[tgx].fy*0x100000000));\n"
"                    ATOMIC_ADD(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (mm_long) (localData[tgx].fz*0x100000000));\n"
"                    ATOMIC_ADD(&global_bornForce[atom2], (mm_long) (localData[tgx].fw*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom2 + GROUP_ID*PADDED_NUM_ATOMS;\n"
"                    real4 f = forceBuffers[offset];\n"
"                    f.x += localData[tgx].fx;\n"
"                    f.y += localData[tgx].fy;\n"
"                    f.z += localData[tgx].fz;\n"
"                    forceBuffers[offset] = f;\n"
"                    global_bornForce[offset] += localData[tgx].fw;\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"";
const string CommonKernelSources::harmonicAngleForce = "float2 angleParams = PARAMS[index];\n"
"real deltaIdeal = theta-angleParams.x;\n"
"energy += 0.5f*angleParams.y*deltaIdeal*deltaIdeal;\n"
"real dEdAngle = angleParams.y*deltaIdeal;\n"
"";
const string CommonKernelSources::harmonicBondForce = "float2 bondParams = PARAMS[index];\n"
"real deltaIdeal = r-bondParams.x;\n"
"energy += 0.5f * bondParams.y*deltaIdeal*deltaIdeal;\n"
"real dEdR = bondParams.y * deltaIdeal;\n"
"";
const string CommonKernelSources::integrationUtilities = "/**\n"
" * Generate random numbers\n"
" */\n"
"KERNEL void generateRandomNumbers(int numValues, GLOBAL float4* RESTRICT random, GLOBAL uint4* RESTRICT seed) {\n"
"    int index = GLOBAL_ID;\n"
"    uint4 state = seed[index];\n"
"    unsigned int carry = 0;\n"
"    while (index < numValues) {\n"
"        float4 value;\n"
"\n"
"        // Generate first two values.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        unsigned int k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        unsigned int m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x1 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x1 = SQRT(-2.0f * LOG(x1));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x2 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.x = x1 * COS(2.0f * 3.14159265f * x2);\n"
"        value.y = x1 * SIN(2.0f * 3.14159265f * x2);\n"
"\n"
"        // Generate next two values.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x3 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x3 = SQRT(-2.0f * LOG(x3));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x4 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.z = x3 * COS(2.0f * 3.14159265f * x4);\n"
"        value.w = x3 * SIN(2.0f * 3.14159265f * x4);\n"
"\n"
"        // Record the values.\n"
"\n"
"        random[index] = value;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"    seed[GLOBAL_ID] = state;\n"
"}\n"
"\n"
"/**\n"
" * Load the position of a particle.\n"
" */\n"
"inline DEVICE mixed4 loadPos(GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT posqCorrection, int index) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"    real4 pos1 = posq[index];\n"
"    real4 pos2 = posqCorrection[index];\n"
"    return make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"    return posq[index];\n"
"#endif\n"
"}\n"
"\n"
"/**\n"
" * Store the position of a particle.\n"
" */\n"
"inline DEVICE void storePos(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection, int index, mixed4 pos) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"    posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"    posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"    posq[index] = pos;\n"
"#endif\n"
"}\n"
"\n"
"/**\n"
" * Enforce constraints on SHAKE clusters\n"
" */\n"
"KERNEL void applyShakeToPositions(int numClusters, mixed tol, GLOBAL const real4* RESTRICT oldPos,\n"
"        GLOBAL mixed4* RESTRICT posDelta, GLOBAL const int4* RESTRICT clusterAtoms, GLOBAL const float4* RESTRICT clusterParams\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifndef USE_MIXED_PRECISION\n"
"        GLOBAL real4* posqCorrection = 0;\n"
"#endif\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numClusters) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float4 params = clusterParams[index];\n"
"        mixed4 pos = loadPos(oldPos, posqCorrection, atoms.x);\n"
"        mixed4 xpi = posDelta[atoms.x];\n"
"        mixed4 pos1 = loadPos(oldPos, posqCorrection, atoms.y);\n"
"        mixed4 xpj1 = posDelta[atoms.y];\n"
"        mixed4 pos2 = make_mixed4(0);\n"
"        mixed4 xpj2 = make_mixed4(0);\n"
"        float invMassCentral = params.x;\n"
"        float avgMass = params.y;\n"
"        float d2 = params.z;\n"
"        float invMassPeripheral = params.w;\n"
"        if (atoms.z != -1) {\n"
"            pos2 = loadPos(oldPos, posqCorrection, atoms.z);\n"
"            xpj2 = posDelta[atoms.z];\n"
"        }\n"
"        mixed4 pos3 = make_mixed4(0);\n"
"        mixed4 xpj3 = make_mixed4(0);\n"
"        if (atoms.w != -1) {\n"
"            pos3 = loadPos(oldPos, posqCorrection, atoms.w);\n"
"            xpj3 = posDelta[atoms.w];\n"
"        }\n"
"\n"
"        // Precompute quantities.\n"
"\n"
"        mixed3 rij1 = make_mixed3(pos.x-pos1.x, pos.y-pos1.y, pos.z-pos1.z);\n"
"        mixed3 rij2 = make_mixed3(pos.x-pos2.x, pos.y-pos2.y, pos.z-pos2.z);\n"
"        mixed3 rij3 = make_mixed3(pos.x-pos3.x, pos.y-pos3.y, pos.z-pos3.z);\n"
"        mixed rij1sq = rij1.x*rij1.x + rij1.y*rij1.y + rij1.z*rij1.z;\n"
"        mixed rij2sq = rij2.x*rij2.x + rij2.y*rij2.y + rij2.z*rij2.z;\n"
"        mixed rij3sq = rij3.x*rij3.x + rij3.y*rij3.y + rij3.z*rij3.z;\n"
"        mixed ld1 = d2-rij1sq;\n"
"        mixed ld2 = d2-rij2sq;\n"
"        mixed ld3 = d2-rij3sq;\n"
"\n"
"        // Iterate until convergence.\n"
"\n"
"        bool converged = false;\n"
"        int iteration = 0;\n"
"        while (iteration < 15 && !converged) {\n"
"            converged = true;\n"
"            mixed3 rpij = make_mixed3(xpi.x-xpj1.x, xpi.y-xpj1.y, xpi.z-xpj1.z);\n"
"            mixed rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"            mixed rrpr = rij1.x*rpij.x + rij1.y*rpij.y + rij1.z*rpij.z;\n"
"            mixed diff = fabs(ld1-2.0f*rrpr-rpsqij) / (d2*tol);\n"
"            if (diff >= 1.0f) {\n"
"                mixed acor  = (ld1-2.0f*rrpr-rpsqij)*avgMass / (rrpr+rij1sq);\n"
"                mixed3 dr = rij1*acor;\n"
"                xpi.x += dr.x*invMassCentral;\n"
"                xpi.y += dr.y*invMassCentral;\n"
"                xpi.z += dr.z*invMassCentral;\n"
"                xpj1.x -= dr.x*invMassPeripheral;\n"
"                xpj1.y -= dr.y*invMassPeripheral;\n"
"                xpj1.z -= dr.z*invMassPeripheral;\n"
"                converged = false;\n"
"            }\n"
"            if (atoms.z != -1) {\n"
"                rpij = make_mixed3(xpi.x-xpj2.x, xpi.y-xpj2.y, xpi.z-xpj2.z);\n"
"                rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"                rrpr = rij2.x*rpij.x + rij2.y*rpij.y + rij2.z*rpij.z;\n"
"                diff = fabs(ld2-2.0f*rrpr-rpsqij) / (d2*tol);\n"
"                if (diff >= 1.0f) {\n"
"                    mixed acor  = (ld2 - 2.0f*rrpr - rpsqij)*avgMass / (rrpr + rij2sq);\n"
"                    mixed3 dr = rij2*acor;\n"
"                    xpi.x += dr.x*invMassCentral;\n"
"                    xpi.y += dr.y*invMassCentral;\n"
"                    xpi.z += dr.z*invMassCentral;\n"
"                    xpj2.x -= dr.x*invMassPeripheral;\n"
"                    xpj2.y -= dr.y*invMassPeripheral;\n"
"                    xpj2.z -= dr.z*invMassPeripheral;\n"
"                    converged = false;\n"
"                }\n"
"            }\n"
"            if (atoms.w != -1) {\n"
"                rpij = make_mixed3(xpi.x-xpj3.x, xpi.y-xpj3.y, xpi.z-xpj3.z);\n"
"                rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"                rrpr = rij3.x*rpij.x + rij3.y*rpij.y + rij3.z*rpij.z;\n"
"                diff = fabs(ld3 - 2.0f*rrpr - rpsqij) / (d2*tol);\n"
"                if (diff >= 1.0f) {\n"
"                    mixed acor  = (ld3-2.0f*rrpr-rpsqij)*avgMass / (rrpr+rij3sq);\n"
"                    mixed3 dr = rij3*acor;\n"
"                    xpi.x += dr.x*invMassCentral;\n"
"                    xpi.y += dr.y*invMassCentral;\n"
"                    xpi.z += dr.z*invMassCentral;\n"
"                    xpj3.x -= dr.x*invMassPeripheral;\n"
"                    xpj3.y -= dr.y*invMassPeripheral;\n"
"                    xpj3.z -= dr.z*invMassPeripheral;\n"
"                    converged = false;\n"
"                }\n"
"            }\n"
"            iteration++;\n"
"        }\n"
"\n"
"        // Record the new positions.\n"
"\n"
"        posDelta[atoms.x] = xpi;\n"
"        posDelta[atoms.y] = xpj1;\n"
"        if (atoms.z != -1)\n"
"            posDelta[atoms.z] = xpj2;\n"
"        if (atoms.w != -1)\n"
"            posDelta[atoms.w] = xpj3;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Enforce velocity constraints on SHAKE clusters\n"
" */\n"
"KERNEL void applyShakeToVelocities(int numClusters, mixed tol, GLOBAL const real4* RESTRICT oldPos,\n"
"        GLOBAL mixed4* RESTRICT posDelta, GLOBAL const int4* RESTRICT clusterAtoms, GLOBAL const float4* RESTRICT clusterParams\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifndef USE_MIXED_PRECISION\n"
"        GLOBAL real4* posqCorrection = 0;\n"
"#endif\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numClusters) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float4 params = clusterParams[index];\n"
"        mixed4 pos = loadPos(oldPos, posqCorrection, atoms.x);\n"
"        mixed4 xpi = posDelta[atoms.x];\n"
"        mixed4 pos1 = loadPos(oldPos, posqCorrection, atoms.y);\n"
"        mixed4 xpj1 = posDelta[atoms.y];\n"
"        mixed4 pos2 = make_mixed4(0);\n"
"        mixed4 xpj2 = make_mixed4(0);\n"
"        float invMassCentral = params.x;\n"
"        float avgMass = params.y;\n"
"        float invMassPeripheral = params.w;\n"
"        if (atoms.z != -1) {\n"
"            pos2 = loadPos(oldPos, posqCorrection, atoms.z);\n"
"            xpj2 = posDelta[atoms.z];\n"
"        }\n"
"        mixed4 pos3 = make_mixed4(0);\n"
"        mixed4 xpj3 = make_mixed4(0);\n"
"        if (atoms.w != -1) {\n"
"            pos3 = loadPos(oldPos, posqCorrection, atoms.w);\n"
"            xpj3 = posDelta[atoms.w];\n"
"        }\n"
"\n"
"        // Precompute quantities.\n"
"\n"
"        mixed3 rij1 = make_mixed3(pos.x-pos1.x, pos.y-pos1.y, pos.z-pos1.z);\n"
"        mixed3 rij2 = make_mixed3(pos.x-pos2.x, pos.y-pos2.y, pos.z-pos2.z);\n"
"        mixed3 rij3 = make_mixed3(pos.x-pos3.x, pos.y-pos3.y, pos.z-pos3.z);\n"
"        mixed rij1sq = rij1.x*rij1.x + rij1.y*rij1.y + rij1.z*rij1.z;\n"
"        mixed rij2sq = rij2.x*rij2.x + rij2.y*rij2.y + rij2.z*rij2.z;\n"
"        mixed rij3sq = rij3.x*rij3.x + rij3.y*rij3.y + rij3.z*rij3.z;\n"
"\n"
"        // Iterate until convergence.\n"
"\n"
"        bool converged = false;\n"
"        int iteration = 0;\n"
"        while (iteration < 15 && !converged) {\n"
"            converged = true;\n"
"            mixed3 rpij = make_mixed3(xpi.x-xpj1.x, xpi.y-xpj1.y, xpi.z-xpj1.z);\n"
"            mixed rrpr = rpij.x*rij1.x + rpij.y*rij1.y + rpij.z*rij1.z;\n"
"            mixed delta = -2.0f*avgMass*rrpr/rij1sq;\n"
"            mixed3 dr = rij1*delta;\n"
"            xpi.x += dr.x*invMassCentral;\n"
"            xpi.y += dr.y*invMassCentral;\n"
"            xpi.z += dr.z*invMassCentral;\n"
"            xpj1.x -= dr.x*invMassPeripheral;\n"
"            xpj1.y -= dr.y*invMassPeripheral;\n"
"            xpj1.z -= dr.z*invMassPeripheral;\n"
"            if (fabs(delta) > tol)\n"
"                converged = false;\n"
"            if (atoms.z != -1) {\n"
"                rpij = make_mixed3(xpi.x-xpj2.x, xpi.y-xpj2.y, xpi.z-xpj2.z);\n"
"                rrpr = rpij.x*rij2.x + rpij.y*rij2.y + rpij.z*rij2.z;\n"
"                delta = -2.0f*avgMass*rrpr/rij2sq;\n"
"                dr = rij2*delta;\n"
"                xpi.x += dr.x*invMassCentral;\n"
"                xpi.y += dr.y*invMassCentral;\n"
"                xpi.z += dr.z*invMassCentral;\n"
"                xpj2.x -= dr.x*invMassPeripheral;\n"
"                xpj2.y -= dr.y*invMassPeripheral;\n"
"                xpj2.z -= dr.z*invMassPeripheral;\n"
"                if (fabs(delta) > tol)\n"
"                    converged = false;\n"
"            }\n"
"            if (atoms.w != -1) {\n"
"                rpij = make_mixed3(xpi.x-xpj3.x, xpi.y-xpj3.y, xpi.z-xpj3.z);\n"
"                rrpr = rpij.x*rij3.x + rpij.y*rij3.y + rpij.z*rij3.z;\n"
"                delta = -2.0f*avgMass*rrpr/rij3sq;\n"
"                dr = rij3*delta;\n"
"                xpi.x += dr.x*invMassCentral;\n"
"                xpi.y += dr.y*invMassCentral;\n"
"                xpi.z += dr.z*invMassCentral;\n"
"                xpj3.x -= dr.x*invMassPeripheral;\n"
"                xpj3.y -= dr.y*invMassPeripheral;\n"
"                xpj3.z -= dr.z*invMassPeripheral;\n"
"                if (fabs(delta) > tol)\n"
"                    converged = false;\n"
"            }\n"
"            iteration++;\n"
"        }\n"
"\n"
"        // Record the new positions.\n"
"\n"
"        posDelta[atoms.x] = xpi;\n"
"        posDelta[atoms.y] = xpj1;\n"
"        if (atoms.z != -1)\n"
"            posDelta[atoms.z] = xpj2;\n"
"        if (atoms.w != -1)\n"
"            posDelta[atoms.w] = xpj3;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Enforce constraints on SETTLE clusters\n"
" */\n"
"KERNEL void applySettleToPositions(int numClusters, mixed tol, GLOBAL const real4* RESTRICT oldPos,\n"
"        GLOBAL mixed4* RESTRICT posDelta, GLOBAL const mixed4* RESTRICT velm, GLOBAL const int4* RESTRICT clusterAtoms,\n"
"        GLOBAL const float2* RESTRICT clusterParams\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifndef USE_MIXED_PRECISION\n"
"        GLOBAL real4* posqCorrection = 0;\n"
"#endif\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numClusters) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float2 params = clusterParams[index];\n"
"        mixed4 apos0 = loadPos(oldPos, posqCorrection, atoms.x);\n"
"        mixed4 xp0 = posDelta[atoms.x];\n"
"        mixed4 apos1 = loadPos(oldPos, posqCorrection, atoms.y);\n"
"        mixed4 xp1 = posDelta[atoms.y];\n"
"        mixed4 apos2 = loadPos(oldPos, posqCorrection, atoms.z);\n"
"        mixed4 xp2 = posDelta[atoms.z];\n"
"        mixed m0 = 1/velm[atoms.x].w;\n"
"        mixed m1 = 1/velm[atoms.y].w;\n"
"        mixed m2 = 1/velm[atoms.z].w;\n"
"\n"
"        // Apply the SETTLE algorithm.\n"
"\n"
"        mixed xb0 = apos1.x-apos0.x;\n"
"        mixed yb0 = apos1.y-apos0.y;\n"
"        mixed zb0 = apos1.z-apos0.z;\n"
"        mixed xc0 = apos2.x-apos0.x;\n"
"        mixed yc0 = apos2.y-apos0.y;\n"
"        mixed zc0 = apos2.z-apos0.z;\n"
"\n"
"        mixed invTotalMass = 1/(m0+m1+m2);\n"
"        mixed xcom = (xp0.x*m0 + (xb0+xp1.x)*m1 + (xc0+xp2.x)*m2) * invTotalMass;\n"
"        mixed ycom = (xp0.y*m0 + (yb0+xp1.y)*m1 + (yc0+xp2.y)*m2) * invTotalMass;\n"
"        mixed zcom = (xp0.z*m0 + (zb0+xp1.z)*m1 + (zc0+xp2.z)*m2) * invTotalMass;\n"
"\n"
"        mixed xa1 = xp0.x - xcom;\n"
"        mixed ya1 = xp0.y - ycom;\n"
"        mixed za1 = xp0.z - zcom;\n"
"        mixed xb1 = xb0 + xp1.x - xcom;\n"
"        mixed yb1 = yb0 + xp1.y - ycom;\n"
"        mixed zb1 = zb0 + xp1.z - zcom;\n"
"        mixed xc1 = xc0 + xp2.x - xcom;\n"
"        mixed yc1 = yc0 + xp2.y - ycom;\n"
"        mixed zc1 = zc0 + xp2.z - zcom;\n"
"\n"
"        mixed xaksZd = yb0*zc0 - zb0*yc0;\n"
"        mixed yaksZd = zb0*xc0 - xb0*zc0;\n"
"        mixed zaksZd = xb0*yc0 - yb0*xc0;\n"
"        mixed xaksXd = ya1*zaksZd - za1*yaksZd;\n"
"        mixed yaksXd = za1*xaksZd - xa1*zaksZd;\n"
"        mixed zaksXd = xa1*yaksZd - ya1*xaksZd;\n"
"        mixed xaksYd = yaksZd*zaksXd - zaksZd*yaksXd;\n"
"        mixed yaksYd = zaksZd*xaksXd - xaksZd*zaksXd;\n"
"        mixed zaksYd = xaksZd*yaksXd - yaksZd*xaksXd;\n"
"\n"
"        mixed axlng = sqrt(xaksXd*xaksXd + yaksXd*yaksXd + zaksXd*zaksXd);\n"
"        mixed aylng = sqrt(xaksYd*xaksYd + yaksYd*yaksYd + zaksYd*zaksYd);\n"
"        mixed azlng = sqrt(xaksZd*xaksZd + yaksZd*yaksZd + zaksZd*zaksZd);\n"
"        mixed trns11 = xaksXd / axlng;\n"
"        mixed trns21 = yaksXd / axlng;\n"
"        mixed trns31 = zaksXd / axlng;\n"
"        mixed trns12 = xaksYd / aylng;\n"
"        mixed trns22 = yaksYd / aylng;\n"
"        mixed trns32 = zaksYd / aylng;\n"
"        mixed trns13 = xaksZd / azlng;\n"
"        mixed trns23 = yaksZd / azlng;\n"
"        mixed trns33 = zaksZd / azlng;\n"
"\n"
"        mixed xb0d = trns11*xb0 + trns21*yb0 + trns31*zb0;\n"
"        mixed yb0d = trns12*xb0 + trns22*yb0 + trns32*zb0;\n"
"        mixed xc0d = trns11*xc0 + trns21*yc0 + trns31*zc0;\n"
"        mixed yc0d = trns12*xc0 + trns22*yc0 + trns32*zc0;\n"
"        mixed za1d = trns13*xa1 + trns23*ya1 + trns33*za1;\n"
"        mixed xb1d = trns11*xb1 + trns21*yb1 + trns31*zb1;\n"
"        mixed yb1d = trns12*xb1 + trns22*yb1 + trns32*zb1;\n"
"        mixed zb1d = trns13*xb1 + trns23*yb1 + trns33*zb1;\n"
"        mixed xc1d = trns11*xc1 + trns21*yc1 + trns31*zc1;\n"
"        mixed yc1d = trns12*xc1 + trns22*yc1 + trns32*zc1;\n"
"        mixed zc1d = trns13*xc1 + trns23*yc1 + trns33*zc1;\n"
"\n"
"        //                                        --- Step2  A2' ---\n"
"\n"
"        float rc = 0.5f*params.y;\n"
"        mixed rb = sqrt(params.x*params.x-rc*rc);\n"
"        mixed ra = rb*(m1+m2)*invTotalMass;\n"
"        rb -= ra;\n"
"        mixed sinphi = za1d/ra;\n"
"        mixed cosphi = sqrt(1-sinphi*sinphi);\n"
"        mixed sinpsi = (zb1d-zc1d) / (2*rc*cosphi);\n"
"        mixed cospsi = sqrt(1-sinpsi*sinpsi);\n"
"\n"
"        mixed ya2d =   ra*cosphi;\n"
"        mixed xb2d = - rc*cospsi;\n"
"        mixed yb2d = - rb*cosphi - rc*sinpsi*sinphi;\n"
"        mixed yc2d = - rb*cosphi + rc*sinpsi*sinphi;\n"
"        mixed xb2d2 = xb2d*xb2d;\n"
"        mixed hh2 = 4.0f*xb2d2 + (yb2d-yc2d)*(yb2d-yc2d) + (zb1d-zc1d)*(zb1d-zc1d);\n"
"        mixed deltx = 2.0f*xb2d + sqrt(4.0f*xb2d2 - hh2 + params.y*params.y);\n"
"        xb2d -= deltx*0.5f;\n"
"\n"
"        //                                        --- Step3  al,be,ga ---\n"
"\n"
"        mixed alpha = (xb2d*(xb0d-xc0d) + yb0d*yb2d + yc0d*yc2d);\n"
"        mixed beta = (xb2d*(yc0d-yb0d) + xb0d*yb2d + xc0d*yc2d);\n"
"        mixed gamma = xb0d*yb1d - xb1d*yb0d + xc0d*yc1d - xc1d*yc0d;\n"
"\n"
"        mixed al2be2 = alpha*alpha + beta*beta;\n"
"        mixed sintheta = (alpha*gamma - beta*sqrt(al2be2 - gamma*gamma)) / al2be2;\n"
"\n"
"        //                                        --- Step4  A3' ---\n"
"\n"
"        mixed costheta = sqrt(1-sintheta*sintheta);\n"
"        mixed xa3d = - ya2d*sintheta;\n"
"        mixed ya3d =   ya2d*costheta;\n"
"        mixed za3d = za1d;\n"
"        mixed xb3d =   xb2d*costheta - yb2d*sintheta;\n"
"        mixed yb3d =   xb2d*sintheta + yb2d*costheta;\n"
"        mixed zb3d = zb1d;\n"
"        mixed xc3d = - xb2d*costheta - yc2d*sintheta;\n"
"        mixed yc3d = - xb2d*sintheta + yc2d*costheta;\n"
"        mixed zc3d = zc1d;\n"
"\n"
"        //                                        --- Step5  A3 ---\n"
"\n"
"        mixed xa3 = trns11*xa3d + trns12*ya3d + trns13*za3d;\n"
"        mixed ya3 = trns21*xa3d + trns22*ya3d + trns23*za3d;\n"
"        mixed za3 = trns31*xa3d + trns32*ya3d + trns33*za3d;\n"
"        mixed xb3 = trns11*xb3d + trns12*yb3d + trns13*zb3d;\n"
"        mixed yb3 = trns21*xb3d + trns22*yb3d + trns23*zb3d;\n"
"        mixed zb3 = trns31*xb3d + trns32*yb3d + trns33*zb3d;\n"
"        mixed xc3 = trns11*xc3d + trns12*yc3d + trns13*zc3d;\n"
"        mixed yc3 = trns21*xc3d + trns22*yc3d + trns23*zc3d;\n"
"        mixed zc3 = trns31*xc3d + trns32*yc3d + trns33*zc3d;\n"
"\n"
"        xp0.x = xcom + xa3;\n"
"        xp0.y = ycom + ya3;\n"
"        xp0.z = zcom + za3;\n"
"        xp1.x = xcom + xb3 - xb0;\n"
"        xp1.y = ycom + yb3 - yb0;\n"
"        xp1.z = zcom + zb3 - zb0;\n"
"        xp2.x = xcom + xc3 - xc0;\n"
"        xp2.y = ycom + yc3 - yc0;\n"
"        xp2.z = zcom + zc3 - zc0;\n"
"\n"
"        // Record the new positions.\n"
"\n"
"        posDelta[atoms.x] = xp0;\n"
"        posDelta[atoms.y] = xp1;\n"
"        posDelta[atoms.z] = xp2;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Enforce velocity constraints on SETTLE clusters\n"
" */\n"
"KERNEL void applySettleToVelocities(int numClusters, mixed tol, GLOBAL const real4* RESTRICT oldPos,\n"
"        GLOBAL mixed4* RESTRICT posDelta, GLOBAL mixed4* RESTRICT velm, GLOBAL const int4* RESTRICT clusterAtoms,\n"
"        GLOBAL const float2* RESTRICT clusterParams\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifndef USE_MIXED_PRECISION\n"
"        GLOBAL real4* posqCorrection = 0;\n"
"#endif\n"
"    for (int index = GLOBAL_ID; index < numClusters; index += GLOBAL_SIZE) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        mixed4 apos0 = loadPos(oldPos, posqCorrection, atoms.x);\n"
"        mixed4 apos1 = loadPos(oldPos, posqCorrection, atoms.y);\n"
"        mixed4 apos2 = loadPos(oldPos, posqCorrection, atoms.z);\n"
"        mixed4 v0 = velm[atoms.x];\n"
"        mixed4 v1 = velm[atoms.y];\n"
"        mixed4 v2 = velm[atoms.z];\n"
"        \n"
"        // Compute intermediate quantities: the atom masses, the bond directions, the relative velocities,\n"
"        // and the angle cosines and sines.\n"
"        \n"
"        mixed mA = 1/v0.w;\n"
"        mixed mB = 1/v1.w;\n"
"        mixed mC = 1/v2.w;\n"
"        mixed3 eAB = make_mixed3(apos1.x-apos0.x, apos1.y-apos0.y, apos1.z-apos0.z);\n"
"        mixed3 eBC = make_mixed3(apos2.x-apos1.x, apos2.y-apos1.y, apos2.z-apos1.z);\n"
"        mixed3 eCA = make_mixed3(apos0.x-apos2.x, apos0.y-apos2.y, apos0.z-apos2.z);\n"
"        eAB *= RSQRT(eAB.x*eAB.x + eAB.y*eAB.y + eAB.z*eAB.z);\n"
"        eBC *= RSQRT(eBC.x*eBC.x + eBC.y*eBC.y + eBC.z*eBC.z);\n"
"        eCA *= RSQRT(eCA.x*eCA.x + eCA.y*eCA.y + eCA.z*eCA.z);\n"
"        mixed vAB = (v1.x-v0.x)*eAB.x + (v1.y-v0.y)*eAB.y + (v1.z-v0.z)*eAB.z;\n"
"        mixed vBC = (v2.x-v1.x)*eBC.x + (v2.y-v1.y)*eBC.y + (v2.z-v1.z)*eBC.z;\n"
"        mixed vCA = (v0.x-v2.x)*eCA.x + (v0.y-v2.y)*eCA.y + (v0.z-v2.z)*eCA.z;\n"
"        mixed cA = -(eAB.x*eCA.x + eAB.y*eCA.y + eAB.z*eCA.z);\n"
"        mixed cB = -(eAB.x*eBC.x + eAB.y*eBC.y + eAB.z*eBC.z);\n"
"        mixed cC = -(eBC.x*eCA.x + eBC.y*eCA.y + eBC.z*eCA.z);\n"
"        mixed s2A = 1-cA*cA;\n"
"        mixed s2B = 1-cB*cB;\n"
"        mixed s2C = 1-cC*cC;\n"
"        \n"
"        // Solve the equations.  These are different from those in the SETTLE paper (JCC 13(8), pp. 952-962, 1992), because\n"
"        // in going from equations B1 to B2, they make the assumption that mB=mC (but don't bother to mention they're\n"
"        // making that assumption).  We allow all three atoms to have different masses.\n"
"        \n"
"        mixed mABCinv = 1/(mA*mB*mC);\n"
"        mixed denom = (((s2A*mB+s2B*mA)*mC+(s2A*mB*mB+2*(cA*cB*cC+1)*mA*mB+s2B*mA*mA))*mC+s2C*mA*mB*(mA+mB))*mABCinv;\n"
"        mixed tab = ((cB*cC*mA-cA*mB-cA*mC)*vCA + (cA*cC*mB-cB*mC-cB*mA)*vBC + (s2C*mA*mA*mB*mB*mABCinv+(mA+mB+mC))*vAB)/denom;\n"
"        mixed tbc = ((cA*cB*mC-cC*mB-cC*mA)*vCA + (s2A*mB*mB*mC*mC*mABCinv+(mA+mB+mC))*vBC + (cA*cC*mB-cB*mA-cB*mC)*vAB)/denom;\n"
"        mixed tca = ((s2B*mA*mA*mC*mC*mABCinv+(mA+mB+mC))*vCA + (cA*cB*mC-cC*mB-cC*mA)*vBC + (cB*cC*mA-cA*mB-cA*mC)*vAB)/denom;\n"
"        v0.x += (tab*eAB.x - tca*eCA.x)*v0.w;\n"
"        v0.y += (tab*eAB.y - tca*eCA.y)*v0.w;\n"
"        v0.z += (tab*eAB.z - tca*eCA.z)*v0.w;\n"
"        v1.x += (tbc*eBC.x - tab*eAB.x)*v1.w;\n"
"        v1.y += (tbc*eBC.y - tab*eAB.y)*v1.w;\n"
"        v1.z += (tbc*eBC.z - tab*eAB.z)*v1.w;\n"
"        v2.x += (tca*eCA.x - tbc*eBC.x)*v2.w;\n"
"        v2.y += (tca*eCA.y - tbc*eBC.y)*v2.w;\n"
"        v2.z += (tca*eCA.z - tbc*eBC.z)*v2.w;\n"
"        velm[atoms.x] = v0;\n"
"        velm[atoms.y] = v1;\n"
"        velm[atoms.z] = v2;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the direction each CCMA constraint is pointing in.  This is called once at the beginning of constraint evaluation.\n"
" */\n"
"DEVICE void computeCCMAConstraintDirections(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const real4* RESTRICT atomPositions\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifndef USE_MIXED_PRECISION\n"
"        GLOBAL real4* posqCorrection = 0;\n"
"#endif\n"
"    for (int index = GLOBAL_ID; index < NUM_CCMA_CONSTRAINTS; index += GLOBAL_SIZE) {\n"
"        // Compute the direction for this constraint.\n"
"\n"
"        int2 atoms = constraintAtoms[index];\n"
"        mixed4 dir = constraintDistance[index];\n"
"        mixed4 oldPos1 = loadPos(atomPositions, posqCorrection, atoms.x);\n"
"        mixed4 oldPos2 = loadPos(atomPositions, posqCorrection, atoms.y);\n"
"        dir.x = oldPos1.x-oldPos2.x;\n"
"        dir.y = oldPos1.y-oldPos2.y;\n"
"        dir.z = oldPos1.z-oldPos2.z;\n"
"        constraintDistance[index] = dir;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeCCMAConstraintDirectionsKernel(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const real4* RESTRICT atomPositions, GLOBAL int* RESTRICT converged\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"    computeCCMAConstraintDirections(constraintAtoms, constraintDistance, atomPositions, posqCorrection);\n"
"#else\n"
"    computeCCMAConstraintDirections(constraintAtoms, constraintDistance, atomPositions);\n"
"#endif\n"
"    if (GLOBAL_ID == 0) {\n"
"        converged[0] = 1;\n"
"        converged[1] = 0;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the force applied by each CCMA position constraint.\n"
" */\n"
"DEVICE void computeCCMAPositionConstraintForce(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL const mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const mixed4* RESTRICT atomPositions, GLOBAL const mixed* RESTRICT reducedMass, GLOBAL mixed* RESTRICT delta1,\n"
"        mixed tol, int iteration, LOCAL_ARG int* groupConverged) {\n"
"    if (LOCAL_ID == 0)\n"
"        *groupConverged = 1;\n"
"    SYNC_THREADS;\n"
"    mixed lowerTol = 1-2*tol+tol*tol;\n"
"    mixed upperTol = 1+2*tol+tol*tol;\n"
"    bool threadConverged = true;\n"
"    for (int index = GLOBAL_ID; index < NUM_CCMA_CONSTRAINTS; index += GLOBAL_SIZE) {\n"
"        // Compute the force due to this constraint.\n"
"\n"
"        int2 atoms = constraintAtoms[index];\n"
"        mixed4 dir = constraintDistance[index];\n"
"        mixed4 rp_ij = atomPositions[atoms.x]-atomPositions[atoms.y];\n"
"        rp_ij.x += dir.x;\n"
"        rp_ij.y += dir.y;\n"
"        rp_ij.z += dir.z;\n"
"        mixed rrpr = rp_ij.x*dir.x + rp_ij.y*dir.y + rp_ij.z*dir.z;\n"
"        mixed d_ij2 = dir.x*dir.x + dir.y*dir.y + dir.z*dir.z;\n"
"        mixed rp2 = rp_ij.x*rp_ij.x + rp_ij.y*rp_ij.y + rp_ij.z*rp_ij.z;\n"
"        mixed dist2 = dir.w*dir.w;\n"
"        mixed diff = dist2 - rp2;\n"
"        delta1[index] = (rrpr > d_ij2*1e-6f ? reducedMass[index]*diff/rrpr : 0.0f);\n"
"        threadConverged &= (rp2 > lowerTol*dist2 && rp2 < upperTol*dist2);\n"
"    }\n"
"    if (*groupConverged && !threadConverged)\n"
"        *groupConverged = 0;\n"
"}\n"
"\n"
"KERNEL void computeCCMAPositionConstraintForceKernel(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL const mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const mixed4* RESTRICT atomPositions, GLOBAL const mixed* RESTRICT reducedMass, GLOBAL mixed* RESTRICT delta1,\n"
"        GLOBAL int* RESTRICT converged, GLOBAL int* RESTRICT hostConvergedFlag, mixed tol, int iteration) {\n"
"    LOCAL int groupConverged;\n"
"    if (converged[1-iteration%2]) {\n"
"        if (GLOBAL_ID == 0) {\n"
"            converged[iteration%2] = 1;\n"
"            hostConvergedFlag[0] = 1;\n"
"        }\n"
"        return; // The constraint iteration has already converged.\n"
"    }\n"
"    computeCCMAPositionConstraintForce(constraintAtoms, constraintDistance, atomPositions, reducedMass,\n"
"            delta1, tol, iteration, &groupConverged);\n"
"    SYNC_THREADS;\n"
"    if (LOCAL_ID == 0 && !groupConverged)\n"
"        converged[iteration%2] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Compute the force applied by each CCMA velocity constraint.\n"
" */\n"
"DEVICE void computeCCMAVelocityConstraintForce(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL const mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const mixed4* RESTRICT atomPositions, GLOBAL const mixed* RESTRICT reducedMass, GLOBAL mixed* RESTRICT delta1,\n"
"        mixed tol, int iteration, LOCAL_ARG int* groupConverged) {\n"
"    if (LOCAL_ID == 0)\n"
"        *groupConverged = 1;\n"
"    SYNC_THREADS;\n"
"    bool threadConverged = true;\n"
"    for (int index = GLOBAL_ID; index < NUM_CCMA_CONSTRAINTS; index += GLOBAL_SIZE) {\n"
"        // Compute the force due to this constraint.\n"
"\n"
"        int2 atoms = constraintAtoms[index];\n"
"        mixed4 dir = constraintDistance[index];\n"
"        mixed4 rp_ij = atomPositions[atoms.x]-atomPositions[atoms.y];\n"
"        mixed rrpr = rp_ij.x*dir.x + rp_ij.y*dir.y + rp_ij.z*dir.z;\n"
"        mixed d_ij2 = dir.x*dir.x + dir.y*dir.y + dir.z*dir.z;\n"
"        delta1[index] = -2*reducedMass[index]*rrpr/d_ij2;\n"
"        threadConverged &= (fabs(delta1[index]) <= tol);\n"
"    }\n"
"    if (*groupConverged && !threadConverged)\n"
"        *groupConverged = 0;\n"
"}\n"
"\n"
"KERNEL void computeCCMAVelocityConstraintForceKernel(GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL const mixed4* RESTRICT constraintDistance,\n"
"        GLOBAL const mixed4* RESTRICT atomPositions, GLOBAL const mixed* RESTRICT reducedMass, GLOBAL mixed* RESTRICT delta1,\n"
"        GLOBAL int* RESTRICT converged, GLOBAL int* RESTRICT hostConvergedFlag, mixed tol, int iteration) {\n"
"    LOCAL int groupConverged;\n"
"    if (converged[1-iteration%2]) {\n"
"        if (GROUP_ID == 0 && LOCAL_ID == 0) {\n"
"            converged[iteration%2] = 1;\n"
"            hostConvergedFlag[0] = 1;\n"
"        }\n"
"        return; // The constraint iteration has already converged.\n"
"    }\n"
"    computeCCMAVelocityConstraintForce(constraintAtoms, constraintDistance, atomPositions, reducedMass,\n"
"            delta1, tol, iteration, &groupConverged);\n"
"    if (LOCAL_ID == 0 && !groupConverged)\n"
"        converged[iteration%2] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Multiply the vector of CCMA constraint forces by the constraint matrix.\n"
" */\n"
"DEVICE void multiplyByCCMAConstraintMatrix(GLOBAL const mixed* RESTRICT delta1, GLOBAL mixed* RESTRICT delta2, GLOBAL const int* RESTRICT constraintMatrixColumn,\n"
"        GLOBAL const mixed* RESTRICT constraintMatrixValue, int iteration) {\n"
"    // Multiply by the inverse constraint matrix.\n"
"\n"
"    for (int index = GLOBAL_ID; index < NUM_CCMA_CONSTRAINTS; index += GLOBAL_SIZE) {\n"
"        mixed sum = 0;\n"
"        for (int i = 0; ; i++) {\n"
"            int element = index+i*NUM_CCMA_CONSTRAINTS;\n"
"            int column = constraintMatrixColumn[element];\n"
"            if (column >= NUM_CCMA_CONSTRAINTS)\n"
"                break;\n"
"            sum += delta1[column]*constraintMatrixValue[element];\n"
"        }\n"
"        delta2[index] = sum;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void multiplyByCCMAConstraintMatrixKernel(GLOBAL const mixed* RESTRICT delta1, GLOBAL mixed* RESTRICT delta2, GLOBAL const int* RESTRICT constraintMatrixColumn,\n"
"        GLOBAL const mixed* RESTRICT constraintMatrixValue, GLOBAL const int* RESTRICT converged, int iteration) {\n"
"    if (converged[iteration%2])\n"
"        return; // The constraint iteration has already converged.\n"
"    multiplyByCCMAConstraintMatrix(delta1, delta2, constraintMatrixColumn, constraintMatrixValue, iteration);\n"
"}\n"
"\n"
"/**\n"
" * Update the atom positions based on CCMA constraint forces.\n"
" */\n"
"DEVICE void updateCCMAAtomPositions(GLOBAL const int* RESTRICT atoms, GLOBAL const int* RESTRICT numAtomConstraints, GLOBAL const int* RESTRICT atomConstraints,\n"
"        GLOBAL const mixed4* RESTRICT constraintDistance, GLOBAL mixed4* RESTRICT atomPositions, GLOBAL const mixed4* RESTRICT velm,\n"
"        GLOBAL const mixed* RESTRICT delta1, GLOBAL const mixed* RESTRICT delta2, int iteration) {\n"
"    mixed damping = (iteration < 2 ? 0.5f : 1.0f);\n"
"    for (int i = GLOBAL_ID; i < NUM_CCMA_ATOMS; i += GLOBAL_SIZE) {\n"
"        // Compute the new position of this atom.\n"
"\n"
"        int index = atoms[i];\n"
"        mixed4 atomPos = atomPositions[index];\n"
"        mixed invMass = velm[index].w;\n"
"        int num = numAtomConstraints[index];\n"
"        for (int i = 0; i < num; i++) {\n"
"            int constraint = atomConstraints[index+i*NUM_ATOMS];\n"
"            bool forward = (constraint > 0);\n"
"            constraint = (forward ? constraint-1 : -constraint-1);\n"
"            mixed constraintForce = damping*invMass*delta2[constraint];\n"
"            constraintForce = (forward ? constraintForce : -constraintForce);\n"
"            mixed4 dir = constraintDistance[constraint];\n"
"            atomPos.x += constraintForce*dir.x;\n"
"            atomPos.y += constraintForce*dir.y;\n"
"            atomPos.z += constraintForce*dir.z;\n"
"        }\n"
"        atomPositions[index] = atomPos;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void updateCCMAAtomPositionsKernel(GLOBAL const int* RESTRICT atoms, GLOBAL const int* RESTRICT numAtomConstraints, GLOBAL const int* RESTRICT atomConstraints,\n"
"        GLOBAL const mixed4* RESTRICT constraintDistance, GLOBAL mixed4* RESTRICT atomPositions, GLOBAL const mixed4* RESTRICT velm,\n"
"        GLOBAL const mixed* RESTRICT delta1, GLOBAL const mixed* RESTRICT delta2, GLOBAL int* RESTRICT converged, int iteration) {\n"
"    if (GROUP_ID == 0 && LOCAL_ID == 0)\n"
"        converged[1-iteration%2] = 1;\n"
"    if (converged[iteration%2])\n"
"        return; // The constraint iteration has already converged.\n"
"    updateCCMAAtomPositions(atoms, numAtomConstraints, atomConstraints, constraintDistance, atomPositions, velm,\n"
"            delta1, delta2, iteration);\n"
"}\n"
"\n"
"/**\n"
" * Run the entire CCMA iteration within a single kernel.  This has far less overhead than\n"
" * using multiple kernels, but requires the calculation to use only a single workgroup.\n"
" * That makes it faster for small numbers of constraints, but slower for large numbers.\n"
" */\n"
"KERNEL void runCCMA(int constrainVelocities, GLOBAL const int* RESTRICT atoms, GLOBAL const int* RESTRICT numAtomConstraints, GLOBAL const int* RESTRICT atomConstraints,\n"
"        GLOBAL const int2* RESTRICT constraintAtoms, GLOBAL mixed4* RESTRICT constraintDistance, GLOBAL const real4* RESTRICT atomPositions,\n"
"        GLOBAL mixed4* RESTRICT velm, GLOBAL mixed4* RESTRICT posDelta, GLOBAL const mixed* RESTRICT reducedMass,\n"
"        GLOBAL mixed* RESTRICT delta1, GLOBAL mixed* RESTRICT delta2, GLOBAL const int* RESTRICT constraintMatrixColumn,\n"
"        GLOBAL const mixed* RESTRICT constraintMatrixValue, mixed tol\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"    LOCAL int groupConverged;\n"
"#ifdef USE_MIXED_PRECISION\n"
"    computeCCMAConstraintDirections(constraintAtoms, constraintDistance, atomPositions, posqCorrection);\n"
"#else\n"
"    computeCCMAConstraintDirections(constraintAtoms, constraintDistance, atomPositions);\n"
"#endif\n"
"    for (int iteration = 0; iteration < 150; iteration++) {\n"
"        SYNC_THREADS\n"
"        if (constrainVelocities)\n"
"            computeCCMAVelocityConstraintForce(constraintAtoms, constraintDistance, velm, reducedMass,\n"
"                    delta1, tol, iteration, &groupConverged);\n"
"        else\n"
"            computeCCMAPositionConstraintForce(constraintAtoms, constraintDistance, posDelta, reducedMass,\n"
"                    delta1, tol, iteration, &groupConverged);\n"
"        SYNC_THREADS\n"
"        multiplyByCCMAConstraintMatrix(delta1, delta2, constraintMatrixColumn, constraintMatrixValue, iteration);\n"
"        SYNC_THREADS\n"
"        if (constrainVelocities)\n"
"            updateCCMAAtomPositions(atoms, numAtomConstraints, atomConstraints, constraintDistance, velm, velm,\n"
"                    delta1, delta2, iteration);\n"
"        else\n"
"            updateCCMAAtomPositions(atoms, numAtomConstraints, atomConstraints, constraintDistance, posDelta, velm,\n"
"                    delta1, delta2, iteration);\n"
"        SYNC_THREADS\n"
"        if (groupConverged)\n"
"            return;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the positions of virtual sites\n"
" */\n"
"KERNEL void computeVirtualSites(GLOBAL real4* RESTRICT posq, GLOBAL real4* RESTRICT posqCorrection,\n"
"        GLOBAL const int4* RESTRICT avg2Atoms, GLOBAL const real2* RESTRICT avg2Weights,\n"
"        GLOBAL const int4* RESTRICT avg3Atoms, GLOBAL const real4* RESTRICT avg3Weights,\n"
"        GLOBAL const int4* RESTRICT outOfPlaneAtoms, GLOBAL const real4* RESTRICT outOfPlaneWeights,\n"
"        GLOBAL const int* RESTRICT localCoordsIndex, GLOBAL const int* RESTRICT localCoordsAtoms,\n"
"        GLOBAL const real* RESTRICT localCoordsWeights, GLOBAL const real4* RESTRICT localCoordsPos,\n"
"        GLOBAL const int* RESTRICT localCoordsStartIndex) {\n"
"    \n"
"    // Two particle average sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_2_AVERAGE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = avg2Atoms[index];\n"
"        real2 weights = avg2Weights[index];\n"
"        mixed4 pos = loadPos(posq, posqCorrection, atoms.x);\n"
"        mixed4 pos1 = loadPos(posq, posqCorrection, atoms.y);\n"
"        mixed4 pos2 = loadPos(posq, posqCorrection, atoms.z);\n"
"        pos.x = pos1.x*weights.x + pos2.x*weights.y;\n"
"        pos.y = pos1.y*weights.x + pos2.y*weights.y;\n"
"        pos.z = pos1.z*weights.x + pos2.z*weights.y;\n"
"        storePos(posq, posqCorrection, atoms.x, pos);\n"
"    }\n"
"    \n"
"    // Three particle average sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_3_AVERAGE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = avg3Atoms[index];\n"
"        real4 weights = avg3Weights[index];\n"
"        mixed4 pos = loadPos(posq, posqCorrection, atoms.x);\n"
"        mixed4 pos1 = loadPos(posq, posqCorrection, atoms.y);\n"
"        mixed4 pos2 = loadPos(posq, posqCorrection, atoms.z);\n"
"        mixed4 pos3 = loadPos(posq, posqCorrection, atoms.w);\n"
"        pos.x = pos1.x*weights.x + pos2.x*weights.y + pos3.x*weights.z;\n"
"        pos.y = pos1.y*weights.x + pos2.y*weights.y + pos3.y*weights.z;\n"
"        pos.z = pos1.z*weights.x + pos2.z*weights.y + pos3.z*weights.z;\n"
"        storePos(posq, posqCorrection, atoms.x, pos);\n"
"    }\n"
"    \n"
"    // Out of plane sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_OUT_OF_PLANE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = outOfPlaneAtoms[index];\n"
"        real4 weights = outOfPlaneWeights[index];\n"
"        mixed4 pos = loadPos(posq, posqCorrection, atoms.x);\n"
"        mixed4 pos1 = loadPos(posq, posqCorrection, atoms.y);\n"
"        mixed4 pos2 = loadPos(posq, posqCorrection, atoms.z);\n"
"        mixed4 pos3 = loadPos(posq, posqCorrection, atoms.w);\n"
"        mixed4 v12 = pos2-pos1;\n"
"        mixed4 v13 = pos3-pos1;\n"
"        mixed4 cr = cross(v12, v13);\n"
"        pos.x = pos1.x + v12.x*weights.x + v13.x*weights.y + cr.x*weights.z;\n"
"        pos.y = pos1.y + v12.y*weights.x + v13.y*weights.y + cr.y*weights.z;\n"
"        pos.z = pos1.z + v12.z*weights.x + v13.z*weights.y + cr.z*weights.z;\n"
"        storePos(posq, posqCorrection, atoms.x, pos);\n"
"    }\n"
"    \n"
"    // Local coordinates sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_LOCAL_COORDS; index += GLOBAL_SIZE) {\n"
"        int siteAtomIndex = localCoordsIndex[index];\n"
"        int start = localCoordsStartIndex[index];\n"
"        int end = localCoordsStartIndex[index+1];\n"
"        mixed3 origin = make_mixed3(0), xdir = make_mixed3(0), ydir = make_mixed3(0);\n"
"        for (int j = start; j < end; j++) {\n"
"            mixed3 pos = trimTo3(loadPos(posq, posqCorrection, localCoordsAtoms[j]));\n"
"            origin += pos*localCoordsWeights[3*j];\n"
"            xdir += pos*localCoordsWeights[3*j+1];\n"
"            ydir += pos*localCoordsWeights[3*j+2];\n"
"        }\n"
"        mixed3 zdir = cross(xdir, ydir);\n"
"        mixed normXdir = sqrt(xdir.x*xdir.x+xdir.y*xdir.y+xdir.z*xdir.z);\n"
"        mixed normZdir = sqrt(zdir.x*zdir.x+zdir.y*zdir.y+zdir.z*zdir.z);\n"
"        mixed invNormXdir = (normXdir > 0 ? 1/normXdir : 0);\n"
"        mixed invNormZdir = (normZdir > 0 ? 1/normZdir : 0);\n"
"        xdir *= invNormXdir;\n"
"        zdir *= invNormZdir;\n"
"        ydir = cross(zdir, xdir);\n"
"        real4 localPosition_4 = localCoordsPos[index];\n"
"        mixed3 localPosition = make_mixed3(localPosition_4.x, localPosition_4.y, localPosition_4.z);\n"
"        mixed4 pos = loadPos(posq, posqCorrection, siteAtomIndex);\n"
"        pos.x = origin.x + xdir.x*localPosition.x + ydir.x*localPosition.y + zdir.x*localPosition.z;\n"
"        pos.y = origin.y + xdir.y*localPosition.x + ydir.y*localPosition.y + zdir.y*localPosition.z;\n"
"        pos.z = origin.z + xdir.z*localPosition.x + ydir.z*localPosition.y + zdir.z*localPosition.z;\n"
"        storePos(posq, posqCorrection, siteAtomIndex, pos);\n"
"    }\n"
"}\n"
"\n"
"inline DEVICE real3 loadForce(int index, GLOBAL const mm_long* RESTRICT force) {\n"
"    real scale = 1/((real) 0x100000000);\n"
"    return make_real3(scale*force[index], scale*force[index+PADDED_NUM_ATOMS], scale*force[index+PADDED_NUM_ATOMS*2]);\n"
"}\n"
"\n"
"inline DEVICE void addForce(int index, GLOBAL mm_long* RESTRICT force, real3 value) {\n"
"    GLOBAL mm_ulong* f = (GLOBAL mm_ulong*) force;\n"
"#ifdef HAS_OVERLAPPING_VSITES\n"
"    ATOMIC_ADD(&f[index], (mm_ulong) ((mm_long) (value.x*0x100000000)));\n"
"    ATOMIC_ADD(&f[index+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (value.y*0x100000000)));\n"
"    ATOMIC_ADD(&f[index+PADDED_NUM_ATOMS*2], (mm_ulong) ((mm_long) (value.z*0x100000000)));\n"
"#else\n"
"    f[index] += (mm_ulong) ((mm_long) (value.x*0x100000000));\n"
"    f[index+PADDED_NUM_ATOMS] += (mm_ulong) ((mm_long) (value.y*0x100000000));\n"
"    f[index+PADDED_NUM_ATOMS*2] += (mm_ulong) ((mm_long) (value.z*0x100000000));\n"
"#endif\n"
"}\n"
"\n"
"/**\n"
" * Distribute forces from virtual sites to the atoms they are based on.\n"
" */\n"
"KERNEL void distributeVirtualSiteForces(GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT posqCorrection, GLOBAL mm_long* RESTRICT force,\n"
"        GLOBAL const int4* RESTRICT avg2Atoms, GLOBAL const real2* RESTRICT avg2Weights,\n"
"        GLOBAL const int4* RESTRICT avg3Atoms, GLOBAL const real4* RESTRICT avg3Weights,\n"
"        GLOBAL const int4* RESTRICT outOfPlaneAtoms, GLOBAL const real4* RESTRICT outOfPlaneWeights,\n"
"        GLOBAL const int* RESTRICT localCoordsIndex, GLOBAL const int* RESTRICT localCoordsAtoms,\n"
"        GLOBAL const real* RESTRICT localCoordsWeights, GLOBAL const real4* RESTRICT localCoordsPos,\n"
"        GLOBAL const int* RESTRICT localCoordsStartIndex) {\n"
"    \n"
"    // Two particle average sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_2_AVERAGE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = avg2Atoms[index];\n"
"        real2 weights = avg2Weights[index];\n"
"        real3 f = loadForce(atoms.x, force);\n"
"        addForce(atoms.y, force, f*weights.x);\n"
"        addForce(atoms.z, force, f*weights.y);\n"
"    }\n"
"    \n"
"    // Three particle average sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_3_AVERAGE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = avg3Atoms[index];\n"
"        real4 weights = avg3Weights[index];\n"
"        real3 f = loadForce(atoms.x, force);\n"
"        addForce(atoms.y, force, f*weights.x);\n"
"        addForce(atoms.z, force, f*weights.y);\n"
"        addForce(atoms.w, force, f*weights.z);\n"
"    }\n"
"    \n"
"    // Out of plane sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_OUT_OF_PLANE; index += GLOBAL_SIZE) {\n"
"        int4 atoms = outOfPlaneAtoms[index];\n"
"        real4 weights = outOfPlaneWeights[index];\n"
"        mixed4 pos1 = loadPos(posq, posqCorrection, atoms.y);\n"
"        mixed4 pos2 = loadPos(posq, posqCorrection, atoms.z);\n"
"        mixed4 pos3 = loadPos(posq, posqCorrection, atoms.w);\n"
"        mixed4 v12 = pos2-pos1;\n"
"        mixed4 v13 = pos3-pos1;\n"
"        real3 f = loadForce(atoms.x, force);\n"
"        real3 fp2 = make_real3((real) (weights.x*f.x - weights.z*v13.z*f.y + weights.z*v13.y*f.z),\n"
"                   (real) (weights.z*v13.z*f.x + weights.x*f.y - weights.z*v13.x*f.z),\n"
"                   (real) (-weights.z*v13.y*f.x + weights.z*v13.x*f.y + weights.x*f.z));\n"
"        real3 fp3 = make_real3((real) (weights.y*f.x + weights.z*v12.z*f.y - weights.z*v12.y*f.z),\n"
"                   (real) (-weights.z*v12.z*f.x + weights.y*f.y + weights.z*v12.x*f.z),\n"
"                   (real) (weights.z*v12.y*f.x - weights.z*v12.x*f.y + weights.y*f.z));\n"
"        addForce(atoms.y, force, f-fp2-fp3);\n"
"        addForce(atoms.z, force, fp2);\n"
"        addForce(atoms.w, force, fp3);\n"
"    }\n"
"    \n"
"    // Local coordinates sites.\n"
"    \n"
"    for (int index = GLOBAL_ID; index < NUM_LOCAL_COORDS; index += GLOBAL_SIZE) {\n"
"        int siteAtomIndex = localCoordsIndex[index];\n"
"        int start = localCoordsStartIndex[index];\n"
"        int end = localCoordsStartIndex[index+1];\n"
"        mixed3 origin = make_mixed3(0), xdir = make_mixed3(0), ydir = make_mixed3(0);\n"
"        for (int j = start; j < end; j++) {\n"
"            mixed3 pos = trimTo3(loadPos(posq, posqCorrection, localCoordsAtoms[j]));\n"
"            origin += pos*localCoordsWeights[3*j];\n"
"            xdir += pos*localCoordsWeights[3*j+1];\n"
"            ydir += pos*localCoordsWeights[3*j+2];\n"
"        }\n"
"        mixed3 zdir = cross(xdir, ydir);\n"
"        mixed normXdir = sqrt(xdir.x*xdir.x+xdir.y*xdir.y+xdir.z*xdir.z);\n"
"        mixed normZdir = sqrt(zdir.x*zdir.x+zdir.y*zdir.y+zdir.z*zdir.z);\n"
"        mixed invNormXdir = (normXdir > 0 ? 1/normXdir : 0);\n"
"        mixed invNormZdir = (normZdir > 0 ? 1/normZdir : 0);\n"
"        mixed3 dx = xdir*invNormXdir;\n"
"        mixed3 dz = zdir*invNormZdir;\n"
"        mixed3 dy = cross(dz, dx);\n"
"        real4 localPosition_4 = localCoordsPos[index];\n"
"        mixed3 localPosition = make_mixed3(localPosition_4.x, localPosition_4.y, localPosition_4.z);\n"
"\n"
"        // The derivatives for this case are very complicated.  They were computed with SymPy then simplified by hand.\n"
"\n"
"        real3 f = loadForce(siteAtomIndex, force);\n"
"        mixed3 fp1 = localPosition*f.x;\n"
"        mixed3 fp2 = localPosition*f.y;\n"
"        mixed3 fp3 = localPosition*f.z;\n"
"        for (int j = start; j < end; j++) {\n"
"            real originWeight = localCoordsWeights[3*j];\n"
"            real wx = localCoordsWeights[3*j+1];\n"
"            real wy = localCoordsWeights[3*j+2];\n"
"            mixed wxScaled = wx*invNormXdir;\n"
"            mixed t1 = (wx*ydir.x-wy*xdir.x)*invNormZdir;\n"
"            mixed t2 = (wx*ydir.y-wy*xdir.y)*invNormZdir;\n"
"            mixed t3 = (wx*ydir.z-wy*xdir.z)*invNormZdir;\n"
"            mixed sx = t3*dz.y-t2*dz.z;\n"
"            mixed sy = t1*dz.z-t3*dz.x;\n"
"            mixed sz = t2*dz.x-t1*dz.y;\n"
"            real3 fresult = make_real3(0);\n"
"            fresult.x += fp1.x*wxScaled*(1-dx.x*dx.x) + fp1.z*(dz.x*sx   ) + fp1.y*((-dx.x*dy.x     )*wxScaled + dy.x*sx - dx.y*t2 - dx.z*t3) + f.x*originWeight;\n"
"            fresult.y += fp1.x*wxScaled*( -dx.x*dx.y) + fp1.z*(dz.x*sy+t3) + fp1.y*((-dx.y*dy.x-dz.z)*wxScaled + dy.x*sy + dx.y*t1);\n"
"            fresult.z += fp1.x*wxScaled*( -dx.x*dx.z) + fp1.z*(dz.x*sz-t2) + fp1.y*((-dx.z*dy.x+dz.y)*wxScaled + dy.x*sz + dx.z*t1);\n"
"            fresult.x += fp2.x*wxScaled*( -dx.y*dx.x) + fp2.z*(dz.y*sx-t3) - fp2.y*(( dx.x*dy.y-dz.z)*wxScaled - dy.y*sx - dx.x*t2);\n"
"            fresult.y += fp2.x*wxScaled*(1-dx.y*dx.y) + fp2.z*(dz.y*sy   ) - fp2.y*(( dx.y*dy.y     )*wxScaled - dy.y*sy + dx.x*t1 + dx.z*t3) + f.y*originWeight;\n"
"            fresult.z += fp2.x*wxScaled*( -dx.y*dx.z) + fp2.z*(dz.y*sz+t1) - fp2.y*(( dx.z*dy.y+dz.x)*wxScaled - dy.y*sz - dx.z*t2);\n"
"            fresult.x += fp3.x*wxScaled*( -dx.z*dx.x) + fp3.z*(dz.z*sx+t2) + fp3.y*((-dx.x*dy.z-dz.y)*wxScaled + dy.z*sx + dx.x*t3);\n"
"            fresult.y += fp3.x*wxScaled*( -dx.z*dx.y) + fp3.z*(dz.z*sy-t1) + fp3.y*((-dx.y*dy.z+dz.x)*wxScaled + dy.z*sy + dx.y*t3);\n"
"            fresult.z += fp3.x*wxScaled*(1-dx.z*dx.z) + fp3.z*(dz.z*sz   ) + fp3.y*((-dx.z*dy.z     )*wxScaled + dy.z*sz - dx.x*t1 - dx.y*t2) + f.z*originWeight;\n"
"            addForce(localCoordsAtoms[j], force, fresult);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the distributed forces from the long buffer back to the float buffer.\n"
" */\n"
"KERNEL void saveDistributedForces(GLOBAL const mm_long* RESTRICT longForces, GLOBAL real4* RESTRICT forces) {\n"
"    for (int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        real3 f = loadForce(index, longForces);\n"
"        forces[index] = make_real4(f.x, f.y, f.z, 0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Apply a time shift to the velocities before computing kinetic energy.\n"
" */\n"
"KERNEL void timeShiftVelocities(GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, real timeShift) {\n"
"    const mixed scale = timeShift/(mixed) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < NUM_ATOMS; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            velocity.x += scale*force[index]*velocity.w;\n"
"            velocity.y += scale*force[index+PADDED_NUM_ATOMS]*velocity.w;\n"
"            velocity.z += scale*force[index+PADDED_NUM_ATOMS*2]*velocity.w;\n"
"            velm[index] = velocity;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::langevin = "enum {VelScale, ForceScale, NoiseScale, MaxParams};\n"
"\n"
"/**\n"
" * Perform the first step of Langevin integration.\n"
" */\n"
"\n"
"KERNEL void integrateLangevinPart1(int numAtoms, int paddedNumAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL const mixed* RESTRICT paramBuffer, GLOBAL const mixed2* RESTRICT dt, GLOBAL const float4* RESTRICT random, unsigned int randomIndex) {\n"
"    mixed vscale = paramBuffer[VelScale];\n"
"    mixed fscale = paramBuffer[ForceScale]/(mixed) 0x100000000;\n"
"    mixed noisescale = paramBuffer[NoiseScale];\n"
"    mixed stepSize = dt[0].y;\n"
"    int index = GLOBAL_ID;\n"
"    randomIndex += index;\n"
"    while (index < numAtoms) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0) {\n"
"            mixed sqrtInvMass = SQRT(velocity.w);\n"
"            velocity.x = vscale*velocity.x + fscale*velocity.w*force[index] + noisescale*sqrtInvMass*random[randomIndex].x;\n"
"            velocity.y = vscale*velocity.y + fscale*velocity.w*force[index+paddedNumAtoms] + noisescale*sqrtInvMass*random[randomIndex].y;\n"
"            velocity.z = vscale*velocity.z + fscale*velocity.w*force[index+paddedNumAtoms*2] + noisescale*sqrtInvMass*random[randomIndex].z;\n"
"            velm[index] = velocity;\n"
"            posDelta[index] = make_mixed4(stepSize*velocity.x, stepSize*velocity.y, stepSize*velocity.z, 0);\n"
"        }\n"
"        randomIndex += GLOBAL_SIZE;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Langevin integration.\n"
" */\n"
"\n"
"KERNEL void integrateLangevinPart2(int numAtoms, GLOBAL real4* RESTRICT posq, GLOBAL const mixed4* RESTRICT posDelta, GLOBAL mixed4* RESTRICT velm, GLOBAL const mixed2* RESTRICT dt\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    double invStepSize = 1.0/dt[0].y;\n"
"#else\n"
"    float invStepSize = 1.0f/dt[0].y;\n"
"    float correction = (1.0f-invStepSize*dt[0].y)/dt[0].y;\n"
"#endif\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms) {\n"
"        mixed4 vel = velm[index];\n"
"        if (vel.w != 0) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            mixed4 delta = posDelta[index];\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"            vel.x = (mixed) (invStepSize*delta.x);\n"
"            vel.y = (mixed) (invStepSize*delta.y);\n"
"            vel.z = (mixed) (invStepSize*delta.z);\n"
"#else\n"
"            vel.x = invStepSize*delta.x + correction*delta.x;\n"
"            vel.y = invStepSize*delta.y + correction*delta.y;\n"
"            vel.z = invStepSize*delta.z + correction*delta.z;\n"
"#endif\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"            velm[index] = vel;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Select the step size to use for the next step.\n"
" */\n"
"\n"
"KERNEL void selectLangevinStepSize(int numAtoms, int paddedNumAtoms, mixed maxStepSize, mixed errorTol, mixed friction, mixed kT, GLOBAL mixed2* RESTRICT dt,\n"
"        GLOBAL const mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, GLOBAL mixed* RESTRICT paramBuffer) {\n"
"    // Calculate the error.\n"
"\n"
"    LOCAL mixed error[256];\n"
"    LOCAL mixed params[MaxParams];\n"
"    mixed err = 0;\n"
"    const mixed scale = RECIP((mixed) 0x100000000);\n"
"    for (int index = LOCAL_ID; index < numAtoms; index += LOCAL_SIZE) {\n"
"        mixed3 f = make_mixed3(scale*force[index], scale*force[index+paddedNumAtoms], scale*force[index+paddedNumAtoms*2]);\n"
"        mixed invMass = velm[index].w;\n"
"        err += (f.x*f.x + f.y*f.y + f.z*f.z)*invMass*invMass;\n"
"    }\n"
"    error[LOCAL_ID] = err;\n"
"    SYNC_THREADS;\n"
"\n"
"    // Sum the errors from all threads.\n"
"\n"
"    for (unsigned int offset = 1; offset < LOCAL_SIZE; offset *= 2) {\n"
"        if (LOCAL_ID+offset < LOCAL_SIZE && (LOCAL_ID&(2*offset-1)) == 0)\n"
"            error[LOCAL_ID] += error[LOCAL_ID+offset];\n"
"        SYNC_THREADS;\n"
"    }\n"
"    if (GLOBAL_ID == 0) {\n"
"        // Select the new step size.\n"
"\n"
"        mixed totalError = SQRT(error[0]/(numAtoms*3));\n"
"        mixed newStepSize = SQRT(errorTol/totalError);\n"
"        mixed oldStepSize = dt[0].y;\n"
"        if (oldStepSize > 0.0f)\n"
"            newStepSize = min(newStepSize, oldStepSize*2.0f); // For safety, limit how quickly dt can increase.\n"
"        if (newStepSize > oldStepSize && newStepSize < 1.1f*oldStepSize)\n"
"            newStepSize = oldStepSize; // Keeping dt constant between steps improves the behavior of the integrator.\n"
"        if (newStepSize > maxStepSize)\n"
"            newStepSize = maxStepSize;\n"
"        dt[0].y = newStepSize;\n"
"\n"
"        // Recalculate the integration parameters.\n"
"\n"
"        mixed vscale = exp(-newStepSize*friction);\n"
"        mixed fscale = (friction == 0 ? newStepSize : (1-vscale)/friction);\n"
"        mixed noisescale = sqrt(kT*(1-vscale*vscale));\n"
"        params[VelScale] = vscale;\n"
"        params[ForceScale] = fscale;\n"
"        params[NoiseScale] = noisescale;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    if (LOCAL_ID < MaxParams)\n"
"        paramBuffer[LOCAL_ID] = params[LOCAL_ID];\n"
"}\n"
"";
const string CommonKernelSources::langevinMiddle = "enum {VelScale, NoiseScale};\n"
"\n"
"/**\n"
" * Perform the first part of integration: velocity step.\n"
" */\n"
"\n"
"KERNEL void integrateLangevinMiddlePart1(int numAtoms, int paddedNumAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force,\n"
"        GLOBAL const mixed2* RESTRICT dt) {\n"
"    mixed fscale = dt[0].y/(mixed) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            velocity.x += fscale*velocity.w*force[index];\n"
"            velocity.y += fscale*velocity.w*force[index+paddedNumAtoms];\n"
"            velocity.z += fscale*velocity.w*force[index+paddedNumAtoms*2];\n"
"            velm[index] = velocity;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second part of integration: position half step, then interact with heat bath,\n"
" * then another position half step.\n"
" */\n"
"\n"
"KERNEL void integrateLangevinMiddlePart2(int numAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL mixed4* RESTRICT oldDelta, GLOBAL const mixed* RESTRICT paramBuffer, GLOBAL const mixed2* RESTRICT dt, GLOBAL const float4* RESTRICT random, unsigned int randomIndex\n"
"        ) {\n"
"    mixed vscale = paramBuffer[VelScale];\n"
"    mixed noisescale = paramBuffer[NoiseScale];\n"
"    mixed halfdt = 0.5f*dt[0].y;\n"
"    int index = GLOBAL_ID;\n"
"    randomIndex += index;\n"
"    while (index < numAtoms) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            mixed4 delta = make_mixed4(halfdt*velocity.x, halfdt*velocity.y, halfdt*velocity.z, 0);\n"
"            mixed sqrtInvMass = SQRT(velocity.w);\n"
"            velocity.x = vscale*velocity.x + noisescale*sqrtInvMass*random[randomIndex].x;\n"
"            velocity.y = vscale*velocity.y + noisescale*sqrtInvMass*random[randomIndex].y;\n"
"            velocity.z = vscale*velocity.z + noisescale*sqrtInvMass*random[randomIndex].z;\n"
"            velm[index] = velocity;\n"
"            delta += make_mixed4(halfdt*velocity.x, halfdt*velocity.y, halfdt*velocity.z, 0);\n"
"            posDelta[index] = delta;\n"
"            oldDelta[index] = delta;\n"
"        }\n"
"        randomIndex += GLOBAL_SIZE;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the third part of integration: apply constraint forces to velocities, then record\n"
" * the constrained positions.\n"
" */\n"
"\n"
"KERNEL void integrateLangevinMiddlePart3(int numAtoms, GLOBAL real4* RESTRICT posq, GLOBAL mixed4* RESTRICT velm,\n"
"         GLOBAL mixed4* RESTRICT posDelta, GLOBAL mixed4* RESTRICT oldDelta, GLOBAL const mixed2* RESTRICT dt\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"    mixed invDt = 1/dt[0].y;\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            mixed4 delta = posDelta[index];\n"
"            velocity.x += (delta.x-oldDelta[index].x)*invDt;\n"
"            velocity.y += (delta.y-oldDelta[index].y)*invDt;\n"
"            velocity.z += (delta.z-oldDelta[index].z)*invDt;\n"
"            velm[index] = velocity;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::monteCarloBarostat = "/**\n"
" * Scale the particle positions with each axis independent.\n"
" */\n"
"\n"
"KERNEL void scalePositions(float scaleX, float scaleY, float scaleZ, int numMolecules, real4 periodicBoxSize,\n"
"        real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, GLOBAL real4* RESTRICT posq,\n"
"        GLOBAL const int* RESTRICT moleculeAtoms, GLOBAL const int* RESTRICT moleculeStartIndex) {\n"
"    for (int index = GLOBAL_ID; index < numMolecules; index += GLOBAL_SIZE) {\n"
"        int first = moleculeStartIndex[index];\n"
"        int last = moleculeStartIndex[index+1];\n"
"        int numAtoms = last-first;\n"
"\n"
"        // Find the center of each molecule.\n"
"\n"
"        real3 center = make_real3(0, 0, 0);\n"
"        for (int atom = first; atom < last; atom++) {\n"
"            real4 pos = posq[moleculeAtoms[atom]];\n"
"            center.x += pos.x;\n"
"            center.y += pos.y;\n"
"            center.z += pos.z;\n"
"        }\n"
"        real invNumAtoms = RECIP((real) numAtoms);\n"
"        center.x *= invNumAtoms;\n"
"        center.y *= invNumAtoms;\n"
"        center.z *= invNumAtoms;\n"
"\n"
"        // Now scale the position of the molecule center.\n"
"\n"
"        real3 delta;\n"
"        delta.x = center.x*(scaleX-1);\n"
"        delta.y = center.y*(scaleY-1);\n"
"        delta.z = center.z*(scaleZ-1);\n"
"        for (int atom = first; atom < last; atom++) {\n"
"            real4 pos = posq[moleculeAtoms[atom]];\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"            posq[moleculeAtoms[atom]] = pos;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::nonbondedExceptions = "float4 exceptionParams = PARAMS[index];\n"
"real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"real invR = RSQRT(r2);\n"
"real sig2 = invR*exceptionParams.y;\n"
"sig2 *= sig2;\n"
"real sig6 = sig2*sig2*sig2;\n"
"real dEdR = exceptionParams.z*(12.0f*sig6-6.0f)*sig6;\n"
"real tempEnergy = exceptionParams.z*(sig6-1.0f)*sig6;\n"
"dEdR += exceptionParams.x*invR;\n"
"dEdR *= invR*invR;\n"
"tempEnergy += exceptionParams.x*invR;\n"
"energy += tempEnergy;\n"
"delta *= dEdR;\n"
"real3 force1 = -delta;\n"
"real3 force2 = delta;\n"
"";
const string CommonKernelSources::nonbondedParameters = "/**\n"
" * Compute the nonbonded parameters for particles and exceptions.\n"
" */\n"
"KERNEL void computeParameters(GLOBAL mixed* RESTRICT energyBuffer, int includeSelfEnergy, GLOBAL real* RESTRICT globalParams,\n"
"        int numAtoms, GLOBAL const float4* RESTRICT baseParticleParams, GLOBAL real4* RESTRICT posq, GLOBAL real* RESTRICT charge,\n"
"        GLOBAL float2* RESTRICT sigmaEpsilon, GLOBAL float4* RESTRICT particleParamOffsets, GLOBAL int* RESTRICT particleOffsetIndices\n"
"#ifdef HAS_EXCEPTIONS\n"
"        , int numExceptions, GLOBAL const float4* RESTRICT baseExceptionParams, GLOBAL float4* RESTRICT exceptionParams,\n"
"        GLOBAL float4* RESTRICT exceptionParamOffsets, GLOBAL int* RESTRICT exceptionOffsetIndices\n"
"#endif\n"
"        ) {\n"
"    mixed energy = 0;\n"
"\n"
"    // Compute particle parameters.\n"
"    \n"
"    for (int i = GLOBAL_ID; i < numAtoms; i += GLOBAL_SIZE) {\n"
"        float4 params = baseParticleParams[i];\n"
"#ifdef HAS_PARTICLE_OFFSETS\n"
"        int start = particleOffsetIndices[i], end = particleOffsetIndices[i+1];\n"
"        for (int j = start; j < end; j++) {\n"
"            float4 offset = particleParamOffsets[j];\n"
"            real value = globalParams[(int) offset.w];\n"
"            params.x += value*offset.x;\n"
"            params.y += value*offset.y;\n"
"            params.z += value*offset.z;\n"
"        }\n"
"#endif\n"
"#ifdef USE_POSQ_CHARGES\n"
"        posq[i].w = params.x;\n"
"#else\n"
"        charge[i] = params.x;\n"
"#endif\n"
"        sigmaEpsilon[i] = make_float2(0.5f*params.y, 2*SQRT(params.z));\n"
"#ifdef HAS_OFFSETS\n"
"    #ifdef INCLUDE_EWALD\n"
"        energy -= EWALD_SELF_ENERGY_SCALE*params.x*params.x;\n"
"    #endif\n"
"    #ifdef INCLUDE_LJPME\n"
"        real sig3 = params.y*params.y*params.y;\n"
"        energy += LJPME_SELF_ENERGY_SCALE*sig3*sig3*params.z;\n"
"    #endif\n"
"#endif\n"
"    }\n"
"\n"
"    // Compute exception parameters.\n"
"    \n"
"#ifdef HAS_EXCEPTIONS\n"
"    for (int i = GLOBAL_ID; i < numExceptions; i += GLOBAL_SIZE) {\n"
"        float4 params = baseExceptionParams[i];\n"
"#ifdef HAS_EXCEPTION_OFFSETS\n"
"        int start = exceptionOffsetIndices[i], end = exceptionOffsetIndices[i+1];\n"
"        for (int j = start; j < end; j++) {\n"
"            float4 offset = exceptionParamOffsets[j];\n"
"            real value = globalParams[(int) offset.w];\n"
"            params.x += value*offset.x;\n"
"            params.y += value*offset.y;\n"
"            params.z += value*offset.z;\n"
"        }\n"
"#endif\n"
"        exceptionParams[i] = make_float4((float) (ONE_4PI_EPS0*params.x), (float) params.y, (float) (4*params.z), 0);\n"
"    }\n"
"#endif\n"
"    if (includeSelfEnergy)\n"
"        energyBuffer[GLOBAL_ID] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute parameters for subtracting the reciprocal part of excluded interactions.\n"
" */\n"
"KERNEL void computeExclusionParameters(GLOBAL real4* RESTRICT posq, GLOBAL real* RESTRICT charge, GLOBAL float2* RESTRICT sigmaEpsilon,\n"
"        int numExclusions, GLOBAL const int2* RESTRICT exclusionAtoms, GLOBAL float4* RESTRICT exclusionParams) {\n"
"    for (int i = GLOBAL_ID; i < numExclusions; i += GLOBAL_SIZE) {\n"
"        int2 atoms = exclusionAtoms[i];\n"
"#ifdef USE_POSQ_CHARGES\n"
"        real chargeProd = posq[atoms.x].w*posq[atoms.y].w;\n"
"#else\n"
"        real chargeProd = charge[atoms.x]*charge[atoms.y];\n"
"#endif\n"
"#ifdef INCLUDE_LJPME_EXCEPTIONS\n"
"        float2 sigEps1 = sigmaEpsilon[atoms.x];\n"
"        float2 sigEps2 = sigmaEpsilon[atoms.y];\n"
"        float sigma = sigEps1.x*sigEps2.x;\n"
"        float epsilon = sigEps1.y*sigEps2.y;\n"
"#else\n"
"        float sigma = 0;\n"
"        float epsilon = 0;\n"
"#endif\n"
"        exclusionParams[i] = make_float4((float) (ONE_4PI_EPS0*chargeProd), sigma, epsilon, 0);\n"
"    }\n"
"}";
const string CommonKernelSources::noseHooverChain = "// Propagates a Nose Hoover chain a full timestep\n"
"KERNEL void propagateNoseHooverChain(GLOBAL mixed2* RESTRICT chainData, GLOBAL const mixed2 * RESTRICT energySum, GLOBAL mixed2* RESTRICT scaleFactor,\n"
"                                     GLOBAL mixed* RESTRICT chainMasses, GLOBAL mixed* RESTRICT chainForces, int chainType, int chainLength, int numMTS,\n"
"                                     int numDOFs, float timeStep, mixed kT, float frequency){\n"
"    const mixed kineticEnergy = chainType == 0 ? energySum[0].x : energySum[0].y;\n"
"    mixed scale = 1;\n"
"    if(kineticEnergy < 1e-8) return;\n"
"    for (int bead = 0; bead < chainLength; ++bead) chainMasses[bead] = kT / (frequency * frequency);\n"
"    chainMasses[0] *= numDOFs;\n"
"    mixed KE2 = 2.0f * kineticEnergy;\n"
"    mixed timeOverMTS = timeStep / numMTS;\n"
"    chainForces[0] = (KE2 - numDOFs * kT) / chainMasses[0];\n"
"    for (int bead = 0; bead < chainLength - 1; ++bead) {\n"
"        chainForces[bead + 1] = (chainMasses[bead] * chainData[bead].y * chainData[bead].y - kT) / chainMasses[bead + 1];\n"
"    }\n"
"    for (int mts = 0; mts < numMTS; ++mts) {\n"
"        BEGIN_YS_LOOP\n"
"            mixed wdt = ys * timeOverMTS;\n"
"            chainData[chainLength-1].y += 0.5f * wdt * chainForces[chainLength-1];\n"
"            for (int bead = chainLength - 2; bead >= 0; --bead) {\n"
"                mixed aa = exp(-0.25f * wdt * chainData[bead + 1].y);\n"
"                chainData[bead].y = aa * (chainData[bead].y * aa + 0.5f * wdt * chainForces[bead]);\n"
"            }\n"
"            // update particle velocities\n"
"            scale *= (mixed) exp(-wdt * chainData[0].y);;\n"
"            // update the thermostat positions\n"
"            for (int bead = 0; bead < chainLength; ++bead) {\n"
"                chainData[bead].x += chainData[bead].y * wdt;\n"
"            }\n"
"            // update the forces\n"
"            chainForces[0] = (scale * scale * KE2 - numDOFs * kT) / chainMasses[0];\n"
"            // update thermostat velocities\n"
"            for (int bead = 0; bead < chainLength - 1; ++bead) {\n"
"                mixed aa = exp(-0.25f * wdt * chainData[bead + 1].y);\n"
"                chainData[bead].y = aa * (aa * chainData[bead].y + 0.5f * wdt * chainForces[bead]);\n"
"                chainForces[bead + 1] = (chainMasses[bead] * chainData[bead].y * chainData[bead].y - kT) / chainMasses[bead + 1];\n"
"            }\n"
"            chainData[chainLength-1].y += 0.5f * wdt * chainForces[chainLength-1];\n"
"        END_YS_LOOP\n"
"    } // MTS loop\n"
"    if (chainType == 0) {\n"
"        scaleFactor[0].x = scale;\n"
"    } else {\n"
"        scaleFactor[0].y = scale;\n"
"    }\n"
"}\n"
"\n"
"\n"
"/**\n"
" * Compute total (potential + kinetic) energy of the Nose-Hoover beads\n"
" */\n"
"KERNEL void computeHeatBathEnergy(GLOBAL mixed* RESTRICT heatBathEnergy, int chainLength, int numDOFs,\n"
"                                  mixed kT, float frequency, GLOBAL const mixed2* RESTRICT chainData){\n"
"    // Note that this is always incremented; make sure it's zeroed properly before the first call\n"
"    for(int i = 0; i < chainLength; ++i) {\n"
"        mixed prefac = i ? 1 : numDOFs;\n"
"        mixed mass = prefac * kT / (frequency * frequency);\n"
"        mixed velocity = chainData[i].y; \n"
"        // The kinetic energy of this bead\n"
"        heatBathEnergy[0] += 0.5f * mass * velocity * velocity;\n"
"        // The potential energy of this bead\n"
"        mixed position = chainData[i].x;\n"
"        heatBathEnergy[0] += prefac * kT * position;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void computeAtomsKineticEnergy(GLOBAL mixed2 * RESTRICT energyBuffer, int numAtoms,\n"
"                                      GLOBAL const mixed4* RESTRICT velm, GLOBAL const int *RESTRICT atoms){\n"
"    mixed2 energy = make_mixed2(0,0);\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms){\n"
"        int atom = atoms[index];\n"
"        mixed4 v = velm[atom];\n"
"        mixed mass = v.w == 0 ? 0 : 1 / v.w;\n"
"        energy.x += 0.5f * mass * (v.x*v.x + v.y*v.y + v.z*v.z);\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"    energyBuffer[GLOBAL_ID] = energy;\n"
"}\n"
"\n"
"KERNEL void computePairsKineticEnergy(GLOBAL mixed2 * RESTRICT energyBuffer, int numPairs,\n"
"                                      GLOBAL const mixed4* RESTRICT velm, GLOBAL const int2 *RESTRICT pairs){\n"
"    mixed2 energy = make_mixed2(0,0);\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numPairs){\n"
"        int2 pair = pairs[index];\n"
"        int atom1 = pair.x;\n"
"        int atom2 = pair.y;\n"
"        mixed4 v1 = velm[atom1];\n"
"        mixed4 v2 = velm[atom2];\n"
"        mixed m1 = v1.w == 0 ? 0 : 1 / v1.w;\n"
"        mixed m2 = v2.w == 0 ? 0 : 1 / v2.w;\n"
"        mixed4 cv;\n"
"        cv.x = (m1*v1.x + m2*v2.x) / (m1 + m2);\n"
"        cv.y = (m1*v1.y + m2*v2.y) / (m1 + m2);\n"
"        cv.z = (m1*v1.z + m2*v2.z) / (m1 + m2);\n"
"        mixed4 rv;\n"
"        rv.x = v2.x - v1.x;\n"
"        rv.y = v2.y - v1.y;\n"
"        rv.z = v2.z - v1.z;\n"
"        energy.x += 0.5f * (m1 + m2) * (cv.x*cv.x + cv.y*cv.y + cv.z*cv.z);\n"
"        energy.y += 0.5f * (m1 * m2 / (m1 + m2)) * (rv.x*rv.x + rv.y*rv.y + rv.z*rv.z);\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"    // The atoms version of this has been called already, so accumulate instead of assigning here\n"
"    energyBuffer[GLOBAL_ID].x += energy.x;\n"
"    energyBuffer[GLOBAL_ID].y += energy.y;\n"
"}\n"
"\n"
"KERNEL void scaleAtomsVelocities(GLOBAL mixed2* RESTRICT scaleFactor, int numAtoms,\n"
"                                   GLOBAL mixed4* RESTRICT velm, GLOBAL const int *RESTRICT atoms){\n"
"    const mixed scale = scaleFactor[0].x;\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms){\n"
"        int atom = atoms[index];\n"
"        velm[atom].x *= scale;\n"
"        velm[atom].y *= scale;\n"
"        velm[atom].z *= scale;\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void scalePairsVelocities(GLOBAL mixed2 * RESTRICT scaleFactor, int numPairs,\n"
"                                 GLOBAL mixed4* RESTRICT velm, GLOBAL const int2 *RESTRICT pairs){\n"
"    int index = GLOBAL_ID;\n"
"    mixed comScale = scaleFactor[0].x;\n"
"    mixed relScale = scaleFactor[0].y;\n"
"    while (index < numPairs){\n"
"        int atom1 = pairs[index].x;\n"
"        int atom2 = pairs[index].y;\n"
"        mixed m1 = velm[atom1].w == 0 ? 0 : 1 / velm[atom1].w;\n"
"        mixed m2 = velm[atom2].w == 0 ? 0 : 1 / velm[atom2].w;\n"
"        mixed4 cv;\n"
"        cv.x = (m1*velm[atom1].x + m2*velm[atom2].x) / (m1 + m2);\n"
"        cv.y = (m1*velm[atom1].y + m2*velm[atom2].y) / (m1 + m2);\n"
"        cv.z = (m1*velm[atom1].z + m2*velm[atom2].z) / (m1 + m2);\n"
"        mixed4 rv;\n"
"        rv.x = velm[atom2].x - velm[atom1].x;\n"
"        rv.y = velm[atom2].y - velm[atom1].y;\n"
"        rv.z = velm[atom2].z - velm[atom1].z;\n"
"        velm[atom1].x = comScale * cv.x - relScale * rv.x * m2 / (m1 + m2);\n"
"        velm[atom1].y = comScale * cv.y - relScale * rv.y * m2 / (m1 + m2);\n"
"        velm[atom1].z = comScale * cv.z - relScale * rv.z * m2 / (m1 + m2);\n"
"        velm[atom2].x = comScale * cv.x + relScale * rv.x * m1 / (m1 + m2);\n"
"        velm[atom2].y = comScale * cv.y + relScale * rv.y * m1 / (m1 + m2);\n"
"        velm[atom2].z = comScale * cv.z + relScale * rv.z * m1 / (m1 + m2);\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the energy buffer containing a pair of energies stored as mixed2.  This is taken from the analogous customIntegrator code\n"
" */\n"
"KERNEL void reduceEnergyPair(GLOBAL const mixed2* RESTRICT sumBuffer, GLOBAL mixed2* result, int bufferSize) {\n"
"    LOCAL mixed2 tempBuffer[WORK_GROUP_SIZE];\n"
"    const unsigned int thread = LOCAL_ID;\n"
"    mixed2 sum = make_mixed2(0,0);\n"
"    for (unsigned int index = thread; index < bufferSize; index += LOCAL_SIZE) {\n"
"        sum.x += sumBuffer[index].x;\n"
"        sum.y += sumBuffer[index].y;\n"
"    }\n"
"    tempBuffer[thread].x = sum.x;\n"
"    tempBuffer[thread].y = sum.y;\n"
"    for (int i = 1; i < WORK_GROUP_SIZE; i *= 2) {\n"
"        SYNC_THREADS;\n"
"        if (thread%(i*2) == 0 && thread+i < WORK_GROUP_SIZE) {\n"
"            tempBuffer[thread].x += tempBuffer[thread+i].x;\n"
"            tempBuffer[thread].y += tempBuffer[thread+i].y;\n"
"        }\n"
"    }\n"
"    if (thread == 0)\n"
"        *result = tempBuffer[0];\n"
"}\n"
"";
const string CommonKernelSources::noseHooverIntegrator = "/**\n"
" * Perform the first part of integration: velocity step.\n"
" */\n"
"KERNEL void integrateNoseHooverMiddlePart1(int numAtoms, int numPairs, int paddedNumAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force,\n"
"        GLOBAL const mixed2* RESTRICT dt, GLOBAL const int* RESTRICT atomList, GLOBAL const int2* RESTRICT pairList) {\n"
"    mixed fscale = dt[0].y/(mixed) 0x100000000;\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms) {\n"
"        int atom = atomList[index];\n"
"        mixed4 velocity = velm[atom];\n"
"        if (velocity.w != 0.0) {\n"
"            velocity.x += fscale*force[atom]*velocity.w;\n"
"            velocity.y += fscale*force[atom+paddedNumAtoms]*velocity.w;\n"
"            velocity.z += fscale*force[atom+paddedNumAtoms*2]*velocity.w;\n"
"            velm[atom] = velocity;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"    index = GLOBAL_ID;\n"
"    while (index < numPairs){\n"
"        int atom1 = pairList[index].x;\n"
"        int atom2 = pairList[index].y;\n"
"        mixed4 v1 = velm[atom1];\n"
"        mixed4 v2 = velm[atom2];\n"
"        mixed m1 = v1.w == 0.0f ? 0.0f : 1.0f / v1.w;\n"
"        mixed m2 = v2.w == 0.0f ? 0.0f : 1.0f / v2.w;\n"
"        mixed mass1fract = m1 / (m1 + m2);\n"
"        mixed mass2fract = m2 / (m1 + m2);\n"
"        mixed invRedMass = (m1 * m2 != 0.0f) ? (m1 + m2)/(m1 * m2) : 0.0f;\n"
"        mixed invTotMass = (m1 + m2 != 0.0f) ? 1.0f /(m1 + m2) : 0.0f;\n"
"        mixed3 comVel;\n"
"        comVel.x= v1.x*mass1fract + v2.x*mass2fract;\n"
"        comVel.y= v1.y*mass1fract + v2.y*mass2fract;\n"
"        comVel.z= v1.z*mass1fract + v2.z*mass2fract;\n"
"        mixed3 relVel;\n"
"        relVel.x= v2.x - v1.x;\n"
"        relVel.y= v2.y - v1.y;\n"
"        relVel.z= v2.z - v1.z;\n"
"\n"
"        mixed3 comFrc;\n"
"        mixed F1x = fscale*force[atom1];\n"
"        mixed F1y = fscale*force[atom1+paddedNumAtoms];\n"
"        mixed F1z = fscale*force[atom1+paddedNumAtoms*2];\n"
"        mixed F2x = fscale*force[atom2];\n"
"        mixed F2y = fscale*force[atom2+paddedNumAtoms];\n"
"        mixed F2z = fscale*force[atom2+paddedNumAtoms*2];\n"
"        comFrc.x = F1x + F2x;\n"
"        comFrc.y = F1y + F2y;\n"
"        comFrc.z = F1z + F2z;\n"
"        mixed3 relFrc;\n"
"        relFrc.x = mass1fract*F2x - mass2fract*F1x;\n"
"        relFrc.y = mass1fract*F2y - mass2fract*F1y;\n"
"        relFrc.z = mass1fract*F2z - mass2fract*F1z;\n"
"        comVel.x += comFrc.x * invTotMass;\n"
"        comVel.y += comFrc.y * invTotMass;\n"
"        comVel.z += comFrc.z * invTotMass;\n"
"        relVel.x += relFrc.x * invRedMass;\n"
"        relVel.y += relFrc.y * invRedMass;\n"
"        relVel.z += relFrc.z * invRedMass;\n"
"        if (v1.w != 0.0f) {\n"
"            v1.x = comVel.x - relVel.x*mass2fract;\n"
"            v1.y = comVel.y - relVel.y*mass2fract;\n"
"            v1.z = comVel.z - relVel.z*mass2fract;\n"
"            velm[atom1] = v1;\n"
"        }\n"
"        if (v2.w != 0.0f) {\n"
"            v2.x = comVel.x + relVel.x*mass1fract;\n"
"            v2.y = comVel.y + relVel.y*mass1fract;\n"
"            v2.z = comVel.z + relVel.z*mass1fract;\n"
"            velm[atom2] = v2;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"     }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second part of integration: position half step\n"
" */\n"
"KERNEL void integrateNoseHooverMiddlePart2(int numAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL mixed4* RESTRICT oldDelta, GLOBAL const mixed2* RESTRICT dt) {\n"
"    mixed halfdt = 0.5f*dt[0].y;\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            mixed4 delta = make_mixed4(halfdt*velocity.x, halfdt*velocity.y, halfdt*velocity.z, 0);\n"
"            posDelta[index] = delta;\n"
"            oldDelta[index] = delta;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the third part of integration: another position half step\n"
" */\n"
"KERNEL void integrateNoseHooverMiddlePart3(int numAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL mixed4* RESTRICT posDelta,\n"
"        GLOBAL mixed4* RESTRICT oldDelta, GLOBAL const mixed2* RESTRICT dt) {\n"
"    mixed halfdt = 0.5f*dt[0].y;\n"
"    int index = GLOBAL_ID;\n"
"    while (index < numAtoms) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            mixed4 delta = make_mixed4(halfdt*velocity.x, halfdt*velocity.y, halfdt*velocity.z, 0);\n"
"            posDelta[index] += delta;\n"
"            oldDelta[index] += delta;\n"
"        }\n"
"        index += GLOBAL_SIZE;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the fourth part of integration: apply constraint forces to velocities, then record\n"
" * the constrained positions.\n"
" */\n"
"KERNEL void integrateNoseHooverMiddlePart4(int numAtoms, GLOBAL real4* RESTRICT posq, GLOBAL mixed4* RESTRICT velm,\n"
"         GLOBAL mixed4* RESTRICT posDelta, GLOBAL mixed4* RESTRICT oldDelta, GLOBAL const mixed2* RESTRICT dt\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"        ) {\n"
"    mixed invDt = 1/dt[0].y;\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            mixed4 delta = posDelta[index];\n"
"            velocity.x += (delta.x-oldDelta[index].x)*invDt;\n"
"            velocity.y += (delta.y-oldDelta[index].y)*invDt;\n"
"            velocity.z += (delta.z-oldDelta[index].z)*invDt;\n"
"            velm[index] = velocity;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void integrateNoseHooverHardWall(int numPairs, GLOBAL const float* RESTRICT maxPairDistance, \n"
"                                        GLOBAL mixed2* RESTRICT dt, GLOBAL real4* RESTRICT posq,\n"
"                                        GLOBAL mixed4* RESTRICT velm, GLOBAL const int2* RESTRICT pairList,\n"
"                                        GLOBAL const float* RESTRICT pairTemperature\n"
"#ifdef USE_MIXED_PRECISION\n"
"                                        ,GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"    ){\n"
"\n"
"    mixed dtPos = dt[0].y;\n"
"    mixed maxDelta = (mixed) maxPairDistance[0];\n"
"    if (maxDelta > 0){\n"
"        int index = GLOBAL_ID;\n"
"        while(index < numPairs) {\n"
"\n"
"            const mixed hardWallScale = sqrt( ((mixed) pairTemperature[index]) * ((mixed) BOLTZ));\n"
"            int atom1 = pairList[index].x;\n"
"            int atom2 = pairList[index].y;\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 posv1 = posq[atom1];\n"
"            real4 posc1 = posqCorrection[atom1];\n"
"            mixed4 pos1 = make_mixed4(posv1.x+(mixed)posc1.x, posv1.y+(mixed)posc1.y, posv1.z+(mixed)posc1.z, posv1.w);\n"
"            real4 posv2 = posq[atom2];\n"
"            real4 posc2 = posqCorrection[atom2];\n"
"            mixed4 pos2 = make_mixed4(posv2.x+(mixed)posc2.x, posv2.y+(mixed)posc2.y, posv2.z+(mixed)posc2.z, posv2.w);\n"
"#else\n"
"            real4 pos1 = posq[atom1];\n"
"            real4 pos2 = posq[atom2];\n"
"#endif\n"
"            mixed3 delta = make_mixed3(pos1.x - pos2.x, pos1.y - pos2.y, pos1.z - pos2.z);\n"
"            mixed r = sqrt(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"            mixed rInv = 1/r;\n"
"            if (rInv*maxDelta < 1.0) {\n"
"                // The constraint has been violated, so make the inter-particle distance \"bounce\"\n"
"                // off the hard wall.\n"
"                mixed3 bondDir = make_mixed3(delta.x * rInv, delta.y * rInv, delta.z * rInv);\n"
"                mixed3 vel1 = make_mixed3(velm[atom1].x, velm[atom1].y, velm[atom1].z);\n"
"                mixed3 vel2 = make_mixed3(velm[atom2].x, velm[atom2].y, velm[atom2].z);\n"
"                mixed m1 = velm[atom1].w != 0.0 ? 1.0/velm[atom1].w : 0.0;\n"
"                mixed m2 = velm[atom2].w != 0.0 ? 1.0/velm[atom2].w : 0.0;\n"
"                mixed invTotMass = (m1 + m2 != 0.0) ? 1.0 /(m1 + m2) : 0.0;\n"
"                mixed deltaR = r-maxDelta;\n"
"                mixed deltaT = dtPos;\n"
"                mixed dt = dtPos;\n"
"\n"
"                mixed dotvr1 = vel1.x*bondDir.x + vel1.y*bondDir.y + vel1.z*bondDir.z;\n"
"                mixed3 vb1 = make_mixed3(bondDir.x*dotvr1, bondDir.y*dotvr1, bondDir.z*dotvr1);\n"
"                mixed3 vp1 = make_mixed3(vel1.x-vb1.x, vel1.y-vb1.y, vel1.z-vb1.z);\n"
"                if (m2 == 0) {\n"
"                    // The parent particle is massless, so move only the Drude particle.\n"
"\n"
"                    if (dotvr1 != 0.0)\n"
"                        deltaT = deltaR/fabs(dotvr1);\n"
"                    if (deltaT > dtPos)\n"
"                        deltaT = dtPos;\n"
"                    dotvr1 = -dotvr1*hardWallScale/(fabs(dotvr1)*sqrt(m1));\n"
"                    mixed dr = -deltaR + deltaT*dotvr1;\n"
"                    pos1.x += bondDir.x*dr;\n"
"                    pos1.y += bondDir.y*dr;\n"
"                    pos1.z += bondDir.z*dr;\n"
"                    velm[atom1] = make_mixed4(vp1.x + bondDir.x*dotvr1, vp1.y + bondDir.y*dotvr1, vp1.z + bondDir.z*dotvr1, velm[atom1].w);\n"
"#ifdef USE_MIXED_PRECISION\n"
"                    posq[atom1] = make_real4((real) pos1.x, (real) pos1.y, (real) pos1.z, (real) pos1.w);\n"
"                    posqCorrection[atom1] = make_real4(pos1.x-(real) pos1.x, pos1.y-(real) pos1.y, pos1.z-(real) pos1.z, 0);\n"
"#else\n"
"                    posq[atom1] = pos1;\n"
"#endif\n"
"                }\n"
"                else {\n"
"                    // Move both particles.\n"
"                    mixed dotvr2 = vel2.x*bondDir.x + vel2.y*bondDir.y + vel2.z*bondDir.z;\n"
"                    mixed3 vb2 = make_mixed3(bondDir.x*dotvr2, bondDir.y*dotvr2, bondDir.z*dotvr2);\n"
"                    mixed3 vp2 = make_mixed3(vel2.x-vb2.x, vel2.y-vb2.y, vel2.z-vb2.z);\n"
"                    mixed vbCMass = (m1*dotvr1 + m2*dotvr2)*invTotMass;\n"
"                    dotvr1 -= vbCMass;\n"
"                    dotvr2 -= vbCMass;\n"
"                    if (dotvr1 != dotvr2)\n"
"                        deltaT = deltaR/fabs(dotvr1-dotvr2);\n"
"                    if (deltaT > dt)\n"
"                        deltaT = dt;\n"
"                    mixed vBond = hardWallScale/sqrt(m1);\n"
"                    dotvr1 = -dotvr1*vBond*m2*invTotMass/fabs(dotvr1);\n"
"                    dotvr2 = -dotvr2*vBond*m1*invTotMass/fabs(dotvr2);\n"
"                    mixed dr1 = -deltaR*m2*invTotMass + deltaT*dotvr1;\n"
"                    mixed dr2 = deltaR*m1*invTotMass + deltaT*dotvr2;\n"
"                    dotvr1 += vbCMass;\n"
"                    dotvr2 += vbCMass;\n"
"                    pos1.x += bondDir.x*dr1;\n"
"                    pos1.y += bondDir.y*dr1;\n"
"                    pos1.z += bondDir.z*dr1;\n"
"                    pos2.x += bondDir.x*dr2;\n"
"                    pos2.y += bondDir.y*dr2;\n"
"                    pos2.z += bondDir.z*dr2;\n"
"                    velm[atom1] = make_mixed4(vp1.x + bondDir.x*dotvr1, vp1.y + bondDir.y*dotvr1, vp1.z + bondDir.z*dotvr1, velm[atom1].w);\n"
"                    velm[atom2] = make_mixed4(vp2.x + bondDir.x*dotvr2, vp2.y + bondDir.y*dotvr2, vp2.z + bondDir.z*dotvr2, velm[atom2].w);\n"
"#ifdef USE_MIXED_PRECISION\n"
"                    posq[atom1] = make_real4((real) pos1.x, (real) pos1.y, (real) pos1.z, (real) pos1.w);\n"
"                    posq[atom2] = make_real4((real) pos2.x, (real) pos2.y, (real) pos2.z, (real) pos2.w);\n"
"                    posqCorrection[atom1] = make_real4(pos1.x-(real) pos1.x, pos1.y-(real) pos1.y, pos1.z-(real) pos1.z, 0);\n"
"                    posqCorrection[atom2] = make_real4(pos2.x-(real) pos2.x, pos2.y-(real) pos2.y, pos2.z-(real) pos2.z, 0);\n"
"#else\n"
"                    posq[atom1] = pos1;\n"
"                    posq[atom2] = pos2;\n"
"#endif\n"
"                }\n"
"            }\n"
"            index += GLOBAL_SIZE;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::periodicTorsionForce = "float4 torsionParams = PARAMS[index];\n"
"real deltaAngle = torsionParams.z*theta-torsionParams.y;\n"
"energy += torsionParams.x*(1.0f+COS(deltaAngle));\n"
"real sinDeltaAngle = SIN(deltaAngle);\n"
"real dEdAngle = -torsionParams.x*torsionParams.z*sinDeltaAngle;\n"
"";
const string CommonKernelSources::pme = "KERNEL void findAtomGridIndex(GLOBAL const real4* RESTRICT posq, GLOBAL int2* RESTRICT pmeAtomGridIndex,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ\n"
"#ifndef SUPPORTS_64_BIT_ATOMICS\n"
"        , GLOBAL real4* RESTRICT pmeBsplineTheta, LOCAL real4* RESTRICT bsplinesCache,\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        GLOBAL const float2* RESTRICT sigmaEpsilon\n"
"#else\n"
"        GLOBAL const real* RESTRICT charges\n"
"#endif\n"
"#endif\n"
"    ) {\n"
"    // Compute the index of the grid point each atom is associated with.\n"
"\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = make_real3(pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                             pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                             pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int3 gridIndex = make_int3(((int) t.x) % GRID_SIZE_X,\n"
"                                   ((int) t.y) % GRID_SIZE_Y,\n"
"                                   ((int) t.z) % GRID_SIZE_Z);\n"
"        pmeAtomGridIndex[atom] = make_int2(atom, gridIndex.x*GRID_SIZE_Y*GRID_SIZE_Z+gridIndex.y*GRID_SIZE_Z+gridIndex.z);\n"
"#ifndef SUPPORTS_64_BIT_ATOMICS\n"
"        // Compute B-splines here for use in the charge spreading kernel.\n"
"        const real4 scale = 1/(real) (PME_ORDER-1);\n"
"        LOCAL real4* data = &bsplinesCache[LOCAL_ID*PME_ORDER];\n"
"        real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+make_real4(k))*data[j-k-2] + (-dr+make_real4(j-k))*data[j-k-1]);\n"
"            data[0] = div*(- dr+1.0f)*data[0];\n"
"        }\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+make_real4(j))*data[PME_ORDER-j-2] + (-dr+make_real4(PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"        for (int j = 0; j < PME_ORDER; j++) {\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"            const float2 sigEps = sigmaEpsilon[atom];\n"
"            const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"            const real charge = CHARGE;\n"
"#endif\n"
"            data[j].w = charge; // Storing the charge here improves cache coherency in the charge spreading kernel\n"
"            pmeBsplineTheta[atom+j*NUM_ATOMS] = data[j];\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"KERNEL void gridSpreadCharge(GLOBAL const real4* RESTRICT posq,\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"        GLOBAL mm_ulong* RESTRICT pmeGrid,\n"
"#else\n"
"        GLOBAL real* RESTRICT pmeGrid,\n"
"#endif\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ, GLOBAL const int2* RESTRICT pmeAtomGridIndex,\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        GLOBAL const float2* RESTRICT sigmaEpsilon\n"
"#else\n"
"        GLOBAL const real* RESTRICT charges\n"
"#endif\n"
"        ) {\n"
"    // To improve memory efficiency, we divide indices along the z axis into\n"
"    // PME_ORDER blocks, where the data for each block is stored together.  We\n"
"    // can ensure that all threads write to the same block at the same time,\n"
"    // which leads to better coalescing of writes.\n"
"    \n"
"    LOCAL int zindexTable[GRID_SIZE_Z+PME_ORDER];\n"
"    int blockSize = (int) ceil(GRID_SIZE_Z/(real) PME_ORDER);\n"
"    for (int i = LOCAL_ID; i < GRID_SIZE_Z+PME_ORDER; i += LOCAL_SIZE) {\n"
"        int zindex = i % GRID_SIZE_Z;\n"
"	int block = zindex % PME_ORDER;\n"
"        zindexTable[i] = zindex/PME_ORDER + block*GRID_SIZE_X*GRID_SIZE_Y*blockSize;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    \n"
"    // Process the atoms in spatially sorted order.  This improves efficiency when writing\n"
"    // the grid values.\n"
"    \n"
"    real3 data[PME_ORDER];\n"
"    const real scale = RECIP((real) (PME_ORDER-1));\n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        int atom = pmeAtomGridIndex[i].x;\n"
"        real4 pos = posq[atom];\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        const real charge = (CHARGE)*EPSILON_FACTOR;\n"
"#endif\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = make_real3(pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                             pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                             pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int3 gridIndex = make_int3(((int) t.x) % GRID_SIZE_X,\n"
"                                   ((int) t.y) % GRID_SIZE_Y,\n"
"                                   ((int) t.z) % GRID_SIZE_Z);\n"
"        if (charge == 0)\n"
"            continue;\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real3 dr = make_real3(t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z);\n"
"        data[PME_ORDER-1] = make_real3(0);\n"
"        data[1] = dr;\n"
"        data[0] = make_real3(1)-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP((real) (j-1));\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+make_real3(k))*data[j-k-2] + (make_real3(j-k)-dr)*data[j-k-1]);\n"
"            data[0] = div*(make_real3(1)-dr)*data[0];\n"
"        }\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+make_real3(j))*data[PME_ORDER-j-2] + (make_real3(PME_ORDER-j)-dr)*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(make_real3(1)-dr)*data[0];\n"
"\n"
"        // Spread the charge from this atom onto each grid point.\n"
"\n"
"	int izoffset = (PME_ORDER-(gridIndex.z%PME_ORDER)) % PME_ORDER;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = gridIndex.x+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y;\n"
"            real dx = charge*data[ix].x;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = gridIndex.y+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = (xbase+ybase)*blockSize;\n"
"                real dxdy = dx*data[iy].y;\n"
"                for (int i = 0; i < PME_ORDER; i++) {\n"
"		    int iz = (i+izoffset) % PME_ORDER;\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    int index = ybase + zindexTable[zindex];\n"
"                    real add = dxdy*data[iz].z;\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"                    ATOMIC_ADD(&pmeGrid[index], (mm_ulong) ((mm_long) (add*0x100000000)));\n"
"#else\n"
"                    ATOMIC_ADD(&pmeGrid[index], add);\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"KERNEL void finishSpreadCharge(\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"        GLOBAL const mm_long* RESTRICT grid1,\n"
"#else\n"
"        GLOBAL const real* RESTRICT grid1,\n"
"#endif\n"
"        GLOBAL real* RESTRICT grid2) {\n"
"    // During charge spreading, we shuffled the order of indices along the z\n"
"    // axis to make memory access more efficient.  We now need to unshuffle\n"
"    // them.  If the values were accumulated as fixed point, we also need to\n"
"    // convert them to floating point.\n"
"\n"
"    LOCAL int zindexTable[GRID_SIZE_Z];\n"
"    int blockSize = (int) ceil(GRID_SIZE_Z/(real) PME_ORDER);\n"
"    for (int i = LOCAL_ID; i < GRID_SIZE_Z; i += LOCAL_SIZE) {\n"
"	int block = i % PME_ORDER;\n"
"        zindexTable[i] = i/PME_ORDER + block*GRID_SIZE_X*GRID_SIZE_Y*blockSize;\n"
"    }\n"
"    SYNC_THREADS;\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < gridSize; index += GLOBAL_SIZE) {\n"
"        int zindex = index%GRID_SIZE_Z;\n"
"        int loadIndex = zindexTable[zindex] + blockSize*(int) (index/GRID_SIZE_Z);\n"
"#ifdef USE_FIXED_POINT_CHARGE_SPREADING\n"
"        grid2[index] = scale*grid1[loadIndex];\n"
"#else\n"
"        grid2[index] = grid1[loadIndex];\n"
"#endif\n"
"    }\n"
"}\n"
"#elif defined(DEVICE_IS_CPU)\n"
"KERNEL void gridSpreadCharge(GLOBAL const real4* RESTRICT posq, GLOBAL real* RESTRICT pmeGrid,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ,\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        GLOBAL const float2* RESTRICT sigmaEpsilon\n"
"#else\n"
"        GLOBAL const real* RESTRICT charges\n"
"#endif\n"
"    ) {\n"
"    const int firstx = GLOBAL_ID*GRID_SIZE_X/GLOBAL_SIZE;\n"
"    const int lastx = (GLOBAL_ID+1)*GRID_SIZE_X/GLOBAL_SIZE;\n"
"    if (firstx == lastx)\n"
"        return;\n"
"    const real4 scale = 1/(real) (PME_ORDER-1);\n"
"    real4 data[PME_ORDER];\n"
"    \n"
"    // Process the atoms in spatially sorted order.  This improves efficiency when writing\n"
"    // the grid values.\n"
"    \n"
"    for (int i = 0; i < NUM_ATOMS; i++) {\n"
"        int atom = i;\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = (real3) (pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                           pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                           pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"\n"
"        // Spread the charge from this atom onto each grid point.\n"
"\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        const real charge = (CHARGE)*EPSILON_FACTOR;\n"
"#endif\n"
"        if (charge == 0)\n"
"            continue;\n"
"        bool hasComputedThetas = false;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            if (xindex < firstx || xindex >= lastx)\n"
"                continue;\n"
"            if (!hasComputedThetas) {\n"
"                hasComputedThetas = true;\n"
"                \n"
"                // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"                // from global memory.\n"
"\n"
"                real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"                data[PME_ORDER-1] = 0.0f;\n"
"                data[1] = dr;\n"
"                data[0] = 1.0f-dr;\n"
"                for (int j = 3; j < PME_ORDER; j++) {\n"
"                    real div = RECIP(j-1.0f);\n"
"                    data[j-1] = div*dr*data[j-2];\n"
"                    for (int k = 1; k < (j-1); k++)\n"
"                        data[j-k-1] = div*((dr+(real4) k) *data[j-k-2] + (-dr+(real4) (j-k))*data[j-k-1]);\n"
"                    data[0] = div*(- dr+1.0f)*data[0];\n"
"                }\n"
"                data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"                for (int j = 1; j < (PME_ORDER-1); j++)\n"
"                    data[PME_ORDER-j-1] = scale*((dr+(real4) j)*data[PME_ORDER-j-2] + (-dr+(real4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"                data[0] = scale*(-dr+1.0f)*data[0];\n"
"            }\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    pmeGrid[index] += charge*data[ix].x*data[iy].y*data[iz].z;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"#else\n"
"/**\n"
" * For each grid point, find the range of sorted atoms associated with that point.\n"
" */\n"
"KERNEL void findAtomRangeForGrid(GLOBAL int2* RESTRICT pmeAtomGridIndex, GLOBAL int* RESTRICT pmeAtomRange, GLOBAL const real4* RESTRICT posq) {\n"
"    int start = (NUM_ATOMS*GLOBAL_ID)/GLOBAL_SIZE;\n"
"    int end = (NUM_ATOMS*(GLOBAL_ID+1))/GLOBAL_SIZE;\n"
"    int last = (start == 0 ? -1 : pmeAtomGridIndex[start-1].y);\n"
"    for (int i = start; i < end; ++i) {\n"
"        int2 atomData = pmeAtomGridIndex[i];\n"
"        int gridIndex = atomData.y;\n"
"        if (gridIndex != last) {\n"
"            for (int j = last+1; j <= gridIndex; ++j)\n"
"                pmeAtomRange[j] = i;\n"
"            last = gridIndex;\n"
"        }\n"
"    }\n"
"\n"
"    // Fill in values beyond the last atom.\n"
"\n"
"    if (GLOBAL_ID == GLOBAL_SIZE-1) {\n"
"        int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        for (int j = last+1; j <= gridSize; ++j)\n"
"            pmeAtomRange[j] = NUM_ATOMS;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * The grid index won't be needed again.  Reuse that component to hold the z index, thus saving\n"
" * some work in the charge spreading kernel.\n"
" */\n"
"KERNEL void recordZIndex(GLOBAL int2* RESTRICT pmeAtomGridIndex, GLOBAL const real4* RESTRICT posq, real4 periodicBoxSize, real4 recipBoxVecZ) {\n"
"    int start = (NUM_ATOMS*GLOBAL_ID)/GLOBAL_SIZE;\n"
"    int end = (NUM_ATOMS*(GLOBAL_ID+1))/GLOBAL_SIZE;\n"
"    for (int i = start; i < end; ++i) {\n"
"        real posz = posq[pmeAtomGridIndex[i].x].z;\n"
"        posz -= floor(posz*recipBoxVecZ.z)*periodicBoxSize.z;\n"
"        int z = ((int) ((posz*recipBoxVecZ.z)*GRID_SIZE_Z)) % GRID_SIZE_Z;\n"
"        pmeAtomGridIndex[i].y = z;\n"
"    }\n"
"}\n"
"\n"
"KERNEL void gridSpreadCharge(GLOBAL const real4* RESTRICT posq, GLOBAL real* RESTRICT pmeGrid,\n"
"        GLOBAL const int2* RESTRICT pmeAtomGridIndex, GLOBAL const int* RESTRICT pmeAtomRange,\n"
"        GLOBAL const real4* RESTRICT pmeBsplineTheta\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        , GLOBAL const float2* RESTRICT sigmaEpsilon\n"
"#else\n"
"        , GLOBAL const real* RESTRICT charges\n"
"#endif\n"
"    ) {\n"
"    unsigned int numGridPoints = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    for (int gridIndex = GLOBAL_ID; gridIndex < numGridPoints; gridIndex += GLOBAL_SIZE) {\n"
"        // Compute the charge on a grid point.\n"
"\n"
"        int4 gridPoint;\n"
"        gridPoint.x = gridIndex/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = gridIndex-gridPoint.x*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        gridPoint.y = remainder/GRID_SIZE_Z;\n"
"        gridPoint.z = remainder-gridPoint.y*GRID_SIZE_Z;\n"
"        real result = 0.0f;\n"
"\n"
"        // Loop over all atoms that affect this grid point.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ++ix) {\n"
"            int x = gridPoint.x-ix+(gridPoint.x >= ix ? 0 : GRID_SIZE_X);\n"
"            for (int iy = 0; iy < PME_ORDER; ++iy) {\n"
"                int y = gridPoint.y-iy+(gridPoint.y >= iy ? 0 : GRID_SIZE_Y);\n"
"                int z1 = gridPoint.z-PME_ORDER+1;\n"
"                z1 += (z1 >= 0 ? 0 : GRID_SIZE_Z);\n"
"                int z2 = (z1 < gridPoint.z ? gridPoint.z : GRID_SIZE_Z-1);\n"
"                int gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z1;\n"
"                int gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z2;\n"
"                int firstAtom = pmeAtomRange[gridIndex1];\n"
"                int lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                for (int i = firstAtom; i < lastAtom; ++i)\n"
"                {\n"
"                    int2 atomData = pmeAtomGridIndex[i];\n"
"                    int atomIndex = atomData.x;\n"
"                    int z = atomData.y;\n"
"                    int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                    real atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                    result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                }\n"
"                if (z1 > gridPoint.z)\n"
"                {\n"
"                    gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z;\n"
"                    gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+gridPoint.z;\n"
"                    firstAtom = pmeAtomRange[gridIndex1];\n"
"                    lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                    for (int i = firstAtom; i < lastAtom; ++i)\n"
"                    {\n"
"                        int2 atomData = pmeAtomGridIndex[i];\n"
"                        int atomIndex = atomData.x;\n"
"                        int z = atomData.y;\n"
"                        int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                        real atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                        result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        pmeGrid[gridIndex] = result*EPSILON_FACTOR;\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"KERNEL void reciprocalConvolution(GLOBAL real2* RESTRICT pmeGrid, GLOBAL const real* RESTRICT pmeBsplineModuliX,\n"
"        GLOBAL const real* RESTRICT pmeBsplineModuliY, GLOBAL const real* RESTRICT pmeBsplineModuliZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"#ifdef USE_LJPME\n"
"    const real recipScaleFactor = -(2*M_PI/6)*SQRT(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"    real bfac = M_PI / EWALD_ALPHA;\n"
"    real fac1 = 2*M_PI*M_PI*M_PI*SQRT(M_PI);\n"
"    real fac2 = EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fac3 = -2*EWALD_ALPHA*M_PI*M_PI;\n"
"#else\n"
"    const real recipScaleFactor = RECIP(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"#endif\n"
"\n"
"    for (int index = GLOBAL_ID; index < gridSize; index += GLOBAL_SIZE) {\n"
"        // real indices\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"        int ky = remainder/(GRID_SIZE_Z/2+1);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z/2+1);\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"        real2 grid = pmeGrid[index];\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"#ifdef USE_LJPME\n"
"        real denom = recipScaleFactor/(bx*by*bz);\n"
"        real m = SQRT(m2);\n"
"        real m3 = m*m2;\n"
"        real b = bfac*m;\n"
"        real expfac = -b*b;\n"
"        real expterm = EXP(expfac);\n"
"        real erfcterm = ERFC(b);\n"
"        real eterm = (fac1*erfcterm*m3 + expterm*(fac2 + fac3*m2)) * denom;\n"
"        pmeGrid[index] = make_real2(grid.x*eterm, grid.y*eterm);\n"
"#else\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"        if (kx != 0 || ky != 0 || kz != 0) {\n"
"            pmeGrid[index] = make_real2(grid.x*eterm, grid.y*eterm);\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"KERNEL void gridEvaluateEnergy(GLOBAL real2* RESTRICT pmeGrid, GLOBAL mixed* RESTRICT energyBuffer,\n"
"                      GLOBAL const real* RESTRICT pmeBsplineModuliX, GLOBAL const real* RESTRICT pmeBsplineModuliY, GLOBAL const real* RESTRICT pmeBsplineModuliZ,\n"
"                      real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
" #ifdef USE_LJPME\n"
"    const real recipScaleFactor = -(2*M_PI/6)*SQRT(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"    real bfac = M_PI / EWALD_ALPHA;\n"
"    real fac1 = 2*M_PI*M_PI*M_PI*SQRT(M_PI);\n"
"    real fac2 = EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fac3 = -2*EWALD_ALPHA*M_PI*M_PI;\n"
"#else\n"
"    const real recipScaleFactor = RECIP(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"#endif\n"
"\n"
"    mixed energy = 0;\n"
"    for (int index = GLOBAL_ID; index < gridSize; index += GLOBAL_SIZE) {\n"
"        // real indices\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z);\n"
"        int ky = remainder/(GRID_SIZE_Z);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z);\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"#ifdef USE_LJPME\n"
"        real denom = recipScaleFactor/(bx*by*bz);\n"
"        real m = SQRT(m2);\n"
"        real m3 = m*m2;\n"
"        real b = bfac*m;\n"
"        real expfac = -b*b;\n"
"        real expterm = EXP(expfac);\n"
"        real erfcterm = ERFC(b);\n"
"        real eterm = (fac1*erfcterm*m3 + expterm*(fac2 + fac3*m2)) * denom;\n"
"#else\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"#endif\n"
"        if (kz >= (GRID_SIZE_Z/2+1)) {\n"
"            kx = ((kx == 0) ? kx : GRID_SIZE_X-kx);\n"
"            ky = ((ky == 0) ? ky : GRID_SIZE_Y-ky);\n"
"            kz = GRID_SIZE_Z-kz;\n"
"        } \n"
"        int indexInHalfComplexGrid = kz + ky*(GRID_SIZE_Z/2+1)+kx*(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        real2 grid = pmeGrid[indexInHalfComplexGrid];\n"
"#ifndef USE_LJPME\n"
"        if (kx != 0 || ky != 0 || kz != 0)\n"
"#endif\n"
"            energy += eterm*(grid.x*grid.x + grid.y*grid.y);\n"
"    }\n"
"#if defined(USE_PME_STREAM) && !defined(USE_LJPME)\n"
"    energyBuffer[GLOBAL_ID] = 0.5f*energy;\n"
"#else\n"
"    energyBuffer[GLOBAL_ID] += 0.5f*energy;\n"
"#endif\n"
"}\n"
"\n"
"KERNEL void gridInterpolateForce(GLOBAL const real4* RESTRICT posq, GLOBAL mm_ulong* RESTRICT forceBuffers, GLOBAL const real* RESTRICT pmeGrid,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ, GLOBAL const int2* RESTRICT pmeAtomGridIndex,\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        GLOBAL const float2* RESTRICT sigmaEpsilon\n"
"#else\n"
"        GLOBAL const real* RESTRICT charges\n"
"#endif\n"
"        ) {\n"
"    real3 data[PME_ORDER];\n"
"    real3 ddata[PME_ORDER];\n"
"    const real scale = RECIP((real) (PME_ORDER-1));\n"
"    \n"
"    // Process the atoms in spatially sorted order.  This improves cache performance when loading\n"
"    // the grid values.\n"
"    \n"
"    for (int i = GLOBAL_ID; i < NUM_ATOMS; i += GLOBAL_SIZE) {\n"
"        int atom = pmeAtomGridIndex[i].x;\n"
"        real3 force = make_real3(0);\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = make_real3(pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                             pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                             pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int3 gridIndex = make_int3(((int) t.x) % GRID_SIZE_X,\n"
"                                   ((int) t.y) % GRID_SIZE_Y,\n"
"                                   ((int) t.z) % GRID_SIZE_Z);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real3 dr = make_real3(t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z);\n"
"        data[PME_ORDER-1] = make_real3(0);\n"
"        data[1] = dr;\n"
"        data[0] = make_real3(1)-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP((real) (j-1));\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+make_real3(k))*data[j-k-2] + (make_real3(j-k)-dr)*data[j-k-1]);\n"
"            data[0] = div*(make_real3(1)-dr)*data[0];\n"
"        }\n"
"        ddata[0] = -data[0];\n"
"        for (int j = 1; j < PME_ORDER; j++)\n"
"            ddata[j] = data[j-1]-data[j];\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+make_real3(j))*data[PME_ORDER-j-2] + (make_real3(PME_ORDER-j)-dr)*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(make_real3(1)-dr)*data[0];\n"
"\n"
"        // Compute the force on this atom.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = gridIndex.x+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"            real dx = data[ix].x;\n"
"            real ddx = ddata[ix].x;\n"
"            \n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = gridIndex.y+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = xbase + ybase*GRID_SIZE_Z;\n"
"                real dy = data[iy].y;\n"
"                real ddy = ddata[iy].y;\n"
"                \n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = ybase + zindex;\n"
"                    real gridvalue = pmeGrid[index];\n"
"                    force.x += ddx*dy*data[iz].z*gridvalue;\n"
"                    force.y += dx*ddy*data[iz].z*gridvalue;\n"
"                    force.z += dx*dy*ddata[iz].z*gridvalue;\n"
"                }\n"
"            }\n"
"        }\n"
"#ifdef CHARGE_FROM_SIGEPS\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        real q = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        real q = CHARGE*EPSILON_FACTOR;\n"
"#endif\n"
"        real forceX = -q*(force.x*GRID_SIZE_X*recipBoxVecX.x);\n"
"        real forceY = -q*(force.x*GRID_SIZE_X*recipBoxVecY.x+force.y*GRID_SIZE_Y*recipBoxVecY.y);\n"
"        real forceZ = -q*(force.x*GRID_SIZE_X*recipBoxVecZ.x+force.y*GRID_SIZE_Y*recipBoxVecZ.y+force.z*GRID_SIZE_Z*recipBoxVecZ.z);\n"
"#ifdef USE_PME_STREAM\n"
"        ATOMIC_ADD(&forceBuffers[atom], (mm_ulong) ((mm_long) (forceX*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[atom+PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forceY*0x100000000)));\n"
"        ATOMIC_ADD(&forceBuffers[atom+2*PADDED_NUM_ATOMS], (mm_ulong) ((mm_long) (forceZ*0x100000000)));\n"
"#else\n"
"        forceBuffers[atom] += (mm_ulong) ((mm_long) (forceX*0x100000000));\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] += (mm_ulong) ((mm_long) (forceY*0x100000000));\n"
"        forceBuffers[atom+2*PADDED_NUM_ATOMS] += (mm_ulong) ((mm_long) (forceZ*0x100000000));\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"KERNEL void addForces(GLOBAL const real4* RESTRICT forces, GLOBAL mm_long* RESTRICT forceBuffers) {\n"
"    for (int atom = GLOBAL_ID; atom < NUM_ATOMS; atom += GLOBAL_SIZE) {\n"
"        real4 f = forces[atom];\n"
"        forceBuffers[atom] += (mm_long) (f.x*0x100000000);\n"
"        forceBuffers[atom+PADDED_NUM_ATOMS] += (mm_long) (f.y*0x100000000);\n"
"        forceBuffers[atom+2*PADDED_NUM_ATOMS] += (mm_long) (f.z*0x100000000);\n"
"    }\n"
"}\n"
"\n"
"KERNEL void addEnergy(GLOBAL const mixed* RESTRICT pmeEnergyBuffer, GLOBAL mixed* RESTRICT energyBuffer, int bufferSize) {\n"
"    for (int i = GLOBAL_ID; i < bufferSize; i += GLOBAL_SIZE)\n"
"        energyBuffer[i] += pmeEnergyBuffer[i];\n"
"}\n"
"";
const string CommonKernelSources::pmeExclusions = "const float4 exclusionParams = PARAMS[index];\n"
"real3 delta = make_real3(pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#if USE_PERIODIC\n"
"    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"const real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"const real r = SQRT(r2);\n"
"const real invR = RECIP(r);\n"
"const real alphaR = EWALD_ALPHA*r;\n"
"const real expAlphaRSqr = EXP(-alphaR*alphaR);\n"
"real tempForce = 0.0f;\n"
"if (alphaR > 1e-6f) {\n"
"    const real erfAlphaR = ERF(alphaR);\n"
"    const real prefactor = exclusionParams.x*invR;\n"
"    tempForce = -prefactor*(erfAlphaR-alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    energy -= prefactor*erfAlphaR;\n"
"}\n"
"else {\n"
"    energy -= TWO_OVER_SQRT_PI*EWALD_ALPHA*exclusionParams.x;\n"
"}\n"
"#if DO_LJPME\n"
"const real dispersionAlphaR = EWALD_DISPERSION_ALPHA*r;\n"
"const real dar2 = dispersionAlphaR*dispersionAlphaR;\n"
"const real dar4 = dar2*dar2;\n"
"const real dar6 = dar4*dar2;\n"
"const real invR2 = invR*invR;\n"
"const real expDar2 = EXP(-dar2);\n"
"const real c6 = 64*exclusionParams.y*exclusionParams.y*exclusionParams.y*exclusionParams.z;\n"
"const real coef = invR2*invR2*invR2*c6;\n"
"const real eprefac = 1.0f + dar2 + 0.5f*dar4;\n"
"const real dprefac = eprefac + dar6/6.0f;\n"
"energy += coef*(1.0f - expDar2*eprefac);\n"
"tempForce += 6.0f*coef*(1.0f - expDar2*dprefac);\n"
"#endif\n"
"if (r > 0)\n"
"    delta *= tempForce*invR*invR;\n"
"real3 force1 = -delta;\n"
"real3 force2 = delta;\n"
"\n"
"";
const string CommonKernelSources::pointFunctions = "/**\n"
" * Compute the angle between two vectors.  The w component of each vector should contain the squared magnitude.\n"
" */\n"
"DEVICE real computeAngle(real4 vec1, real4 vec2) {\n"
"    real dotProduct = vec1.x*vec2.x + vec1.y*vec2.y + vec1.z*vec2.z;\n"
"    real cosine = dotProduct*RSQRT(vec1.w*vec2.w);\n"
"    real angle;\n"
"    if (cosine > 0.99f || cosine < -0.99f) {\n"
"        // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"        real3 crossProduct = cross(trimTo3(vec1), trimTo3(vec2));\n"
"        real scale = vec1.w*vec2.w;\n"
"        angle = ASIN(SQRT(dot(crossProduct, crossProduct)/scale));\n"
"        if (cosine < 0)\n"
"            angle = M_PI-angle;\n"
"    }\n"
"    else\n"
"       angle = ACOS(cosine);\n"
"    return angle;\n"
"}\n"
"\n"
"/**\n"
" * Compute the cross product of two vectors, setting the fourth component to the squared magnitude.\n"
" */\n"
"DEVICE real4 computeCross(real4 vec1, real4 vec2) {\n"
"    real3 cp = cross(trimTo3(vec1), trimTo3(vec2));\n"
"    return make_real4(cp.x, cp.y, cp.z, cp.x*cp.x+cp.y*cp.y+cp.z*cp.z);\n"
"}\n"
"\n"
"";
const string CommonKernelSources::rbTorsionForce = "float4 torsionParams1 = PARAMS1[index];\n"
"float2 torsionParams2 = PARAMS2[index];\n"
"if (theta < 0)\n"
"    theta += PI;\n"
"else\n"
"    theta -= PI;\n"
"cosangle = -cosangle;\n"
"real cosFactor = cosangle;\n"
"real dEdAngle = -torsionParams1.y;\n"
"real rbEnergy = torsionParams1.x;\n"
"rbEnergy += torsionParams1.y*cosFactor;\n"
"dEdAngle -= 2.0f*torsionParams1.z*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 3.0f*torsionParams1.w*cosFactor;\n"
"rbEnergy += torsionParams1.z*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 4.0f*torsionParams2.x*cosFactor;\n"
"rbEnergy += torsionParams1.w*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 5.0f*torsionParams2.y*cosFactor;\n"
"rbEnergy += torsionParams2.x*cosFactor;\n"
"rbEnergy += torsionParams2.y*cosFactor*cosangle;\n"
"energy += rbEnergy;\n"
"dEdAngle *= SIN(theta);\n"
"";
const string CommonKernelSources::removeCM = "/**\n"
" * Calculate the center of mass momentum.\n"
" */\n"
"\n"
"KERNEL void calcCenterOfMassMomentum(int numAtoms, GLOBAL const mixed4* RESTRICT velm, GLOBAL float4* RESTRICT cmMomentum) {\n"
"    LOCAL float4 temp[64];\n"
"    float4 cm = make_float4(0);\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0) {\n"
"            mixed mass = RECIP(velocity.w);\n"
"            cm.x += (float) (velocity.x*mass);\n"
"            cm.y += (float) (velocity.y*mass);\n"
"            cm.z += (float) (velocity.z*mass);\n"
"        }\n"
"    }\n"
"\n"
"    // Sum the threads in this group.\n"
"\n"
"    int thread = LOCAL_ID;\n"
"    temp[thread] = cm;\n"
"    SYNC_THREADS;\n"
"    if (thread < 32)\n"
"        temp[thread] += temp[thread+32];\n"
"    SYNC_THREADS;\n"
"    if (thread < 16)\n"
"        temp[thread] += temp[thread+16];\n"
"    SYNC_THREADS;\n"
"    if (thread < 8)\n"
"        temp[thread] += temp[thread+8];\n"
"    SYNC_THREADS;\n"
"    if (thread < 4)\n"
"        temp[thread] += temp[thread+4];\n"
"    SYNC_THREADS;\n"
"    if (thread < 2)\n"
"        temp[thread] += temp[thread+2];\n"
"    SYNC_THREADS;\n"
"    if (thread == 0)\n"
"        cmMomentum[GROUP_ID] = temp[thread]+temp[thread+1];\n"
"}\n"
"\n"
"/**\n"
" * Remove center of mass motion.\n"
" */\n"
"\n"
"KERNEL void removeCenterOfMassMomentum(int numAtoms, GLOBAL mixed4* RESTRICT velm, GLOBAL const float4* RESTRICT cmMomentum) {\n"
"    // First sum all of the momenta that were calculated by individual groups.\n"
"\n"
"    LOCAL float4 temp[64];\n"
"    float4 cm = make_float4(0);\n"
"    for (int index = LOCAL_ID; index < NUM_GROUPS; index += LOCAL_SIZE)\n"
"        cm += cmMomentum[index];\n"
"    int thread = LOCAL_ID;\n"
"    temp[thread] = cm;\n"
"    SYNC_THREADS;\n"
"    if (thread < 32)\n"
"        temp[thread] += temp[thread+32];\n"
"    SYNC_THREADS;\n"
"    if (thread < 16)\n"
"        temp[thread] += temp[thread+16];\n"
"    SYNC_THREADS;\n"
"    if (thread < 8)\n"
"        temp[thread] += temp[thread+8];\n"
"    SYNC_THREADS;\n"
"    if (thread < 4)\n"
"        temp[thread] += temp[thread+4];\n"
"    SYNC_THREADS;\n"
"    if (thread < 2)\n"
"        temp[thread] += temp[thread+2];\n"
"    SYNC_THREADS;\n"
"    cm = make_float4(INVERSE_TOTAL_MASS*(temp[0].x+temp[1].x), INVERSE_TOTAL_MASS*(temp[0].y+temp[1].y), INVERSE_TOTAL_MASS*(temp[0].z+temp[1].z), 0);\n"
"\n"
"    // Now remove the center of mass velocity from each atom.\n"
"\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        velm[index].x -= cm.x;\n"
"        velm[index].y -= cm.y;\n"
"        velm[index].z -= cm.z;\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::rmsd = "// This file contains kernels to compute the RMSD and its gradient using the algorithm described\n"
"// in Coutsias et al, \"Using quaternions to calculate RMSD\" (doi: 10.1002/jcc.20110).\n"
"\n"
"/**\n"
" * Sum a value over all threads.\n"
" */\n"
"DEVICE real reduceValue(real value, LOCAL_ARG volatile real* temp) {\n"
"    const int thread = LOCAL_ID;\n"
"    SYNC_THREADS;\n"
"    temp[thread] = value;\n"
"    SYNC_THREADS;\n"
"    for (int step = 1; step < 32; step *= 2) {\n"
"        if (thread+step < LOCAL_SIZE && thread%(2*step) == 0)\n"
"            temp[thread] = temp[thread] + temp[thread+step];\n"
"        SYNC_WARPS;\n"
"    }\n"
"    for (int step = 32; step < LOCAL_SIZE; step *= 2) {\n"
"        if (thread+step < LOCAL_SIZE && thread%(2*step) == 0)\n"
"            temp[thread] = temp[thread] + temp[thread+step];\n"
"        SYNC_THREADS;\n"
"    }\n"
"    return temp[0];\n"
"}\n"
"\n"
"/**\n"
" * Perform the first step of computing the RMSD.  This is executed as a single work group.\n"
" */\n"
"KERNEL void computeRMSDPart1(int numParticles, GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT referencePos,\n"
"        GLOBAL const int* RESTRICT particles, GLOBAL real* buffer) {\n"
"    LOCAL volatile real temp[THREAD_BLOCK_SIZE];\n"
"\n"
"    // Compute the center of the particle positions.\n"
"    \n"
"    real3 center = make_real3(0);\n"
"    for (int i = LOCAL_ID; i < numParticles; i += LOCAL_SIZE)\n"
"        center += trimTo3(posq[particles[i]]);\n"
"    center.x = reduceValue(center.x, temp)/numParticles;\n"
"    center.y = reduceValue(center.y, temp)/numParticles;\n"
"    center.z = reduceValue(center.z, temp)/numParticles;\n"
"    \n"
"    // Compute the correlation matrix.\n"
"    \n"
"    real R[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n"
"    real sum = 0;\n"
"    for (int i = LOCAL_ID; i < numParticles; i += LOCAL_SIZE) {\n"
"        int index = particles[i];\n"
"        real3 pos = trimTo3(posq[index]) - center;\n"
"        real3 refPos = trimTo3(referencePos[index]);\n"
"        R[0][0] += pos.x*refPos.x;\n"
"        R[0][1] += pos.x*refPos.y;\n"
"        R[0][2] += pos.x*refPos.z;\n"
"        R[1][0] += pos.y*refPos.x;\n"
"        R[1][1] += pos.y*refPos.y;\n"
"        R[1][2] += pos.y*refPos.z;\n"
"        R[2][0] += pos.z*refPos.x;\n"
"        R[2][1] += pos.z*refPos.y;\n"
"        R[2][2] += pos.z*refPos.z;\n"
"        sum += dot(pos, pos);\n"
"    }\n"
"    for (int i = 0; i < 3; i++)\n"
"        for (int j = 0; j < 3; j++)\n"
"            R[i][j] = reduceValue(R[i][j], temp);\n"
"    sum = reduceValue(sum, temp);\n"
"\n"
"    // Copy everything into the output buffer to send back to the host.\n"
"    \n"
"    if (LOCAL_ID == 0) {\n"
"        for (int i = 0; i < 3; i++)\n"
"            for (int j = 0; j < 3; j++)\n"
"                buffer[3*i+j] = R[i][j];\n"
"        buffer[9] = sum;\n"
"        buffer[10] = center.x;\n"
"        buffer[11] = center.y;\n"
"        buffer[12] = center.z;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Apply forces based on the RMSD.\n"
" */\n"
"KERNEL void computeRMSDForces(int numParticles, int paddedNumAtoms, GLOBAL const real4* RESTRICT posq, GLOBAL const real4* RESTRICT referencePos,\n"
"        GLOBAL const int* RESTRICT particles, GLOBAL const real* buffer, GLOBAL mm_long* RESTRICT forceBuffers) {\n"
"    real3 center = make_real3(buffer[10], buffer[11], buffer[12]);\n"
"    real scale = 1 / (real) (buffer[9]*numParticles);\n"
"    for (int i = GLOBAL_ID; i < numParticles; i += GLOBAL_SIZE) {\n"
"        int index = particles[i];\n"
"        real3 pos = trimTo3(posq[index]) - center;\n"
"        real3 refPos = trimTo3(referencePos[index]);\n"
"        real3 rotatedRef = make_real3(buffer[0]*refPos.x + buffer[3]*refPos.y + buffer[6]*refPos.z,\n"
"                                      buffer[1]*refPos.x + buffer[4]*refPos.y + buffer[7]*refPos.z,\n"
"                                      buffer[2]*refPos.x + buffer[5]*refPos.y + buffer[8]*refPos.z);\n"
"        real3 force = (rotatedRef-pos)*scale;\n"
"        forceBuffers[index] += (mm_long) (force.x*0x100000000);\n"
"        forceBuffers[index+paddedNumAtoms] += (mm_long) (force.y*0x100000000);\n"
"        forceBuffers[index+2*paddedNumAtoms] += (mm_long) (force.z*0x100000000);\n"
"    }\n"
"}\n"
"";
const string CommonKernelSources::torsionForce = "const real PI = (real) 3.14159265358979323846;\n"
"real3 v0 = make_real3(pos1.x-pos2.x, pos1.y-pos2.y, pos1.z-pos2.z);\n"
"real3 v1 = make_real3(pos3.x-pos2.x, pos3.y-pos2.y, pos3.z-pos2.z);\n"
"real3 v2 = make_real3(pos3.x-pos4.x, pos3.y-pos4.y, pos3.z-pos4.z);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0)\n"
"APPLY_PERIODIC_TO_DELTA(v1)\n"
"APPLY_PERIODIC_TO_DELTA(v2)\n"
"#endif\n"
"real3 cp0 = cross(v0, v1);\n"
"real3 cp1 = cross(v1, v2);\n"
"real cosangle = dot(normalize(cp0), normalize(cp1));\n"
"real theta;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real3 cross_prod = cross(cp0, cp1);\n"
"    real scale = dot(cp0, cp0)*dot(cp1, cp1);\n"
"    theta = ASIN(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0)\n"
"        theta = PI-theta;\n"
"}\n"
"else\n"
"   theta = ACOS(cosangle);\n"
"theta = (dot(v0, cp1) >= 0 ? theta : -theta);\n"
"COMPUTE_FORCE\n"
"real normCross1 = dot(cp0, cp0);\n"
"real normSqrBC = dot(v1, v1);\n"
"real normBC = SQRT(normSqrBC);\n"
"real normCross2 = dot(cp1, cp1);\n"
"real dp = RECIP(normSqrBC);\n"
"real4 ff = make_real4((-dEdAngle*normBC)/normCross1, dot(v0, v1)*dp, dot(v2, v1)*dp, (dEdAngle*normBC)/normCross2);\n"
"real3 force1 = ff.x*cp0;\n"
"real3 force4 = ff.w*cp1;\n"
"real3 s = ff.y*force1 - ff.z*force4;\n"
"real3 force2 = s-force1;\n"
"real3 force3 = -s-force4;\n"
"";
const string CommonKernelSources::verlet = "/**\n"
" * Perform the first step of Verlet integration.\n"
" */\n"
"\n"
"KERNEL void integrateVerletPart1(int numAtoms, int paddedNumAtoms, GLOBAL const mixed2* RESTRICT dt, GLOBAL const real4* RESTRICT posq,\n"
"        GLOBAL mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force, GLOBAL mixed4* RESTRICT posDelta\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL const real4* RESTRICT posqCorrection\n"
"#endif\n"
"    ) {\n"
"    const mixed2 stepSize = dt[0];\n"
"    const mixed dtPos = stepSize.y;\n"
"    const mixed dtVel = 0.5f*(stepSize.x+stepSize.y);\n"
"    const mixed scale = dtVel/(mixed) 0x100000000;\n"
"    for (int index = GLOBAL_ID; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            velocity.x += scale*force[index]*velocity.w;\n"
"            velocity.y += scale*force[index+paddedNumAtoms]*velocity.w;\n"
"            velocity.z += scale*force[index+paddedNumAtoms*2]*velocity.w;\n"
"            pos.x = velocity.x*dtPos;\n"
"            pos.y = velocity.y*dtPos;\n"
"            pos.z = velocity.z*dtPos;\n"
"            posDelta[index] = pos;\n"
"            velm[index] = velocity;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Verlet integration.\n"
" */\n"
"\n"
"KERNEL void integrateVerletPart2(int numAtoms, GLOBAL mixed2* RESTRICT dt, GLOBAL real4* RESTRICT posq,\n"
"        GLOBAL mixed4* RESTRICT velm, GLOBAL const mixed4* RESTRICT posDelta\n"
"#ifdef USE_MIXED_PRECISION\n"
"        , GLOBAL real4* RESTRICT posqCorrection\n"
"#endif\n"
"    ) {\n"
"    mixed2 stepSize = dt[0];\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    double oneOverDt = 1.0/stepSize.y;\n"
"#else\n"
"    float oneOverDt = 1.0f/stepSize.y;\n"
"    float correction = (1.0f-oneOverDt*stepSize.y)/stepSize.y;\n"
"#endif\n"
"    if (GLOBAL_ID == 0)\n"
"        dt[0].x = stepSize.y;\n"
"    SYNC_THREADS;\n"
"    int index = GLOBAL_ID;\n"
"    for (; index < numAtoms; index += GLOBAL_SIZE) {\n"
"        mixed4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"            real4 pos1 = posq[index];\n"
"            real4 pos2 = posqCorrection[index];\n"
"            mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"            real4 pos = posq[index];\n"
"#endif\n"
"            mixed4 delta = posDelta[index];\n"
"            pos.x += delta.x;\n"
"            pos.y += delta.y;\n"
"            pos.z += delta.z;\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"            velocity = make_mixed4((mixed) (delta.x*oneOverDt), (mixed) (delta.y*oneOverDt), (mixed) (delta.z*oneOverDt), velocity.w);\n"
"#else\n"
"            velocity = make_mixed4((mixed) (delta.x*oneOverDt+delta.x*correction), (mixed) (delta.y*oneOverDt+delta.y*correction), (mixed) (delta.z*oneOverDt+delta.z*correction), velocity.w);\n"
"#endif\n"
"#ifdef USE_MIXED_PRECISION\n"
"            posq[index] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"            posqCorrection[index] = make_real4(pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"            posq[index] = pos;\n"
"#endif\n"
"            velm[index] = velocity;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Select the step size to use for the next step.\n"
" */\n"
"\n"
"KERNEL void selectVerletStepSize(int numAtoms, int paddedNumAtoms, mixed maxStepSize, mixed errorTol, GLOBAL mixed2* RESTRICT dt, GLOBAL const mixed4* RESTRICT velm, GLOBAL const mm_long* RESTRICT force) {\n"
"    // Calculate the error.\n"
"\n"
"    LOCAL mixed error[256];\n"
"    mixed err = 0;\n"
"    const mixed scale = RECIP((mixed) 0x100000000);\n"
"    for (int index = LOCAL_ID; index < numAtoms; index += LOCAL_SIZE) {\n"
"        mixed3 f = make_mixed3(scale*force[index], scale*force[index+paddedNumAtoms], scale*force[index+paddedNumAtoms*2]);\n"
"        mixed invMass = velm[index].w;\n"
"        err += (f.x*f.x + f.y*f.y + f.z*f.z)*invMass*invMass;\n"
"    }\n"
"    error[LOCAL_ID] = err;\n"
"    SYNC_THREADS;\n"
"\n"
"    // Sum the errors from all threads.\n"
"\n"
"    for (unsigned int offset = 1; offset < LOCAL_SIZE; offset *= 2) {\n"
"        if (LOCAL_ID+offset < LOCAL_SIZE && (LOCAL_ID&(2*offset-1)) == 0)\n"
"            error[LOCAL_ID] += error[LOCAL_ID+offset];\n"
"        SYNC_THREADS;\n"
"    }\n"
"    if (LOCAL_ID == 0) {\n"
"        mixed totalError = SQRT(error[0]/(numAtoms*3));\n"
"        mixed newStepSize = SQRT(errorTol/totalError);\n"
"        mixed oldStepSize = dt[0].y;\n"
"        if (oldStepSize > 0.0f)\n"
"            newStepSize = min(newStepSize, oldStepSize*2.0f); // For safety, limit how quickly dt can increase.\n"
"        if (newStepSize > oldStepSize && newStepSize < 1.1f*oldStepSize)\n"
"            newStepSize = oldStepSize; // Keeping dt constant between steps improves the behavior of the integrator.\n"
"        if (newStepSize > maxStepSize)\n"
"            newStepSize = maxStepSize;\n"
"        dt[0].y = newStepSize;\n"
"    }\n"
"}\n"
"";
